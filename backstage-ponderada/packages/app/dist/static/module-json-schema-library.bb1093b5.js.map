{"version":3,"file":"static/module-json-schema-library.bb1093b5.js","mappings":"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","sources":["webpack://app/../../node_modules/json-schema-library/dist/module/lib/config/strings.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getTypeOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/render.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/__.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/config/settings.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/schema/createOneOfSchemaResult.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/types.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/filter.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/features/oneOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/merge.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/mergeSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/omit.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/copy.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/features/if.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/features/allOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/isObject.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/features/dependencies.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/features/anyOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/reduceSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/schema/types.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/schema/getTypeId.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/schema/getTypeDefs.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/eachSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/joinScope.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/splitRef.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/getRef.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compileSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/each.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/errors.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/format.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getTemplate.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/isValid.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/keyword.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/createSchemaOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/step.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/type.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validate.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft04/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/validation/type.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft07/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveRef.merge.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/index.js"],"sourcesContent":["/* eslint max-len: 0 */\nexport default {\n    // validation errors\n    AdditionalItemsError: \"Array at `{{pointer}}` may not have an additional item `{{key}}`\",\n    AdditionalPropertiesError: \"Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`\",\n    AllOfError: \"Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`\",\n    AnyOfError: \"Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`\",\n    ConstError: \"Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`\",\n    containsAnyError: \"The array at `{{pointer}}` must contain at least one item\",\n    ContainsArrayError: \"The property at `{{pointer}}` must not be an array\",\n    ContainsError: \"The array at `{{pointer}}` must contain an element that matches `{{schema}}`\",\n    EnumError: \"Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`\",\n    ForbiddenPropertyError: \"Property name `{{property}}` at `{{pointer}}` is not allowed\",\n    FormatDateError: \"Value `{{value}}` at `{{pointer}}` is not a valid date\",\n    FormatDateTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid date-time\",\n    FormatEmailError: \"Value `{{value}}` at `{{pointer}}` is not a valid email\",\n    FormatHostnameError: \"Value `{{value}}` at `{{pointer}}` is not a valid hostname\",\n    FormatIPV4Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address\",\n    FormatIPV4LeadingZeroError: \"IPv4 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatIPV6Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address\",\n    FormatIPV6LeadingZeroError: \"IPv6 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatJsonPointerError: \"Value `{{value}}` at `{{pointer}}` is not a valid json-pointer\",\n    FormatRegExError: \"Value `{{value}}` at `{{pointer}}` is not a valid regular expression\",\n    FormatTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid time\",\n    FormatURIError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri\",\n    FormatURIReferenceError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-reference\",\n    FormatURITemplateError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-template\",\n    FormatURLError: \"Value `{{value}}` at `{{pointer}}` is not a valid url\",\n    InvalidDataError: \"No value may be specified in `{{pointer}}`\",\n    InvalidPropertyNameError: \"Invalid property name `{{property}}` at `{{pointer}}`\",\n    MaximumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum\",\n    MaxItemsError: \"Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MaxLengthError: \"Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.\",\n    MaxPropertiesError: \"Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MinimumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum\",\n    MinItemsError: \"Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`\",\n    MinItemsOneError: \"At least one item is required in `{{pointer}}`\",\n    MinLengthError: \"Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.\",\n    MinLengthOneError: \"A value is required in `{{pointer}}`\",\n    MinPropertiesError: \"Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\n    MissingDependencyError: \"The required propery '{{missingProperty}}' in `{{pointer}}` is missing\",\n    MissingOneOfPropertyError: \"Value at `{{pointer}}` property: `{{property}}`\",\n    MultipleOfError: \"Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`\",\n    MultipleOneOfError: \"Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`\",\n    NoAdditionalPropertiesError: \"Additional property `{{property}}` in `{{pointer}}` is not allowed\",\n    NotError: \"Value `{{value}}` at pointer should not match schema `{{not}}`\",\n    OneOfError: \"Value `{{value}}` in `{{pointer}}` does not match any given oneof schema\",\n    OneOfPropertyError: \"Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`\",\n    PatternError: \"Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`\",\n    PatternPropertiesError: \"Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}\",\n    RequiredPropertyError: \"The required property `{{key}}` is missing at `{{pointer}}`\",\n    SchemaWarning: \"Failed retrieving a schema from '{{pointer}}' to key '{{key}}'\",\n    TypeError: \"Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`\",\n    UndefinedValueError: \"Value must not be undefined in `{{pointer}}`\",\n    UniqueItemsError: \"Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.\",\n    UnknownPropertyError: \"Could not find a valid schema for property `{{pointer}}` within object\",\n    ValueNotEmptyError: \"A value for `{{property}}` is required at `{{pointer}}`\"\n};\n","const toString = Object.prototype.toString;\nexport default function getTypeOf(value) {\n    const type = toString\n        .call(value)\n        .match(/\\s([^\\]]+)\\]/)\n        .pop()\n        .toLowerCase();\n    if (type === \"file\") {\n        return \"object\";\n    }\n    return type;\n}\n","import getTypeOf from \"../getTypeOf\";\nconst OBJECT_TYPE = \"object\";\nconst ARRAY_TYPE = \"array\";\n/**\n * Renders data into a string by {{variables}}.\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\n *\n * @param template - template string containing variables in handelbars/mustache style\n * @param data - flat object containing properties matching variables\n * @return rendered string\n */\nexport default function render(template, data = {}) {\n    return template.replace(/\\{\\{\\w+\\}\\}/g, (match) => {\n        const key = match.replace(/[{}]/g, \"\");\n        const variable = data[key];\n        const variableType = getTypeOf(variable);\n        if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {\n            return JSON.stringify(variable);\n        }\n        return variable;\n    });\n}\n","import strings from \"../config/strings\";\nimport render from \"./render\";\n/**\n * Renders the given string as defined in __@see config/strings.js__\n * @param keyword\n * @param data - template data\n * @param fallback - fallback template\n * @return resulting string\n */\nexport default function __(keyword, data, fallback = keyword) {\n    var _a;\n    const template = (_a = strings[keyword]) !== null && _a !== void 0 ? _a : fallback;\n    return render(template, data);\n}\n","import __ from \"./__\";\nfunction dashCase(text) {\n    return text.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nexport function createError(name, data) {\n    return {\n        type: \"error\",\n        name,\n        code: dashCase(name),\n        message: __(name, data),\n        data\n    };\n}\n/**\n * Creates a custom Error Creator. Its messages are defined by strings-object @see config/strings.ts\n *\n * @param name - id of error (camelcased)\n * @return error constructor function\n */\nexport function createCustomError(name) {\n    return createError.bind(null, name);\n}\n","export default function flattenArray(list, result = []) {\n    for (let i = 0; i < list.length; i += 1) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n            flattenArray(item, result);\n        }\n        else {\n            result.push(item);\n        }\n    }\n    return result;\n}\n","export default {\n    DECLARATOR_ONEOF: \"oneOfProperty\",\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\n    propertyBlacklist: [\"_id\"],\n    templateDefaultOptions: {\n        addOptionalProps: false,\n        removeInvalidData: false,\n        extendDefaults: true\n    }\n};\n","export function createOneOfSchemaResult(schema, oneOfSchema, oneOfIndex) {\n    const childSchema = { ...oneOfSchema };\n    Object.defineProperty(childSchema, \"getOneOfOrigin\", {\n        enumerable: false,\n        value: () => ({\n            index: oneOfIndex,\n            schema\n        })\n    });\n    return childSchema;\n}\n","/**\n * ts type guard for json error\n * @returns true if passed type is a JsonError\n */\nexport function isJsonError(error) {\n    return (error === null || error === void 0 ? void 0 : error.type) === \"error\";\n}\n","import { isJsonError } from \"../types\";\nexport function isPromise(obj) {\n    return obj instanceof Promise;\n}\nexport function errorOrPromise(error) {\n    return isJsonError(error) || isPromise(error);\n}\nexport function errorsOnly(error) {\n    return isJsonError(error);\n}\n","/**\n * @draft-04\n */\nimport flattenArray from \"../utils/flattenArray\";\nimport getTypeOf from \"../getTypeOf\";\nimport settings from \"../config/settings\";\nimport { createOneOfSchemaResult } from \"../schema/createOneOfSchemaResult\";\nimport { errorOrPromise } from \"../utils/filter\";\nimport { isJsonError } from \"../types\";\nconst { DECLARATOR_ONEOF } = settings;\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft - validator\n * @param data\n * @param schema - current json schema containing property oneOf\n * @param pointer - json pointer to data\n * @return oneOf schema or an error\n */\nexport function resolveOneOf(draft, data, schema = draft.rootSchema, pointer = \"#\") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);\n            if (isJsonError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return createOneOfSchemaResult(schema, one, i); // return resolved schema\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    const matches = [];\n    const errors = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = draft.resolveRef(schema.oneOf[i]);\n        let result = flattenArray(draft.validate(data, one, pointer));\n        result = result.filter(errorOrPromise);\n        if (result.length > 0) {\n            errors.push(...result);\n        }\n        else {\n            matches.push({ index: i, schema: one });\n        }\n    }\n    if (matches.length === 1) {\n        return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index); // return resolved schema\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({\n            value: data,\n            pointer,\n            schema,\n            matches\n        });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf,\n        errors\n    });\n}\n/**\n * Returns a ranking for the data and given schema\n *\n * @param draft\n * @param - json schema type: object\n * @param data\n * @param [pointer]\n * @return ranking value (higher is better)\n */\nfunction fuzzyObjectValue(draft, one, data, pointer) {\n    if (data == null || one.properties == null) {\n        return -1;\n    }\n    let value = 0;\n    const keys = Object.keys(one.properties);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (data[key] != null && draft.isValid(data[key], one.properties[key], pointer)) {\n            value += 1;\n        }\n    }\n    return value;\n}\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft\n * @param data\n * @param [schema] - current json schema containing property oneOf\n * @param [pointer] - json pointer to data\n * @return oneOf schema or an error\n */\nexport function resolveOneOfFuzzy(draft, data, schema = draft.rootSchema, pointer = \"#\") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);\n            if (isJsonError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return createOneOfSchemaResult(schema, one, i);\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    // keyword: oneOf\n    const matches = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = draft.resolveRef(schema.oneOf[i]);\n        if (draft.isValid(data, one, pointer)) {\n            matches.push({ schema: one, index: i });\n        }\n    }\n    if (matches.length === 1) {\n        return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index);\n    }\n    // fuzzy match oneOf\n    if (getTypeOf(data) === \"object\") {\n        let schemaOfItem;\n        let schemaOfIndex = -1;\n        let fuzzyGreatest = 0;\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const fuzzyValue = fuzzyObjectValue(draft, one, data);\n            if (fuzzyGreatest < fuzzyValue) {\n                fuzzyGreatest = fuzzyValue;\n                schemaOfItem = schema.oneOf[i];\n                schemaOfIndex = i;\n            }\n        }\n        if (schemaOfItem === undefined) {\n            return draft.errors.oneOfError({\n                value: JSON.stringify(data),\n                pointer,\n                schema,\n                oneOf: schema.oneOf\n            });\n        }\n        return createOneOfSchemaResult(schema, schemaOfItem, schemaOfIndex);\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf\n    });\n}\n/**\n * validates oneOf definition for given input data\n */\nconst validateOneOf = (draft, schema, value, pointer) => {\n    if (Array.isArray(schema.oneOf)) {\n        const schemaOrError = draft.resolveOneOf(value, schema, pointer);\n        if (isJsonError(schemaOrError)) {\n            return schemaOrError;\n        }\n    }\n};\nexport { validateOneOf };\n","import deepmerge from \"deepmerge\";\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport default (a, b) => deepmerge(a, b, { arrayMerge: overwriteMerge });\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\nconst mergeUniqueItems = (destinationArray, sourceArray) => {\n    const all = destinationArray.concat(sourceArray);\n    return all.filter((item, pos) => all.indexOf(item) === pos);\n};\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport const mergeArraysUnique = (a, b) => deepmerge(a, b, { arrayMerge: mergeUniqueItems });\n","import { mergeArraysUnique } from \"./utils/merge\";\nimport getTypeOf from \"./getTypeOf\";\n/**\n * merges to two json schema. In case of conflicts, will use overwrite first\n * schema or directly return first json schema.\n */\nexport function mergeSchema(a, b) {\n    const aType = getTypeOf(a);\n    const bType = getTypeOf(b);\n    if (aType !== bType) {\n        return a;\n    }\n    const result = mergeArraysUnique(a, b);\n    if (a.getOneOfOrigin) {\n        Object.defineProperty(result, \"getOneOfOrigin\", {\n            enumerable: false,\n            value: a.getOneOfOrigin\n        });\n    }\n    else if (b.getOneOfOrigin) {\n        Object.defineProperty(result, \"getOneOfOrigin\", {\n            enumerable: false,\n            value: b.getOneOfOrigin\n        });\n    }\n    return result;\n}\n","/**\n * Omit properties from input object. Accepts any number of properties to\n * remove. Example:\n *\n * ```ts\n * omit(myObject, \"if\", \"dependencies\");\n * ```\n *\n * @returns shallow copy of input object without specified properties\n */\nexport function omit(object, ...keysToOmit) {\n    const result = {};\n    Object.keys(object).forEach((key) => {\n        if (!keysToOmit.includes(key)) {\n            result[key] = object[key];\n        }\n    });\n    if (object.getOneOfOrigin) {\n        Object.defineProperty(result, \"getOneOfOrigin\", {\n            enumerable: false,\n            value: object.getOneOfOrigin\n        });\n    }\n    return result;\n}\n","import copy from \"fast-copy\";\nexport default copy;\n","/**\n * returns if-then-else as a json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns json schema defined by if-then-else or undefined\n */\nexport function resolveIfSchema(draft, schema, data) {\n    if (schema.if == null) {\n        return undefined;\n    }\n    if (schema.if === false) {\n        return schema.else;\n    }\n    if (schema.if && (schema.then || schema.else)) {\n        const ifErrors = draft.validate(data, draft.resolveRef(schema.if));\n        if (ifErrors.length === 0 && schema.then) {\n            return draft.resolveRef(schema.then);\n        }\n        if (ifErrors.length !== 0 && schema.else) {\n            return draft.resolveRef(schema.else);\n        }\n    }\n}\n/**\n * @returns validation result of it-then-else schema\n */\nconst validateIf = (draft, schema, value, pointer) => {\n    const resolvedSchema = resolveIfSchema(draft, schema, value);\n    if (resolvedSchema) {\n        return draft.validate(value, resolvedSchema, pointer);\n    }\n};\nexport { validateIf };\n","import { mergeSchema } from \"../mergeSchema\";\nimport { omit } from \"../utils/omit\";\nimport copy from \"../utils/copy\";\nimport { resolveIfSchema } from \"./if\";\n/**\n * resolves schema\n * when complete this will have much duplication to step.object etc\n */\nexport function resolveSchema(draft, schemaToResolve, data) {\n    var _a;\n    const schema = { ...((_a = draft.resolveRef(schemaToResolve)) !== null && _a !== void 0 ? _a : {}) };\n    const ifSchema = resolveIfSchema(draft, schema, data);\n    if (ifSchema) {\n        return ifSchema;\n    }\n    return omit(schema, \"if\", \"then\", \"else\");\n}\nexport function resolveAllOf(draft, data, schema = draft.rootSchema) {\n    let mergedSchema = copy(schema);\n    for (let i = 0; i < schema.allOf.length; i += 1) {\n        // @todo introduce draft.resolveSchema to iteratively resolve\n        const allOfSchema = resolveSchema(draft, schema.allOf[i], data);\n        mergedSchema = mergeSchema(mergedSchema, allOfSchema);\n    }\n    delete mergedSchema.allOf;\n    return mergedSchema;\n}\n/**\n * @attention: subschemas have to be resolved upfront (e.g. if-else that do not apply)\n * Merge all allOf sub schema into a single schema. Returns undefined for\n * missing allOf definition.\n *\n * @returns json schema defined by allOf or undefined\n */\nexport function mergeAllOfSchema(draft, schema) {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    let resolvedSchema = {};\n    allOf.forEach((subschema) => {\n        resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(subschema));\n    });\n    return resolvedSchema;\n}\n/**\n * validate allOf definition for given input data\n */\nconst validateAllOf = (draft, schema, value, pointer) => {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    const errors = [];\n    schema.allOf.forEach((subSchema) => {\n        errors.push(...draft.validate(value, subSchema, pointer));\n    });\n    return errors;\n};\nexport { validateAllOf };\n","/**\n * @returns list with unique values only\n */\nexport function uniqueItems(list) {\n    return list.filter((item, index) => list.indexOf(item) === index);\n}\n","import getTypeOf from \"../getTypeOf\";\nexport function isObject(v) {\n    return getTypeOf(v) === \"object\";\n}\n","import getTypeOf from \"../getTypeOf\";\nimport { mergeSchema } from \"../mergeSchema\";\nimport { uniqueItems } from \"../utils/uniqueItems\";\nimport { isObject } from \"../utils/isObject\";\n/**\n * returns dependencies as an object json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns merged json schema defined by dependencies or undefined\n */\nexport function resolveDependencies(draft, schema, data) {\n    const { dependencies } = schema;\n    if (!isObject(dependencies) || !isObject(data)) {\n        return;\n    }\n    let updated = false;\n    let resolvedSchema = { required: [] };\n    Object.keys(dependencies).forEach((prop) => {\n        var _a, _b;\n        if (data[prop] == null &&\n            !(((_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {\n            return;\n        }\n        const dependency = dependencies[prop];\n        // dependency array\n        if (Array.isArray(dependency)) {\n            updated = true;\n            resolvedSchema.required.push(...dependency);\n            return;\n        }\n        // dependency schema\n        if (isObject(dependency)) {\n            updated = true;\n            resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(dependency));\n            return;\n        }\n    });\n    if (updated) {\n        resolvedSchema.required = uniqueItems(resolvedSchema.required);\n        return resolvedSchema;\n    }\n}\n/**\n * validate dependencies definition for given input data\n */\nconst validateDependencies = (draft, schema, value, pointer) => {\n    if (getTypeOf(schema.dependencies) !== \"object\") {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        if (schema.dependencies[property] === undefined) {\n            return;\n        }\n        // @draft >= 6 boolean schema\n        if (schema.dependencies[property] === true) {\n            return;\n        }\n        if (schema.dependencies[property] === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        let dependencyErrors;\n        const type = getTypeOf(schema.dependencies[property]);\n        if (type === \"array\") {\n            dependencyErrors = schema.dependencies[property]\n                .filter((dependency) => value[dependency] === undefined)\n                .map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));\n        }\n        else if (type === \"object\") {\n            dependencyErrors = draft.validate(value, schema.dependencies[property], pointer);\n        }\n        else {\n            throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);\n        }\n        errors.push(...dependencyErrors);\n    });\n    return errors.length > 0 ? errors : undefined;\n};\nexport { validateDependencies };\n","/**\n * @draft-04\n */\nimport { mergeSchema } from \"../mergeSchema\";\nimport { omit } from \"../utils/omit\";\n/**\n * returns merged schema of all valid anyOf subschemas for the given input data.\n * Does not merge with rest input schema.\n *\n * @returns merged anyOf subschemas which are valid to the given input data.\n */\nexport function mergeValidAnyOfSchema(draft, schema, data) {\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return;\n    }\n    let resolvedSchema;\n    schema.anyOf.forEach((anySchema) => {\n        anySchema = draft.resolveRef(anySchema);\n        if (draft.isValid(data, anySchema)) {\n            resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anySchema) : anySchema;\n        }\n    });\n    return resolvedSchema;\n}\n/**\n * @returns extended input schema with valid anyOf subschemas or JsonError if\n * no anyOf schema matches input data\n */\nexport function resolveAnyOf(draft, data, schema = draft.rootSchema, pointer = \"#\") {\n    const { anyOf } = schema;\n    if (!Array.isArray(anyOf) || anyOf.length === 0) {\n        return schema;\n    }\n    const resolvedSchema = mergeValidAnyOfSchema(draft, schema, data);\n    if (resolvedSchema == null) {\n        return draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });\n    }\n    const mergedSchema = mergeSchema(schema, resolvedSchema);\n    return omit(mergedSchema, \"anyOf\");\n}\n/**\n * validate anyOf definition for given input data\n */\nconst validateAnyOf = (draft, schema, value, pointer) => {\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return undefined;\n    }\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\n        if (draft.isValid(value, schema.anyOf[i])) {\n            return undefined;\n        }\n    }\n    return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });\n};\nexport { validateAnyOf };\n","import { isJsonError } from \"./types\";\nimport { mergeSchema } from \"./mergeSchema\";\nimport { resolveIfSchema } from \"./features/if\";\nimport { resolveDependencies } from \"./features/dependencies\";\nimport { mergeAllOfSchema } from \"./features/allOf\";\nimport { mergeValidAnyOfSchema } from \"./features/anyOf\";\nimport { resolveOneOfFuzzy as resolveOneOf } from \"./features/oneOf\";\nimport { omit } from \"./utils/omit\";\nconst toOmit = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\", \"then\", \"else\"];\nconst dynamicProperties = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\"];\nexport function isDynamicSchema(schema) {\n    const givenProps = Object.keys(schema);\n    return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;\n}\n/**\n * @note this utility does not reference draft methods for resolution\n * @todo consider using draft methods\n *\n * Resolves all dynamic schema definitions for the given input data and returns\n * the resulting json-schema without any dynamic schema definitions. The result\n * is not merged with the original input schema, thus static definitions of the\n * input schema are untouched and missing. For a full schema definition of this\n * input data you have to merge the result with the original schema\n * (@see reduceSchema)\n *\n * dynamic schema definitions: dependencies, allOf, anyOf, oneOf, if\n *\n * @returns static schema from resolved dynamic schema definitions for this\n *  specific input data\n */\nexport function resolveDynamicSchema(draft, schema, data, pointer) {\n    let resolvedSchema;\n    let error;\n    schema = draft.resolveRef(schema);\n    // @feature oneOf\n    if (schema.oneOf) {\n        const oneOfSchema = resolveOneOf(draft, data, schema, pointer);\n        if (isJsonError(oneOfSchema)) {\n            error = oneOfSchema;\n        }\n        else if (oneOfSchema) {\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema);\n        }\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const allOf = schema.allOf.map((s) => {\n            // before merging allOf schema we need to resolve all subschemas\n            // if not, we would wrongly merge oneOf, if-then statements, etc\n            if (isDynamicSchema(s)) {\n                // copy of reduceSchema\n                let result = resolveDynamicSchema(draft, s, data, pointer);\n                if (result) {\n                    result = mergeSchema(s, result);\n                    return omit(result, ...toOmit);\n                }\n                return undefined;\n            }\n            return s;\n        });\n        if (allOf.length > 0) {\n            const allOfSchema = mergeAllOfSchema(draft, { allOf });\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);\n        }\n    }\n    // @feature anyOf\n    const anyOfSchema = mergeValidAnyOfSchema(draft, schema, data);\n    if (anyOfSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyOfSchema);\n    }\n    // @feature dependencies\n    const dependenciesSchema = resolveDependencies(draft, schema, data);\n    if (dependenciesSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);\n    }\n    // @feature if-then-else\n    const ifSchema = resolveIfSchema(draft, schema, data);\n    if (ifSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifSchema);\n    }\n    if (resolvedSchema == null) {\n        return error;\n    }\n    const nestedSchema = resolveDynamicSchema(draft, resolvedSchema, data, pointer);\n    if (nestedSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema, nestedSchema);\n    }\n    return omit(resolvedSchema, ...toOmit);\n}\n","import { mergeSchema } from \"./mergeSchema\";\nimport { resolveDynamicSchema } from \"./resolveDynamicSchema\";\nimport { omit } from \"./utils/omit\";\nconst toOmit = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\", \"then\", \"else\"];\n/**\n * reduces json schema by merging dynamic constructs like if-then-else,\n * dependencies, allOf, anyOf, oneOf, etc into a static json schema\n * omitting those properties.\n *\n * @returns input schema reduced by dynamic schema definitions for the given\n * input data\n */\nexport function reduceSchema(draft, schema, data, pointer) {\n    let resolvedSchema = resolveDynamicSchema(draft, schema, data, pointer);\n    if (resolvedSchema) {\n        resolvedSchema = mergeSchema(schema, resolvedSchema);\n        return omit(resolvedSchema, ...toOmit);\n    }\n    return schema;\n}\n","import copy from \"../utils/copy\";\nexport class Draft {\n    constructor(config, schema) {\n        /** cache for remote schemas */\n        this.remotes = {};\n        /** error creators by id */\n        this.errors = {};\n        /** map for valid keywords of a type  */\n        this.typeKeywords = {};\n        /** keyword validators  */\n        this.validateKeyword = {};\n        /** type validators  */\n        this.validateType = {};\n        /** format validators  */\n        this.validateFormat = {};\n        this.config = config;\n        this.typeKeywords = copy(config.typeKeywords);\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\n        this.validateType = Object.assign({}, config.validateType);\n        this.validateFormat = Object.assign({}, config.validateFormat);\n        this.errors = Object.assign({}, config.errors);\n        this.setSchema(schema);\n    }\n    get rootSchema() {\n        return this.__rootSchema;\n    }\n    set rootSchema(rootSchema) {\n        if (rootSchema == null) {\n            return;\n        }\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\n    }\n    /**\n     * register a json-schema to be referenced from another json-schema\n     * @param url - base-url of json-schema (aka id)\n     * @param schema - json-schema root\n     */\n    addRemoteSchema(url, schema) {\n        this.config.addRemoteSchema(this, url, schema);\n    }\n    compileSchema(schema) {\n        var _a;\n        return this.config.compileSchema(this, schema, (_a = this.rootSchema) !== null && _a !== void 0 ? _a : schema);\n    }\n    createSchemaOf(data) {\n        return this.config.createSchemaOf(data);\n    }\n    /**\n     * Iterates over data, retrieving its schema\n     *\n     * @param data - the data to iterate\n     * @param callback - will be called with (schema, data, pointer) on each item\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\n     * @param [pointer] - pointer to current data. Default to rootPointer\n     */\n    each(data, callback, schema, pointer) {\n        return this.config.each(this, data, callback, schema, pointer);\n    }\n    eachSchema(callback, schema = this.rootSchema) {\n        return this.config.eachSchema(schema, callback);\n    }\n    getChildSchemaSelection(property, schema) {\n        return this.config.getChildSchemaSelection(this, property, schema);\n    }\n    /**\n     * Returns the json-schema of a data-json-pointer.\n     *\n     * To resolve dynamic schema where the type of json-schema is evaluated by\n     * its value, a data object has to be passed in options.\n     *\n     * Per default this function will return `undefined` for valid properties that\n     * do not have a defined schema. Use the option `withSchemaWarning: true` to\n     * receive an error with `code: schema-warning` containing the location of its\n     * last evaluated json-schema.\n     *\n     * Notes\n     *      - uses draft.step to walk through data and schema\n     *\n     * @param draft\n     * @param pointer - json pointer in data to get the json schema for\n     * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n     * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n     * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n     * @return resolved json-schema object of requested json-pointer location\n     */\n    getSchema(options) {\n        return this.config.getSchema(this, options);\n    }\n    /**\n     * Create data object matching the given schema\n     *\n     * @param [data] - optional template data\n     * @param [schema] - json schema, defaults to rootSchema\n     * @return created template data\n     */\n    getTemplate(data, schema, opts = this.config.templateDefaultOptions) {\n        return this.config.getTemplate(this, data, schema, opts);\n    }\n    isValid(data, schema, pointer) {\n        return this.config.isValid(this, data, schema, pointer);\n    }\n    resolveAnyOf(data, schema, pointer) {\n        return this.config.resolveAnyOf(this, data, schema, pointer);\n    }\n    resolveAllOf(data, schema) {\n        return this.config.resolveAllOf(this, data, schema);\n    }\n    resolveRef(schema) {\n        return this.config.resolveRef(schema, this.rootSchema);\n    }\n    resolveOneOf(data, schema, pointer) {\n        return this.config.resolveOneOf(this, data, schema, pointer);\n    }\n    setSchema(schema) {\n        this.rootSchema = schema;\n    }\n    /**\n     * Returns the json-schema of the given object property or array item.\n     * e.g. it steps by one key into the data\n     *\n     *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n     *  returns the correct schema.\n     *\n     * @param  key       - property-name or array-index\n     * @param  schema    - json schema of current data\n     * @param  data      - parent of key\n     * @param  [pointer] - pointer to schema and data (parent of key)\n     * @return Schema or Error if failed resolving key\n     */\n    step(key, schema, data, pointer) {\n        return this.config.step(this, key, schema, data, pointer);\n    }\n    /**\n     * Validate data by a json schema\n     *\n     * @param value - value to validate\n     * @param [schema] - json schema, defaults to rootSchema\n     * @param [pointer] - json pointer pointing to value (used for error-messages only)\n     * @return list of errors or empty\n     */\n    validate(data, schema, pointer) {\n        return this.config.validate(this, data, schema, pointer);\n    }\n}\n","/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nexport default function addRemoteSchema(draft, url, schema) {\n    schema.id = schema.id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n","const Types = {\n    $ref: {\n        type: false\n    },\n    allOf: {\n        type: false,\n        definitions: [\"allOf/*\"]\n    },\n    anyOf: {\n        type: false,\n        definitions: [\"anyOf/*\"]\n    },\n    array: {\n        type: true,\n        // ignore additionalItems:TypeDef, when items:TypeDef\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"items\",\n            \"items/*\",\n            \"additionalItems\"\n        ],\n        validationKeywords: [\"minItems\", \"maxItems\", \"uniqueItems\"],\n        keywords: [\"items\", \"additionalItems\", \"minItems\", \"maxItems\", \"uniqueItems\"]\n    },\n    boolean: {\n        type: true\n    },\n    enum: {\n        type: false\n    },\n    integer: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    not: {\n        type: false,\n        definitions: [\"not\"]\n    },\n    number: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    null: {\n        type: true\n    },\n    object: {\n        type: true,\n        // patternProperties also validate properties\n        // dependencies:(string, TypeDef) extend current TypeDef\n        // additional Properties validate only remaining properties (after properties & pattern)\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"properties/*\",\n            \"additionalProperties\",\n            \"patternProperties/*\",\n            \"dependencies/*\"\n        ],\n        validationKeywords: [\"minProperties\", \"maxProperties\", \"required\"],\n        keywords: [\n            \"properties\",\n            \"additionalProperties\",\n            \"patternProperties\",\n            \"dependencies\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"required\"\n        ]\n    },\n    oneOf: {\n        type: false,\n        definitions: [\"oneOf/*\"]\n    },\n    string: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minLength\", \"maxLength\", \"pattern\"]\n    }\n};\nexport default Types;\n","import types from \"./types\";\nimport { isObject } from \"../utils/isObject\";\nconst typeKeywords = Object.keys(types).filter((id) => types[id].type === false);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @throws Error    on multiple matches (invalid schema)\n *\n * Returns the type id of a schema object\n * @param schema\n * @return type id, if found\n */\nexport default function getTypeId(schema) {\n    if (isObject(schema) === false) {\n        return undefined;\n    }\n    if (schema.enum) {\n        return \"enum\";\n    }\n    const type = schema.type;\n    if (Array.isArray(type) || types[type]) {\n        return type;\n    }\n    const ids = typeKeywords.filter((type) => schema[type]);\n    if (ids.length === 1) {\n        return ids[0];\n    }\n    if (ids.length === 0) {\n        // @expensive, guess type object\n        for (let i = 0, l = types.object.keywords.length; i < l; i += 1) {\n            const keyword = types.object.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"object\";\n            }\n        }\n        // @expensive, guess type array\n        for (let i = 0, l = types.array.keywords.length; i < l; i += 1) {\n            const keyword = types.array.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"array\";\n            }\n        }\n        return undefined;\n    }\n    throw new Error(`Mutiple typeIds [${ids.join(\", \")}] matched in ${JSON.stringify(schema)}`);\n}\n","import gp from \"@sagold/json-pointer\";\nimport { get } from \"@sagold/json-query\";\nimport getTypeId from \"./getTypeId\";\nimport types from \"./types\";\nimport { isObject } from \"../utils/isObject\";\n/**\n * Returns a list of all (direct) type definitions from the given schema\n * @param schema\n * @return list of type definition, given as { pointer, def }\n */\nexport default function getTypeDefs(schema) {\n    const defs = [];\n    const id = getTypeId(schema);\n    if (id == null) {\n        return defs;\n    }\n    let type;\n    if (Array.isArray(id)) {\n        // since types can also be declared as a set of types, merge the definitions\n        // maybe this will require a more sophisticated approach\n        type = {};\n        for (let i = 0, l = id.length; i < l; i += 1) {\n            Object.assign(type, types[id[i]]);\n        }\n    }\n    else {\n        type = types[id];\n    }\n    if (type.definitions == null) {\n        return defs;\n    }\n    type.definitions.forEach((query) => {\n        get(schema, query, (value, key, parent, pointer) => {\n            if (isObject(value) && getTypeId(value)) {\n                defs.push({ pointer: gp.join(gp.split(pointer), false), def: value });\n            }\n        });\n    });\n    return defs;\n}\n","import gp from \"@sagold/json-pointer\";\nimport getTypeDefs from \"./schema/getTypeDefs\";\nimport { isObject } from \"./utils/isObject\";\nfunction nextTypeDefs(schema, pointer) {\n    if (this.callback(schema, pointer) === true) {\n        // eslint-disable-line no-invalid-this\n        return; // stop iteration\n    }\n    const defs = getTypeDefs(schema);\n    // eslint-disable-next-line no-invalid-this\n    defs.forEach((next) => this.nextTypeDefs(next.def, gp.join(pointer, next.pointer, false)));\n}\nfunction eachDefinition(walk, schema, pointer, key = \"definitions\") {\n    const defs = schema[key];\n    Object.keys(defs).forEach((defId) => {\n        if (defs[defId] === false || isObject(defs[defId])) {\n            walk.nextTypeDefs(defs[defId], gp.join(pointer, key, defId, false));\n            return;\n        }\n        // console.log(`Invalid schema in ${pointer}/${key}/${defId}`);\n    });\n}\nexport function eachSchema(schema, callback, pointer = \"#\") {\n    const walk = { callback, nextTypeDefs };\n    walk.nextTypeDefs(schema, pointer);\n    if (schema.definitions != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer);\n    }\n    if (schema.$defs != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer, \"$defs\");\n    }\n}\n","/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nconst suffixes = /(#|\\/)+$/;\nconst trailingHash = /#$/;\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\nconst trailingFragments = /\\/[^/]*$/;\nconst idAndPointer = /#.*$/;\nexport default function joinScope(previous, id) {\n    if (previous == null && id == null) {\n        return \"#\";\n    }\n    if (id == null) {\n        return previous.replace(trailingHash, \"\");\n    }\n    if (previous == null) {\n        return id.replace(trailingHash, \"\");\n    }\n    if (id[0] === \"#\") {\n        return `${previous.replace(idAndPointer, \"\")}${id.replace(suffixes, \"\")}`;\n    }\n    if (isDomain.test(id)) {\n        return id.replace(trailingHash, \"\");\n    }\n    return `${previous.replace(trailingFragments, \"\")}/${id.replace(trailingHash, \"\")}`;\n}\n","const suffixes = /(#|\\/)+$/g;\nconst emptyValues = [\"\", null, \"#\"];\nexport default function splitRef($ref) {\n    if (emptyValues.includes($ref)) {\n        return [];\n    }\n    $ref = $ref.replace(suffixes, \"\");\n    if ($ref.indexOf(\"#\") === -1) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n    if ($ref.indexOf(\"#\") === 0) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n    const result = $ref.split(\"#\");\n    result[0] = result[0].replace(suffixes, \"\");\n    result[1] = `#${result[1].replace(suffixes, \"\")}`;\n    return result;\n}\n","import { get } from \"@sagold/json-pointer\";\nimport splitRef from \"./splitRef\";\nimport getTypeOf from \"../getTypeOf\";\nconst suffixes = /(#|\\/)+$/g;\nconst isObject = (val) => getTypeOf(val) === \"object\";\n// 1. combined is known\n// 2. base or pointer is known\n// 3. base + pointer is known\nexport default function getRef(context, rootSchema, $ref) {\n    if (isObject($ref)) {\n        $ref = $ref.__ref || $ref.$ref;\n    }\n    if ($ref == null) {\n        return rootSchema;\n    }\n    let schema;\n    // is it a known $ref?\n    const $remote = $ref.replace(suffixes, \"\");\n    if (context.remotes[$remote]) {\n        schema = context.remotes[$remote];\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    if (context.ids[$ref]) {\n        schema = get(rootSchema, context.ids[$ref]);\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    // is it a ref with host/pointer?\n    const fragments = splitRef($ref);\n    if (fragments.length === 0) {\n        return rootSchema;\n    }\n    if (fragments.length === 1) {\n        $ref = fragments[0];\n        if (context.remotes[$ref]) {\n            schema = context.remotes[$ref];\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        if (context.ids[$ref]) {\n            schema = get(rootSchema, context.ids[$ref]);\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema.$ref);\n            }\n            return schema;\n        }\n    }\n    if (fragments.length === 2) {\n        const base = fragments[0];\n        $ref = fragments[1];\n        if (context.remotes[base]) {\n            if (context.remotes[base].getRef) {\n                return context.remotes[base].getRef($ref);\n            }\n            // console.log(\"warning: uncompiled remote - context may be wrong\", base);\n            return getRef(context, context.remotes[base], $ref);\n        }\n        if (context.ids[base]) {\n            return getRef(context, get(rootSchema, context.ids[base]), $ref);\n        }\n    }\n    schema = get(rootSchema, context.ids[$ref] || $ref);\n    if (schema && schema.$ref) {\n        return getRef(context, rootSchema, schema.$ref);\n    }\n    return schema;\n}\n","/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { eachSchema } from \"../eachSchema\";\nimport joinScope from \"./joinScope\";\nimport getRef from \"./getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * compiles the input root schema for `$ref` resolution and returns it again\n * @attention this modifies input schema but maintains data-structure and thus returns\n * the same object with JSON.stringify\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param draft\n * @param schemaToCompile - json-schema to compile\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\n * @param [force] = false - force compile json-schema\n * @return compiled input json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    }\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    // flag this schema as compiled\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    // add getRef-helper to this object\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (schemaToCompile !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"definitions\", {\n            enumerable: false,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.id = (_a = parentSchema.id) !== null && _a !== void 0 ? _a : schema.id;\n            }\n            context.ids[schema.id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n    // console.log(JSON.stringify(context.ids, null, 2));\n    return compiledSchema;\n}\n","import compile from \"./compile\";\nexport default compile;\n","import getTypeOf from \"./getTypeOf\";\n/**\n * Iterates over data, retrieving its schema\n *\n * @param draft - validator\n * @param data - the data to iterate\n * @param callback - will be called with (schema, data, pointer) on each item\n * @param [schema] - the schema matching the data. Defaults to rootSchema\n * @param [pointer] - pointer to current data. Default to rootPointer\n */\nexport function each(draft, data, callback, schema = draft.rootSchema, pointer = \"#\") {\n    schema = draft.resolveRef(schema);\n    callback(schema, data, pointer);\n    const dataType = getTypeOf(data);\n    if (dataType === \"object\") {\n        Object.keys(data).forEach((key) => {\n            const nextSchema = draft.step(key, schema, data, pointer); // not save\n            const next = data[key]; // save\n            draft.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n    else if (dataType === \"array\") {\n        data.forEach((next, key) => {\n            const nextSchema = draft.step(key, schema, data, pointer);\n            draft.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n}\n","/* eslint no-invalid-this: 0 */\nimport { createCustomError } from \"../utils/createCustomError\";\nconst errors = {\n    additionalItemsError: createCustomError(\"AdditionalItemsError\"),\n    additionalPropertiesError: createCustomError(\"AdditionalPropertiesError\"),\n    anyOfError: createCustomError(\"AnyOfError\"),\n    allOfError: createCustomError(\"AllOfError\"),\n    constError: createCustomError(\"ConstError\"),\n    containsError: createCustomError(\"ContainsError\"),\n    containsArrayError: createCustomError(\"ContainsArrayError\"),\n    containsAnyError: createCustomError(\"ContainsAnyError\"),\n    enumError: createCustomError(\"EnumError\"),\n    forbiddenPropertyError: createCustomError(\"ForbiddenPropertyError\"),\n    formatURLError: createCustomError(\"FormatURLError\"),\n    formatURIError: createCustomError(\"FormatURIError\"),\n    formatURIReferenceError: createCustomError(\"FormatURIReferenceError\"),\n    formatURITemplateError: createCustomError(\"FormatURITemplateError\"),\n    formatDateError: createCustomError(\"FormatDateError\"),\n    formatDateTimeError: createCustomError(\"FormatDateTimeError\"),\n    formatEmailError: createCustomError(\"FormatEmailError\"),\n    formatHostnameError: createCustomError(\"FormatHostnameError\"),\n    formatIPV4Error: createCustomError(\"FormatIPV4Error\"),\n    formatIPV4LeadingZeroError: createCustomError(\"FormatIPV4LeadingZeroError\"),\n    formatIPV6Error: createCustomError(\"FormatIPV6Error\"),\n    formatIPV6LeadingZeroError: createCustomError(\"FormatIPV6LeadingZeroError\"),\n    formatJsonPointerError: createCustomError(\"FormatJsonPointerError\"),\n    formatRegExError: createCustomError(\"FormatRegExError\"),\n    formatTimeError: createCustomError(\"FormatTimeError\"),\n    invalidSchemaError: createCustomError(\"InvalidSchemaError\"),\n    invalidDataError: createCustomError(\"InvalidDataError\"),\n    invalidTypeError: createCustomError(\"InvalidTypeError\"),\n    invalidPropertyNameError: createCustomError(\"InvalidPropertyNameError\"),\n    maximumError: createCustomError(\"MaximumError\"),\n    maxItemsError: createCustomError(\"MaxItemsError\"),\n    maxLengthError: createCustomError(\"MaxLengthError\"),\n    maxPropertiesError: createCustomError(\"MaxPropertiesError\"),\n    minimumError: createCustomError(\"MinimumError\"),\n    minItemsError: createCustomError(\"MinItemsError\"),\n    minItemsOneError: createCustomError(\"MinItemsOneError\"),\n    minLengthError: createCustomError(\"MinLengthError\"),\n    minLengthOneError: createCustomError(\"MinLengthOneError\"),\n    minPropertiesError: createCustomError(\"MinPropertiesError\"),\n    missingDependencyError: createCustomError(\"MissingDependencyError\"),\n    missingOneOfPropertyError: createCustomError(\"MissingOneOfPropertyError\"),\n    multipleOfError: createCustomError(\"MultipleOfError\"),\n    multipleOneOfError: createCustomError(\"MultipleOneOfError\"),\n    noAdditionalPropertiesError: createCustomError(\"NoAdditionalPropertiesError\"),\n    notError: createCustomError(\"NotError\"),\n    oneOfError: createCustomError(\"OneOfError\"),\n    oneOfPropertyError: createCustomError(\"OneOfPropertyError\"),\n    patternError: createCustomError(\"PatternError\"),\n    patternPropertiesError: createCustomError(\"PatternPropertiesError\"),\n    requiredPropertyError: createCustomError(\"RequiredPropertyError\"),\n    schemaWarning: createCustomError(\"SchemaWarning\"),\n    typeError: createCustomError(\"TypeError\"),\n    undefinedValueError: createCustomError(\"UndefinedValueError\"),\n    uniqueItemsError: createCustomError(\"UniqueItemsError\"),\n    unknownPropertyError: createCustomError(\"UnknownPropertyError\"),\n    valueNotEmptyError: createCustomError(\"ValueNotEmptyError\")\n};\nexport default errors;\n","import validUrl from \"valid-url\";\nimport { parse as parseIdnEmail } from \"smtp-address-parser\";\n// referenced\n// https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n// https://gist.github.com/marcelotmelo/b67f58a08bee6c2468f8\nconst isValidDateTime = new RegExp(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\\\.[0-9]+)?(([Zz])|([\\\\+|\\\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$\");\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\n// const matchTime = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst matchTime = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst isValidJsonPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst isValidURIRef = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst isValidURITemplate = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// Default Json-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\nconst formatValidators = {\n    date: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        const matches = value.match(matchDate);\n        if (!matches) {\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        // https://tools.ietf.org/html/rfc3339#appendix-C\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        if (month >= 1 &&\n            month <= 12 &&\n            day >= 1 &&\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {\n            return undefined;\n        }\n        return draft.errors.formatDateError({ value, pointer, schema });\n    },\n    \"date-time\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidDateTime.test(value)) {\n            if (new Date(value).toString() === \"Invalid Date\") {\n                return draft.errors.formatDateTimeError({ value, pointer, schema });\n            }\n            return undefined;\n        }\n        return draft.errors.formatDateTimeError({ value, pointer, schema });\n    },\n    email: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n        if (value[0] === '\"') {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        const [name, host, ...rest] = value.split(\"@\");\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\")) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!host.split(\".\").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        return undefined;\n    },\n    /**\n     * @draft 7\n     * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531\n     */\n    \"idn-email\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        try {\n            parseIdnEmail(value);\n            return undefined;\n        }\n        catch (e) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n    },\n    hostname: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidHostname.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatHostnameError({ value, pointer, schema });\n    },\n    ipv4: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 15 && isValidIPV4.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV4Error({ value, pointer, schema });\n    },\n    ipv6: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 45 && isValidIPV6.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV6Error({ value, pointer, schema });\n    },\n    \"json-pointer\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    \"relative-json-pointer\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidRelativeJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    regex: (draft, schema, value, pointer) => {\n        if (typeof value === \"string\" && /\\\\Z$/.test(value) === false) {\n            try {\n                new RegExp(value);\n                return undefined;\n            }\n            catch (e) { } // eslint-disable-line no-empty\n            return draft.errors.formatRegExError({ value, pointer, schema });\n        }\n        // v7 tests, ignore non-regex values\n        if (typeof value === \"object\" || typeof value === \"number\" || Array.isArray(value)) {\n            return undefined;\n        }\n        return draft.errors.formatRegExError({ value, pointer, schema });\n    },\n    // hh:mm:ss.sTZD\n    // https://opis.io/json-schema/2.x/formats.html\n    // regex https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html\n    time: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        const matches = value.match(matchTime);\n        return matches ? undefined : draft.errors.formatDateTimeError({ value, pointer, schema });\n        // if (!matches) {\n        //     return errors.formatDateTimeError({ value, pointer, schema });\n        // }\n        // const hour = +matches[1];\n        // const minute = +matches[2];\n        // const second = +matches[3];\n        // const timeZone = !!matches[5];\n        // if (\n        //     ((hour <= 23 && minute <= 59 && second <= 59) ||\n        //         (hour == 23 && minute == 59 && second == 60)) &&\n        //     timeZone\n        // ) {\n        //     return undefined;\n        // }\n        // return errors.formatTimeError({ value, pointer, schema });\n    },\n    uri: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (validUrl.isUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIError({ value, pointer, schema });\n    },\n    \"uri-reference\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURIRef.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIReferenceError({ value, pointer, schema });\n    },\n    \"uri-template\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURITemplate.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURITemplateError({ value, pointer, schema });\n    },\n    url: (draft, schema, value, pointer) => {\n        if (value === \"\" || validUrl.isWebUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURLError({ value, pointer, schema });\n    }\n};\nexport default formatValidators;\n","import gp from \"@sagold/json-pointer\";\nimport { isJsonError } from \"./types\";\nconst emptyObject = {};\n/**\n * Returns the json-schema of a data-json-pointer.\n *\n * To resolve dynamic schema where the type of json-schema is evaluated by\n * its value, a data object has to be passed in options.\n *\n * Per default this function will return `undefined` for valid properties that\n * do not have a defined schema. Use the option `withSchemaWarning: true` to\n * receive an error with `code: schema-warning` containing the location of its\n * last evaluated json-schema.\n *\n * Notes\n *      - uses draft.step to walk through data and schema\n *\n * @param draft\n * @param pointer - json pointer in data to get the json schema for\n * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n * @return resolved json-schema object of requested json-pointer location or json-error\n */\nexport default function getSchema(draft, options = emptyObject) {\n    const { pointer = \"#\", data, schema = draft.rootSchema, withSchemaWarning = false } = options;\n    const path = gp.split(pointer);\n    const result = _getSchema(draft, draft.resolveRef(schema), path, \"#\", data);\n    if (!withSchemaWarning && (result === null || result === void 0 ? void 0 : result.code) === \"schema-warning\") {\n        return undefined;\n    }\n    return result;\n}\nfunction _getSchema(draft, schema, path, pointer, data = emptyObject) {\n    if (path.length === 0) {\n        return draft.resolveRef(schema);\n    }\n    const key = path.shift(); // step key\n    schema = draft.step(key, schema, data, pointer); // step schema\n    if (isJsonError(schema)) {\n        return schema;\n    }\n    // @ts-expect-error data\n    data = data[key]; // step data\n    return _getSchema(draft, schema, path, `${pointer}/${key}`, data);\n}\n","import getTypeOf from \"../getTypeOf\";\nexport function isEmpty(v) {\n    const type = getTypeOf(v);\n    switch (type) {\n        case \"string\":\n        case \"array\":\n            // @ts-expect-error tested as array - could use ts type guard\n            return (v === null || v === void 0 ? void 0 : v.length) === 0;\n        case \"null\":\n        case \"undefined\":\n            return true;\n        case \"object\":\n            return Object.keys(v).length === 0;\n        default:\n            return false;\n    }\n}\n","/* eslint quote-props: 0, max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { resolveOneOfFuzzy } from \"./features/oneOf\";\nimport getTypeOf from \"./getTypeOf\";\nimport merge from \"./utils/merge\";\nimport copy from \"./utils/copy\";\nimport settings from \"./config/settings\";\nimport { isJsonError } from \"./types\";\nimport { isEmpty } from \"./utils/isEmpty\";\nimport { resolveIfSchema } from \"./features/if\";\nimport { mergeAllOfSchema, resolveSchema } from \"./features/allOf\";\nimport { resolveDependencies } from \"./features/dependencies\";\nimport { mergeSchema } from \"./mergeSchema\";\nconst defaultOptions = settings.templateDefaultOptions;\nlet cache;\nfunction shouldResolveRef(schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return true;\n    }\n    const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\n}\nfunction resolveRef(draft, schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return schema;\n    }\n    // @todo pointer + ref is redundant?\n    cache[pointer] = cache[pointer] || {};\n    cache[pointer][$ref] = cache[pointer][$ref] || 0;\n    cache[pointer][$ref] += 1;\n    return draft.resolveRef(schema);\n}\nfunction convertValue(type, value) {\n    if (type === \"string\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof value !== \"string\") {\n        return null;\n    }\n    try {\n        value = JSON.parse(value);\n        if (typeof value === type) {\n            return value;\n        }\n    }\n    catch (e) { } // eslint-disable-line no-empty\n    return null;\n}\n/**\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\n * Also returns a pointer-property on schema, that must be used as current pointer.\n *\n * @param draft\n * @param schema\n * @param data\n * @param pointer\n * @return resolved json-schema or input-schema\n */\nfunction createTemplateSchema(draft, schema, data, pointer, opts) {\n    // invalid schema\n    if (getTypeOf(schema) !== \"object\") {\n        return Object.assign({ pointer }, schema);\n    }\n    // return if reached recursion limit\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\n        return false;\n    }\n    // resolve $ref and copy schema\n    let templateSchema = copy(resolveRef(draft, schema, pointer));\n    // @feature anyOf\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\n        // test if we may resolve\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\n            const resolvedAnyOf = resolveRef(draft, schema.anyOf[0], `${pointer}/anyOf/0`);\n            templateSchema = merge(templateSchema, resolvedAnyOf);\n            // add pointer return-value, if any\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\n        }\n        delete templateSchema.anyOf;\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const mayResolve = schema.allOf\n            .map((allOf, index) => shouldResolveRef(allOf, `${pointer}/allOf/${index}`))\n            .reduceRight((next, before) => next && before, true);\n        if (mayResolve) {\n            // before merging all-of, we need to resolve all if-then-else statesments\n            // we need to udpate data on the way to trigger if-then-else schemas sequentially.\n            // Note that this will make if-then-else order-dependent\n            const allOf = [];\n            let extendedData = copy(data);\n            for (let i = 0; i < schema.allOf.length; i += 1) {\n                allOf.push(resolveSchema(draft, schema.allOf[i], extendedData));\n                extendedData = getTemplate(draft, extendedData, { type: schema.type, ...allOf[i] }, `${pointer}/allOf/${i}`, opts);\n            }\n            const resolvedSchema = mergeAllOfSchema(draft, { allOf });\n            if (resolvedSchema) {\n                templateSchema = mergeSchema(templateSchema, resolvedSchema);\n            }\n        }\n    }\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\n    return templateSchema;\n}\nconst isJsonSchema = (template) => template && typeof template === \"object\";\n/**\n * Create data object matching the given schema\n *\n * @param draft - json schema draft\n * @param [data] - optional template data\n * @param [schema] - json schema, defaults to rootSchema\n * @return created template data\n */\nfunction getTemplate(draft, data, _schema, pointer, opts) {\n    var _a;\n    if (_schema == null) {\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\n    }\n    if (pointer == null) {\n        throw new Error(\"Missing pointer\");\n    }\n    // resolve $ref references, allOf and first anyOf definitions\n    let schema = createTemplateSchema(draft, _schema, data, pointer, opts);\n    if (!isJsonSchema(schema)) {\n        return undefined;\n    }\n    pointer = schema.pointer;\n    if (schema === null || schema === void 0 ? void 0 : schema.const) {\n        return schema.const;\n    }\n    // @feature oneOf\n    if (Array.isArray(schema.oneOf)) {\n        if (isEmpty(data)) {\n            const type = schema.oneOf[0].type ||\n                schema.type ||\n                (schema.const && typeof schema.const) ||\n                getTypeOf(data);\n            schema = { ...schema.oneOf[0], type };\n        }\n        else {\n            // find correct schema for data\n            const resolvedSchema = resolveOneOfFuzzy(draft, data, schema);\n            if (isJsonError(resolvedSchema)) {\n                if (data != null && opts.removeInvalidData !== true) {\n                    return data;\n                }\n                // override\n                schema = schema.oneOf[0];\n                data = undefined;\n            }\n            else {\n                resolvedSchema.type = (_a = resolvedSchema.type) !== null && _a !== void 0 ? _a : schema.type;\n                schema = resolvedSchema;\n            }\n        }\n    }\n    // @todo Array.isArray(schema.type)\n    // -> hasDefault? return\n    // if not -> pick first types\n    if (!isJsonSchema(schema) || schema.type == null) {\n        return undefined;\n    }\n    // @attention - very special case to support file instances\n    if (data instanceof File) {\n        return data;\n    }\n    const type = Array.isArray(schema.type)\n        ? selectType(schema.type, data, schema.default)\n        : schema.type;\n    // reset invalid type\n    const javascriptTypeOfData = getTypeOf(data);\n    if (data != null &&\n        javascriptTypeOfData !== type &&\n        !(javascriptTypeOfData === \"number\" && type === \"integer\")) {\n        data = convertValue(type, data);\n    }\n    if (TYPE[type] == null) {\n        // in case we could not resolve the type\n        // (schema-type could not be resolved and returned an error)\n        if (opts.removeInvalidData) {\n            return undefined;\n        }\n        return data;\n    }\n    const templateData = TYPE[type](draft, schema, data, pointer, opts);\n    return templateData;\n}\nfunction selectType(types, data, defaultValue) {\n    if (data == undefined) {\n        if (defaultValue != null) {\n            const defaultType = getTypeOf(defaultValue);\n            if (types.includes(defaultType)) {\n                return defaultType;\n            }\n        }\n        return types[0];\n    }\n    const dataType = getTypeOf(data);\n    if (types.includes(dataType)) {\n        return dataType;\n    }\n    return types[0];\n}\nconst TYPE = {\n    null: (draft, schema, data) => getDefault(schema, data, null),\n    string: (draft, schema, data) => getDefault(schema, data, \"\"),\n    number: (draft, schema, data) => getDefault(schema, data, 0),\n    integer: (draft, schema, data) => getDefault(schema, data, 0),\n    boolean: (draft, schema, data) => getDefault(schema, data, false),\n    object: (draft, schema, data, pointer, opts) => {\n        var _a;\n        const template = schema.default === undefined ? {} : schema.default;\n        const d = {}; // do not assign data here, to keep ordering from json-schema\n        const required = (opts.extendDefaults === false && schema.default !== undefined) ? [] : ((_a = schema.required) !== null && _a !== void 0 ? _a : []);\n        if (schema.properties) {\n            Object.keys(schema.properties).forEach((key) => {\n                const value = data == null || data[key] == null ? template[key] : data[key];\n                const isRequired = required.includes(key);\n                // Omit adding a property if it is not required or optional props should be added\n                if (value != null || isRequired || opts.addOptionalProps) {\n                    d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);\n                }\n            });\n        }\n        // @feature dependencies\n        // has to be done after resolving properties so dependency may trigger\n        let dependenciesSchema = resolveDependencies(draft, schema, d);\n        if (dependenciesSchema) {\n            dependenciesSchema = mergeSchema(schema, dependenciesSchema);\n            delete dependenciesSchema.dependencies;\n            const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);\n            Object.assign(d, dependencyData);\n        }\n        if (data) {\n            if (opts.removeInvalidData === true &&\n                (schema.additionalProperties === false ||\n                    getTypeOf(schema.additionalProperties) === \"object\")) {\n                if (getTypeOf(schema.additionalProperties) === \"object\") {\n                    Object.keys(data).forEach((key) => {\n                        if (d[key] == null) {\n                            // merge valid missing data (additionals) to resulting object\n                            if (draft.isValid(data[key], schema.additionalProperties)) {\n                                d[key] = data[key];\n                            }\n                        }\n                    });\n                }\n            }\n            else {\n                // merge any missing data (additionals) to resulting object\n                Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\n            }\n        }\n        // @feature if-then-else\n        const ifSchema = resolveIfSchema(draft, schema, d);\n        if (ifSchema) {\n            const additionalData = getTemplate(draft, d, { type: \"object\", ...ifSchema }, pointer, opts);\n            Object.assign(d, additionalData);\n        }\n        // returns object, which is ordered by json-schema\n        return d;\n    },\n    // build array type of items, ignores additionalItems\n    array: (draft, schema, data, pointer, opts) => {\n        var _a, _b;\n        if (schema.items == null) {\n            return data || []; // items are undefined\n        }\n        const template = schema.default === undefined ? [] : schema.default;\n        const d = data || template;\n        const minItems = (opts.extendDefaults === false && schema.default !== undefined) ? 0 : (schema.minItems || 0);\n        // build defined set of items\n        if (Array.isArray(schema.items)) {\n            for (let i = 0, l = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_b = (_a = schema.items) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);\n            }\n            return d;\n        }\n        // abort if the schema is invalid\n        if (getTypeOf(schema.items) !== \"object\") {\n            return d;\n        }\n        // resolve allOf and first anyOf definition\n        const templateSchema = createTemplateSchema(draft, schema.items, data, pointer, opts);\n        if (templateSchema === false) {\n            return d;\n        }\n        pointer = templateSchema.pointer || pointer;\n        // build data for first oneOf-schema\n        if (templateSchema.oneOf && d.length === 0) {\n            const oneOfSchema = templateSchema.oneOf[0];\n            for (let i = 0; i < minItems; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);\n            }\n            return d;\n        }\n        // complete data selecting correct oneOf-schema\n        if (templateSchema.oneOf && d.length > 0) {\n            const itemCount = Math.max(minItems, d.length);\n            for (let i = 0; i < itemCount; i += 1) {\n                let value = d[i] == null ? template[i] : d[i];\n                let one = resolveOneOfFuzzy(draft, value, templateSchema);\n                if (one == null || isJsonError(one)) {\n                    // schema could not be resolved or data is invalid\n                    if (value != null && opts.removeInvalidData !== true) {\n                        // keep invalid value\n                        d[i] = value;\n                    }\n                    else {\n                        // replace invalid value\n                        value = undefined;\n                        one = templateSchema.oneOf[0];\n                        d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                    }\n                }\n                else {\n                    // schema is valid\n                    d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                }\n            }\n            return d;\n        }\n        // build data from items-definition\n        if (templateSchema.type) {\n            for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);\n            }\n            return d;\n        }\n        return d;\n    }\n};\nfunction getDefault(schema, templateValue, initValue) {\n    if (templateValue != null) {\n        return templateValue;\n    }\n    else if (schema.const) {\n        return schema.const;\n    }\n    else if (schema.default === undefined && Array.isArray(schema.enum)) {\n        return schema.enum[0];\n    }\n    else if (schema.default === undefined) {\n        return initValue;\n    }\n    return schema.default;\n}\nexport default (draft, data, schema = draft.rootSchema, opts) => {\n    cache = {};\n    if (opts) {\n        return getTemplate(draft, data, schema, \"#\", { ...defaultOptions, ...opts });\n    }\n    return getTemplate(draft, data, schema, \"#\", defaultOptions);\n};\n","/**\n * Test if the data is valid according to the given schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema\n * @param [pointer] - json pointer pointing to value\n * @return if schema does match given value\n */\nexport default function isValid(draft, value, schema = draft.rootSchema, pointer = \"#\") {\n    return draft.validate(value, schema, pointer).length === 0;\n}\n","/* eslint no-bitwise: 0 */\n/**\n * taken from punycode@2.1.0\n *\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param string The Unicode input string (UCS-2).\n * @returns The new array of code points.\n */\nexport default function ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            // eslint-disable-next-line eqeqeq\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n","/**\n * returns the floating point precision of a decimal number or 0\n */\nexport function getPrecision(value) {\n    const string = `${value}`;\n    const index = string.indexOf(\".\");\n    return index === -1 ? 0 : string.length - (index + 1);\n}\n","import getTypeOf from \"../getTypeOf\";\nimport settings from \"../config/settings\";\nimport ucs2decode from \"../utils/punycode.ucs2decode\";\nimport { isObject } from \"../utils/isObject\";\nimport { isJsonError } from \"../types\";\nimport { validateAllOf } from \"../features/allOf\";\nimport { validateAnyOf } from \"../features/anyOf\";\nimport { validateDependencies } from \"../features/dependencies\";\nimport { validateOneOf } from \"../features/oneOf\";\nimport { getPrecision } from \"../utils/getPrecision\";\nimport deepEqual from \"fast-deep-equal\";\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasProperty = (value, property) => !(value[property] === undefined || !hasOwnProperty.call(value, property));\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\nconst KeywordValidation = {\n    additionalProperties: (draft, schema, value, pointer) => {\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\n            return undefined;\n        }\n        if (getTypeOf(schema.patternProperties) === \"object\" &&\n            schema.additionalProperties === false) {\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\n            return undefined;\n        }\n        const errors = [];\n        let receivedProperties = Object.keys(value).filter((prop) => settings.propertyBlacklist.includes(prop) === false);\n        const expectedProperties = Object.keys(schema.properties || {});\n        if (getTypeOf(schema.patternProperties) === \"object\") {\n            // filter received properties by matching patternProperties\n            const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));\n            receivedProperties = receivedProperties.filter((prop) => {\n                for (let i = 0; i < patterns.length; i += 1) {\n                    if (patterns[i].test(prop)) {\n                        return false; // remove\n                    }\n                }\n                return true;\n            });\n        }\n        // adds an error for each an unexpected property\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\n            const property = receivedProperties[i];\n            if (expectedProperties.indexOf(property) === -1) {\n                const additionalIsObject = isObject(schema.additionalProperties);\n                // additionalProperties { oneOf: [] }\n                if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {\n                    const result = draft.resolveOneOf(value[property], schema.additionalProperties, `${pointer}/${property}`);\n                    if (isJsonError(result)) {\n                        errors.push(draft.errors.additionalPropertiesError({\n                            pointer,\n                            schema: schema.additionalProperties,\n                            value,\n                            property: receivedProperties[i],\n                            properties: expectedProperties,\n                            // pass all validation errors\n                            errors: result.data.errors\n                        }));\n                    }\n                    else {\n                        errors.push(...draft.validate(value[property], result, pointer));\n                    }\n                    // additionalProperties {}\n                }\n                else if (additionalIsObject) {\n                    errors.push(...draft.validate(value[property], schema.additionalProperties, `${pointer}/${property}`));\n                }\n                else {\n                    errors.push(draft.errors.noAdditionalPropertiesError({\n                        pointer,\n                        schema,\n                        value,\n                        property: receivedProperties[i],\n                        properties: expectedProperties\n                    }));\n                }\n            }\n        }\n        return errors;\n    },\n    allOf: validateAllOf,\n    anyOf: validateAnyOf,\n    dependencies: validateDependencies,\n    enum: (draft, schema, value, pointer) => {\n        const type = getTypeOf(value);\n        if (type === \"object\" || type === \"array\") {\n            const valueStr = JSON.stringify(value);\n            for (let i = 0; i < schema.enum.length; i += 1) {\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\n                    return undefined;\n                }\n            }\n        }\n        else if (schema.enum.includes(value)) {\n            return undefined;\n        }\n        return draft.errors.enumError({ pointer, schema, value, values: schema.enum });\n    },\n    format: (draft, schema, value, pointer) => {\n        if (draft.validateFormat[schema.format]) {\n            const errors = draft.validateFormat[schema.format](draft, schema, value, pointer);\n            return errors;\n        }\n        // fail silently if given format is not defined\n        return undefined;\n    },\n    items: (draft, schema, value, pointer) => {\n        // @draft >= 7 bool schema\n        if (schema.items === false) {\n            if (Array.isArray(value) && value.length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidDataError({ pointer, value, schema });\n        }\n        const errors = [];\n        for (let i = 0; i < value.length; i += 1) {\n            const itemData = value[i];\n            // @todo reevaluate: incomplete schema is created here\n            const itemSchema = draft.step(i, schema, value, pointer);\n            if (isJsonError(itemSchema)) {\n                return [itemSchema];\n            }\n            const itemErrors = draft.validate(itemData, itemSchema, `${pointer}/${i}`);\n            errors.push(...itemErrors);\n        }\n        return errors;\n    },\n    maximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                value,\n                pointer,\n                schema\n            });\n        }\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxItems: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maxItems)) {\n            return undefined;\n        }\n        if (schema.maxItems < value.length) {\n            return draft.errors.maxItemsError({\n                maximum: schema.maxItems,\n                length: value.length,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxLength: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maxLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.maxLength < lengthOfString) {\n            return draft.errors.maxLengthError({\n                maxLength: schema.maxLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxProperties: (draft, schema, value, pointer) => {\n        const propertyCount = Object.keys(value).length;\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\n            return draft.errors.maxPropertiesError({\n                maxProperties: schema.maxProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minLength: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.minLength > lengthOfString) {\n            if (schema.minLength === 1) {\n                return draft.errors.minLengthOneError({\n                    minLength: schema.minLength,\n                    length: lengthOfString,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minLengthError({\n                minLength: schema.minLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minItems: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minItems)) {\n            return undefined;\n        }\n        if (schema.minItems > value.length) {\n            if (schema.minItems === 1) {\n                return draft.errors.minItemsOneError({\n                    minItems: schema.minItems,\n                    length: value.length,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minItemsError({\n                minItems: schema.minItems,\n                length: value.length,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minProperties: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minProperties)) {\n            return undefined;\n        }\n        const propertyCount = Object.keys(value).length;\n        if (schema.minProperties > propertyCount) {\n            return draft.errors.minPropertiesError({\n                minProperties: schema.minProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    multipleOf: (draft, schema, value, pointer) => {\n        if (isNaN(schema.multipleOf) || typeof value !== \"number\") {\n            return undefined;\n        }\n        const valuePrecision = getPrecision(value);\n        const multiplePrecision = getPrecision(schema.multipleOf);\n        if (valuePrecision > multiplePrecision) {\n            // value with higher precision then multipleOf-precision can never be multiple\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        const precision = Math.pow(10, multiplePrecision);\n        const val = Math.round(value * precision);\n        const multiple = Math.round(schema.multipleOf * precision);\n        if ((val % multiple) / precision !== 0) {\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        // maybe also check overflow\n        // https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\n        return undefined;\n    },\n    not: (draft, schema, value, pointer) => {\n        const errors = [];\n        if (draft.validate(value, schema.not, pointer).length === 0) {\n            errors.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));\n        }\n        return errors;\n    },\n    oneOf: validateOneOf,\n    pattern: (draft, schema, value, pointer) => {\n        const pattern = new RegExp(schema.pattern, \"u\");\n        if (pattern.test(value) === false) {\n            return draft.errors.patternError({\n                pattern: schema.pattern,\n                description: schema.patternExample || schema.pattern,\n                received: value,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (draft, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    schema,\n                    value,\n                    patterns: Object.keys(pp).join(\",\")\n                }));\n            }\n        });\n        return errors;\n    },\n    properties: (draft, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (hasProperty(value, key)) {\n                const itemSchema = draft.step(key, schema, value, pointer);\n                const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\n    propertiesRequired: (draft, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (value[key] === undefined) {\n                errors.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));\n            }\n            else {\n                const itemSchema = draft.step(key, schema, value, pointer);\n                const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    required: (draft, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (!hasProperty(value, property)) {\n                return draft.errors.requiredPropertyError({\n                    key: property,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\n    requiredNotEmpty: (draft, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (value[property] == null || value[property] === \"\") {\n                return draft.errors.valueNotEmptyError({\n                    property,\n                    pointer: `${pointer}/${property}`,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    uniqueItems: (draft, schema, value, pointer) => {\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\n            return undefined;\n        }\n        const duplicates = [];\n        const errors = [];\n        value.forEach((item, index) => {\n            for (let i = index + 1; i < value.length; i += 1) {\n                if (deepEqual(item, value[i]) && !duplicates.includes(i)) {\n                    errors.push(draft.errors.uniqueItemsError({\n                        pointer: `${pointer}/${i}`,\n                        duplicatePointer: `${pointer}/${index}`,\n                        arrayPointer: pointer,\n                        value: JSON.stringify(item),\n                        schema\n                    }));\n                    duplicates.push(i);\n                }\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n","export default function resolveRef(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    if (schema.getRoot) {\n        // we actually always need to resolve the schema like this, since returned subschemas\n        // must resolve relative from their schema\n        const resolvedSchema = schema.getRoot().getRef(schema);\n        // console.log(schema.$ref, \"=>\", resolvedSchema);\n        return resolvedSchema;\n    }\n    // tryout - this should never be called, except we missed something\n    const resolvedSchema = rootSchema.getRef(schema);\n    return resolvedSchema;\n}\n","import getTypeOf from \"./getTypeOf\";\nimport { isObject } from \"./utils/isObject\";\n/**\n * Create a simple json schema for the given input data\n * @param  data - data to get json schema for\n */\nexport default function createSchemaOf(data) {\n    if (data === undefined) {\n        return undefined;\n    }\n    const schema = {\n        type: getTypeOf(data)\n    };\n    if (schema.type === \"object\" && isObject(data)) {\n        schema.properties = {};\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\n    }\n    if (schema.type === \"array\" && Array.isArray(data)) {\n        if (data.length === 1) {\n            schema.items = createSchemaOf(data[0]);\n        }\n        else {\n            schema.items = data.map(createSchemaOf);\n        }\n    }\n    return schema;\n}\n","import getTypeOf from \"./getTypeOf\";\nimport createSchemaOf from \"./createSchemaOf\";\nimport { isJsonError } from \"./types\";\nimport { reduceSchema } from \"./reduceSchema\";\nconst stepType = {\n    array: (draft, key, schema, data, pointer) => {\n        const itemValue = data === null || data === void 0 ? void 0 : data[key];\n        const itemsType = getTypeOf(schema.items);\n        if (itemsType === \"object\") {\n            // @spec: ignore additionalItems, when items is schema-object\n            return (reduceSchema(draft, schema.items, itemValue, `${pointer}/${key}`) ||\n                draft.resolveRef(schema.items));\n        }\n        if (itemsType === \"array\") {\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === true) {\n                return createSchemaOf(itemValue);\n            }\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === false) {\n                return draft.errors.invalidDataError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.items[key]) {\n                return draft.resolveRef(schema.items[key]);\n            }\n            if (schema.additionalItems === false) {\n                return draft.errors.additionalItemsError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\n                return createSchemaOf(itemValue);\n            }\n            if (getTypeOf(schema.additionalItems) === \"object\") {\n                return schema.additionalItems;\n            }\n            throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);\n        }\n        if (schema.additionalItems !== false && itemValue) {\n            // @todo reevaluate: incomplete schema is created here\n            // @todo support additionalItems: {schema}\n            return createSchemaOf(itemValue);\n        }\n        return new Error(`Invalid array schema for ${key} at ${pointer}`);\n    },\n    object: (draft, key, schema, data, pointer) => {\n        var _a;\n        schema = reduceSchema(draft, schema, data, pointer);\n        // @feature properties\n        const property = (_a = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _a === void 0 ? void 0 : _a[key];\n        if (property !== undefined) {\n            // @todo patternProperties also validate properties\n            // @feature boolean schema\n            if (property === false) {\n                return draft.errors.forbiddenPropertyError({\n                    property: key,\n                    value: data,\n                    pointer,\n                    schema\n                });\n            }\n            else if (property === true) {\n                return createSchemaOf(data === null || data === void 0 ? void 0 : data[key]);\n            }\n            const targetSchema = draft.resolveRef(property);\n            if (isJsonError(targetSchema)) {\n                return targetSchema;\n            }\n            // check if there is a oneOf selection, which must be resolved\n            if (targetSchema && Array.isArray(targetSchema.oneOf)) {\n                // @special case: this is a mix of a schema and optional definitions\n                // we resolve the schema here and add the original schema to `oneOfSchema`\n                return draft.resolveOneOf(data[key], targetSchema, `${pointer}/${key}`);\n            }\n            // resolved schema or error\n            if (targetSchema) {\n                return targetSchema;\n            }\n        }\n        // @feature patternProperties\n        const { patternProperties } = schema;\n        if (getTypeOf(patternProperties) === \"object\") {\n            // find matching property key\n            let regex;\n            const patterns = Object.keys(patternProperties);\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                regex = new RegExp(patterns[i]);\n                if (regex.test(key)) {\n                    return patternProperties[patterns[i]];\n                }\n            }\n        }\n        // @feature additionalProperties\n        const { additionalProperties } = schema;\n        if (getTypeOf(additionalProperties) === \"object\") {\n            return schema.additionalProperties;\n        }\n        if (data && (additionalProperties === undefined || additionalProperties === true)) {\n            return createSchemaOf(data[key]);\n        }\n        return draft.errors.unknownPropertyError({\n            property: key,\n            value: data,\n            pointer: `${pointer}`,\n            schema\n        });\n    }\n};\n/**\n * Returns the json-schema of the given object property or array item.\n * e.g. it steps by one key into the data\n *\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n *  returns the correct schema.\n *\n * @param  draft      - validator\n * @param  key       - property-name or array-index\n * @param  schema    - json schema of current data\n * @param  data      - parent of key\n * @param  [pointer] - pointer to schema and data (parent of key)\n * @return Schema or Error if failed resolving key\n */\nexport default function step(draft, key, schema, data, pointer = \"#\") {\n    var _a;\n    const typeOfData = getTypeOf(data);\n    let schemaType = (_a = schema.type) !== null && _a !== void 0 ? _a : typeOfData;\n    // @draft >= 4 ?\n    if (Array.isArray(schemaType)) {\n        if (!schemaType.includes(typeOfData)) {\n            return draft.errors.typeError({\n                value: data,\n                pointer,\n                expected: schema.type,\n                received: typeOfData,\n                schema\n            });\n        }\n        schemaType = typeOfData;\n    }\n    const stepFunction = stepType[schemaType];\n    if (stepFunction) {\n        const schemaResult = stepFunction(draft, `${key}`, schema, data, pointer);\n        if (schemaResult === undefined) {\n            return draft.errors.schemaWarning({\n                pointer,\n                value: data,\n                schema,\n                key\n            });\n        }\n        return schemaResult;\n    }\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`);\n}\n","import { isJsonError } from \"./types\";\n/**\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\n * a list with a single item will be returned\n *\n * @param draft        - draft to use\n * @param property    - parent schema of following property\n * @param [schema]    - parent schema of following property\n * @return\n */\nexport default function getChildSchemaSelection(draft, property, schema = draft.rootSchema) {\n    var _a;\n    if (schema.oneOf) {\n        return schema.oneOf.map((item) => draft.resolveRef(item));\n    }\n    if ((_a = schema.items) === null || _a === void 0 ? void 0 : _a.oneOf) {\n        return schema.items.oneOf.map((item) => draft.resolveRef(item));\n    }\n    const result = draft.step(property, schema, {}, \"#\");\n    if (isJsonError(result)) {\n        return result;\n    }\n    return [result];\n}\n","/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst typeValidators = {\n    array: (draft, schema, value, pointer) => draft.typeKeywords.array\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    object: (draft, schema, value, pointer) => draft.typeKeywords.object\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    string: (draft, schema, value, pointer) => draft.typeKeywords.string\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    integer: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    number: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    null: (draft, schema, value, pointer) => draft.typeKeywords.null\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer))\n};\nexport default typeValidators;\n","import getTypeOf from \"./getTypeOf\";\nimport { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport { isJsonError } from \"./types\";\nimport equal from \"fast-deep-equal\";\nfunction getJsonSchemaType(value, expectedType) {\n    const jsType = getTypeOf(value);\n    if (jsType === \"number\" &&\n        (expectedType === \"integer\" ||\n            (Array.isArray(expectedType) && expectedType.includes(\"integer\")))) {\n        return Number.isInteger(value) || isNaN(value) ? \"integer\" : \"number\";\n    }\n    return jsType;\n}\n/**\n * Validates data with json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema, defaults to rootSchema\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\n * @return list of errors or empty\n */\nexport default function validate(draft, value, schema = draft.rootSchema, pointer = \"#\") {\n    schema = draft.resolveRef(schema);\n    // @draft >= 07\n    if (getTypeOf(schema) === \"boolean\") {\n        if (schema) {\n            return [];\n        }\n        return [draft.errors.invalidDataError({ pointer, schema, value })];\n    }\n    if (isJsonError(schema)) {\n        return [schema];\n    }\n    // @draft >= 6 const\n    if (schema.const !== undefined) {\n        if (equal(schema.const, value)) {\n            return [];\n        }\n        return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];\n    }\n    const receivedType = getJsonSchemaType(value, schema.type);\n    const expectedType = schema.type || receivedType;\n    if (receivedType !== expectedType &&\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {\n        return [\n            draft.errors.typeError({\n                pointer,\n                schema,\n                value,\n                received: receivedType,\n                expected: expectedType\n            })\n        ];\n    }\n    if (draft.validateType[receivedType] == null) {\n        return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];\n    }\n    // get type validation results\n    const errors = flattenArray(draft.validateType[receivedType](draft, schema, value, pointer));\n    return errors.filter(errorOrPromise); // ignore promises here\n}\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../compileSchema\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../validation/keyword\";\nimport merge from \"../utils/merge\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.strict\";\nimport step from \"../step\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nimport settings from \"../config/settings\";\nconst draft04Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"enum\", \"not\", \"allOf\", \"anyOf\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"patternProperties\",\n            \"properties\",\n            \"required\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft04 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft04Config, config), schema);\n    }\n}\nexport { Draft04, draft04Config };\n","import { eachSchema } from \"../../eachSchema\";\n// import remotes from \"../../../remotes\";\nimport joinScope from \"../../compile/joinScope\";\nimport getRef from \"../../compile/getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * @draft starting with _draft 06_ keyword `id` has been renamed to `$id`\n *\n * compiles the input root schema for $ref resolution and returns it again\n * @attention this modifies input schema but maintains object-structure\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\n * @param [force] = false force compile json-schema\n * @return compiled json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    // @ts-expect-error incomplete JsonSchema type\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\n        return schemaToCompile;\n    }\n    if (schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    } // eslint-disable-line\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (compiledSchema !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"$defs\", {\n            enumerable: true,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.$id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.$id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.$id = (_a = parentSchema.$id) !== null && _a !== void 0 ? _a : schema.$id;\n            }\n            context.ids[schema.$id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.$id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n    return compiledSchema;\n}\n","import Keywords from \"../../validation/keyword\";\nimport getTypeOf from \"../../getTypeOf\";\nimport { validateIf } from \"../../features/if\";\nconst KeywordValidation = {\n    ...Keywords,\n    // @draft >= 6\n    contains: (draft, schema, value, pointer) => {\n        if (schema.contains === false) {\n            return draft.errors.containsArrayError({ pointer, value, schema });\n        }\n        if (schema.contains === true) {\n            if (Array.isArray(value) && value.length === 0) {\n                return draft.errors.containsAnyError({ pointer, value, schema });\n            }\n            return undefined;\n        }\n        if (getTypeOf(schema.contains) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        for (let i = 0; i < value.length; i += 1) {\n            if (draft.isValid(value[i], schema.contains)) {\n                return undefined;\n            }\n        }\n        return draft.errors.containsError({ pointer, schema, value });\n    },\n    exclusiveMaximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMaximum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMaximum <= value) {\n            return draft.errors.maximumError({\n                maximum: schema.exclusiveMaximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    exclusiveMinimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMinimum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMinimum >= value) {\n            return draft.errors.minimumError({\n                minimum: schema.exclusiveMinimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    // @feature if-then-else\n    if: validateIf,\n    maximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (draft, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    // for a boolean schema `false`, always invalidate\n                    if (patterns[i].patternSchema === false) {\n                        errors.push(draft.errors.patternPropertiesError({\n                            key,\n                            pointer,\n                            patterns: Object.keys(pp).join(\",\"),\n                            schema,\n                            value\n                        }));\n                        return;\n                    }\n                    const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    patterns: Object.keys(pp).join(\",\"),\n                    schema,\n                    value\n                }));\n            }\n        });\n        return errors;\n    },\n    // @draft >= 6\n    propertyNames: (draft, schema, value, pointer) => {\n        // bool schema\n        if (schema.propertyNames === false) {\n            // empty objects are valid\n            if (Object.keys(value).length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidPropertyNameError({\n                property: Object.keys(value),\n                pointer,\n                value,\n                schema\n            });\n        }\n        if (schema.propertyNames === true) {\n            return undefined;\n        }\n        if (getTypeOf(schema.propertyNames) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        const errors = [];\n        const properties = Object.keys(value);\n        const propertySchema = { ...schema.propertyNames, type: \"string\" };\n        properties.forEach((prop) => {\n            const validationResult = draft.validate(prop, propertySchema, `${pointer}/${prop}`);\n            if (validationResult.length > 0) {\n                errors.push(draft.errors.invalidPropertyNameError({\n                    property: prop,\n                    pointer,\n                    validationError: validationResult[0],\n                    value: value[prop],\n                    schema\n                }));\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n","/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst validationType = {\n    array: (draft, schema, value, pointer) => draft.typeKeywords.array\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    object: (draft, schema, value, pointer) => draft.typeKeywords.object\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    string: (draft, schema, value, pointer) => draft.typeKeywords.string\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    integer: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    number: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    null: (draft, schema, value, pointer) => draft.typeKeywords.null\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer))\n};\nexport default validationType;\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nimport settings from \"../config/settings\";\nconst draft06Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\",\n            \"if\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft06 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft06Config, config), schema);\n    }\n}\nexport { Draft06, draft06Config };\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nimport settings from \"../config/settings\";\nconst draft07Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"if\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft07 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft07Config, config), schema);\n    }\n}\nexport { Draft07, draft07Config };\n","export default function resolveRefMerge(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    const resolvedSchema = rootSchema.getRef(schema);\n    const mergedSchema = Object.assign({}, resolvedSchema, schema);\n    delete mergedSchema.$ref;\n    // @todo the following might not be safe nor incomplete\n    Object.defineProperty(mergedSchema, \"__ref\", { enumerable: false, value: schema.__ref });\n    Object.defineProperty(mergedSchema, \"getRoot\", { enumerable: false, value: schema.getRoot });\n    return mergedSchema;\n}\n","import merge from \"../utils/merge\";\nimport { resolveOneOfFuzzy } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.merge\";\nimport { Draft } from \"../draft\";\nimport { draft07Config } from \"../draft07\";\nconst draftJsonEditorConfig = {\n    ...draft07Config,\n    resolveOneOf: resolveOneOfFuzzy,\n    resolveRef\n};\nclass JsonEditor extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draftJsonEditorConfig, config), schema);\n    }\n}\nexport { JsonEditor, draftJsonEditorConfig };\n","import { createError, createCustomError } from \"./lib/utils/createCustomError\";\nimport getTypeOf from \"./lib/getTypeOf\";\nimport { resolveOneOf, resolveOneOfFuzzy } from \"./lib/features/oneOf\";\nimport { resolveAllOf } from \"./lib/features/allOf\";\nimport resolveRef from \"./lib/resolveRef.strict\";\nimport resolveRefMerge from \"./lib/resolveRef.merge\";\nimport settings from \"./lib/config/settings\";\nimport strings from \"./lib/config/strings\";\nimport validateAsync from \"./lib/validateAsync\";\nimport { reduceSchema } from \"./lib/reduceSchema\";\nimport { resolveDynamicSchema, isDynamicSchema } from \"./lib/resolveDynamicSchema\";\nimport { mergeSchema } from \"./lib/mergeSchema\";\nimport render from \"./lib/utils/render\";\nimport { Draft } from \"./lib/draft\";\nimport { Draft04, draft04Config } from \"./lib/draft04\";\nimport { Draft06, draft06Config } from \"./lib/draft06\";\nimport { Draft07, draft07Config } from \"./lib/draft07\";\nimport { JsonEditor, draftJsonEditorConfig } from \"./lib/jsoneditor\";\nimport { isJsonError } from \"./lib/types\";\nconst config = { strings };\nexport { config, createCustomError, createError, Draft, Draft04, // core implementing draft04 specs\ndraft04Config, // config implementing draft04 specs\nDraft06, // core implementing draft06 specs\ndraft06Config, // config implementing draft06 specs\nDraft07, // core implementing draft07 specs\ndraft07Config, // config implementing draft07 specs\ndraftJsonEditorConfig, // adjusted config of draft04 to better support the json-editor\ngetTypeOf, // returns the javascript datatype\nisDynamicSchema, // NEW\nisJsonError, JsonEditor, // adjusted core of draft07 to better support the json-editor\nmergeSchema, // NEW\nreduceSchema, // NEW\nrender, resolveAllOf, resolveDynamicSchema, // NEW\nresolveOneOf, resolveOneOfFuzzy, resolveRef, resolveRefMerge, settings, validateAsync // async validation of data by a schema\n };\n"],"names":["getTypeOf","value","type","OBJECT_TYPE","ARRAY_TYPE","render","template","data","match","key","variable","variableType","__","keyword","fallback","_a","strings","dashCase","text","createError","name","createCustomError","flattenArray","list","result","i","item","createOneOfSchemaResult","schema","oneOfSchema","oneOfIndex","childSchema","error","isPromise","obj","errorOrPromise","errorsOnly","DECLARATOR_ONEOF","settings","resolveOneOf","draft","pointer","errors","oneOfProperty","oneOfValue","one","oneOfPropertySchema","matches","fuzzyObjectValue","keys","resolveOneOfFuzzy","schemaOfItem","schemaOfIndex","fuzzyGreatest","fuzzyValue","validateOneOf","schemaOrError","overwriteMerge","destinationArray","sourceArray","a","b","mergeUniqueItems","all","pos","mergeArraysUnique","mergeSchema","aType","bType","omit","object","keysToOmit","resolveIfSchema","ifErrors","validateIf","resolvedSchema","resolveSchema","schemaToResolve","ifSchema","resolveAllOf","mergedSchema","copy","allOfSchema","mergeAllOfSchema","allOf","subschema","validateAllOf","subSchema","uniqueItems","index","isObject","v","resolveDependencies","dependencies","updated","prop","_b","dependency","validateDependencies","property","dependencyErrors","missingProperty","mergeValidAnyOfSchema","anySchema","resolveAnyOf","anyOf","validateAnyOf","toOmit","dynamicProperties","isDynamicSchema","givenProps","resolveDynamicSchema","s","anyOfSchema","dependenciesSchema","nestedSchema","reduceSchema","Draft","config","rootSchema","url","callback","options","opts","addRemoteSchema","typeKeywords","types","id","getTypeId","ids","l","getTypeDefs","defs","query","parent","nextTypeDefs","next","eachDefinition","walk","defId","eachSchema","defschema","schemaPointer","suffixes","trailingHash","isDomain","trailingFragments","idAndPointer","joinScope","previous","emptyValues","splitRef","$ref","val","getRef","context","$remote","fragments","base","COMPILED","COMPILED_REF","GET_REF","GET_ROOT","compileSchema","schemaToCompile","force","rootSchemaAsString","compiledSchema","scopes","getRoot","parentPointer","parentSchema","previousPointer","previousScope","scope","each","dataType","nextSchema","isValidDateTime","isValidIPV4","isValidIPV6","isValidHostname","matchDate","matchTime","DAYS","isValidJsonPointer","isValidRelativeJsonPointer","isValidURIRef","isValidURITemplate","year","month","day","isLeapYear","host","rest","part","emptyObject","getSchema","withSchemaWarning","path","_getSchema","isEmpty","defaultOptions","cache","shouldResolveRef","resolveRef","convertValue","createTemplateSchema","templateSchema","resolvedAnyOf","merge","before","extendedData","getTemplate","isJsonSchema","_schema","selectType","javascriptTypeOfData","TYPE","defaultValue","defaultType","getDefault","d","required","isRequired","dependencyData","additionalData","minItems","itemCount","templateValue","initValue","isValid","ucs2decode","string","output","counter","length","extra","getPrecision","hasProperty","receivedProperties","expectedProperties","patterns","pattern","additionalIsObject","valueStr","itemData","itemSchema","itemErrors","lengthOfString","propertyCount","valuePrecision","multiplePrecision","precision","multiple","properties","pp","expr","patternFound","valErrors","keyErrors","duplicates","createSchemaOf","stepType","itemValue","itemsType","targetSchema","patternProperties","regex","additionalProperties","step","typeOfData","schemaType","stepFunction","schemaResult","getChildSchemaSelection","getJsonSchemaType","expectedType","jsType","validate","receivedType","draft04Config","Draft04","propertySchema","validationResult","draft06Config","Draft06","draft07Config","Draft07","resolveRefMerge","draftJsonEditorConfig","JsonEditor"],"sourceRoot":""}