'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pluginAuthNode = require('@backstage/plugin-auth-node');
var jose = require('jose');
var fetch = require('node-fetch');
var passportMicrosoft = require('passport-microsoft');
var lodash = require('lodash');
var backendPluginApi = require('@backstage/backend-plugin-api');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);

class ExtendedMicrosoftStrategy extends passportMicrosoft.Strategy {
  userProfile(accessToken, done) {
    if (this.skipUserProfile(accessToken)) {
      done(null, void 0);
      return;
    }
    super.userProfile(
      accessToken,
      (err, profile) => {
        if (!profile || profile.photos) {
          done(err, profile);
          return;
        }
        this.getProfilePhotos(accessToken).then((photos) => {
          profile.photos = photos;
          done(err, profile);
        });
      }
    );
  }
  hasGraphReadScope(accessToken) {
    const { aud, scp } = jose.decodeJwt(accessToken);
    return aud === "00000003-0000-0000-c000-000000000000" && !!scp && scp.split(" ").map((s) => s.toLocaleLowerCase("en-US")).some(
      (s) => [
        "https://graph.microsoft.com/user.read",
        "https://graph.microsoft.com/user.read.all",
        "user.read",
        "user.read.all"
      ].includes(s)
    );
  }
  skipUserProfile(accessToken) {
    try {
      return !this.hasGraphReadScope(accessToken);
    } catch {
      return false;
    }
  }
  async getProfilePhotos(accessToken) {
    return this.getCurrentUserPhoto(accessToken, "96x96").then(
      (photo) => photo ? [{ value: photo }] : void 0
    );
  }
  async getCurrentUserPhoto(accessToken, size) {
    try {
      const res = await fetch__default.default(
        `https://graph.microsoft.com/v1.0/me/photos/${size}/$value`,
        {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        }
      );
      const data = await res.buffer();
      return `data:image/jpeg;base64,${data.toString("base64")}`;
    } catch (error) {
      return void 0;
    }
  }
}

const microsoftAuthenticator = pluginAuthNode.createOAuthAuthenticator({
  defaultProfileTransform: pluginAuthNode.PassportOAuthAuthenticatorHelper.defaultProfileTransform,
  initialize({ callbackUrl, config }) {
    const clientId = config.getString("clientId");
    const clientSecret = config.getString("clientSecret");
    const tenantId = config.getString("tenantId");
    const domainHint = config.getOptionalString("domainHint");
    const scope = lodash.union(
      ["user.read"],
      config.getOptionalStringArray("additionalScopes")
    );
    const helper = pluginAuthNode.PassportOAuthAuthenticatorHelper.from(
      new ExtendedMicrosoftStrategy(
        {
          clientID: clientId,
          clientSecret,
          callbackURL: callbackUrl,
          tenant: tenantId,
          scope
        },
        (accessToken, refreshToken, params, fullProfile, done) => {
          done(
            void 0,
            { fullProfile, params, accessToken },
            { refreshToken }
          );
        }
      )
    );
    return {
      helper,
      domainHint
    };
  },
  async start(input, ctx) {
    const options = {
      accessType: "offline"
    };
    if (ctx.domainHint !== void 0) {
      options.domain_hint = ctx.domainHint;
    }
    return ctx.helper.start(input, options);
  },
  async authenticate(input, ctx) {
    return ctx.helper.authenticate(input);
  },
  async refresh(input, ctx) {
    return ctx.helper.refresh(input);
  }
});

exports.microsoftSignInResolvers = void 0;
((microsoftSignInResolvers2) => {
  microsoftSignInResolvers2.emailMatchingUserEntityAnnotation = pluginAuthNode.createSignInResolverFactory({
    create() {
      return async (info, ctx) => {
        const { profile } = info;
        if (!profile.email) {
          throw new Error("Microsoft profile contained no email");
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "microsoft.com/email": profile.email
          }
        });
      };
    }
  });
})(exports.microsoftSignInResolvers || (exports.microsoftSignInResolvers = {}));

const authModuleMicrosoftProvider$1 = backendPluginApi.createBackendModule({
  pluginId: "auth",
  moduleId: "microsoft-provider",
  register(reg) {
    reg.registerInit({
      deps: {
        providers: pluginAuthNode.authProvidersExtensionPoint
      },
      async init({ providers }) {
        providers.registerProvider({
          providerId: "microsoft",
          factory: pluginAuthNode.createOAuthProviderFactory({
            authenticator: microsoftAuthenticator,
            signInResolverFactories: {
              ...exports.microsoftSignInResolvers,
              ...pluginAuthNode.commonSignInResolvers
            }
          })
        });
      }
    });
  }
});

const authModuleMicrosoftProvider = authModuleMicrosoftProvider$1;

exports.authModuleMicrosoftProvider = authModuleMicrosoftProvider;
exports.default = authModuleMicrosoftProvider$1;
exports.microsoftAuthenticator = microsoftAuthenticator;
//# sourceMappingURL=index.cjs.js.map
