import React, { useMemo, Children, isValidElement, Fragment } from 'react';
import { createVersionedContext, createVersionedValueMap, getOrCreateGlobalSingleton, useVersionedContext } from '@backstage/version-bridge';
import { createRouteRef, createSubRouteRef, createExternalRouteRef, useApi, appTreeApiRef, componentsApiRef, iconsApiRef, coreComponentRefs, routeResolutionApiRef, createPlugin, createPageExtension, createExtensionInput, coreExtensionData, createApiExtension, createExtension, createExtensionOverrides } from '@backstage/frontend-plugin-api';
import { getComponentData } from '@backstage/core-plugin-api';
import { Route, Routes } from 'react-router-dom';

const AppContext = createVersionedContext("app-context");
const AppContextProvider = ({
  appContext,
  children
}) => {
  const versionedValue = createVersionedValueMap({ 1: appContext });
  return /* @__PURE__ */ React.createElement(AppContext.Provider, { value: versionedValue, children });
};

const routeRefType = getOrCreateGlobalSingleton(
  "route-ref-type",
  () => Symbol("route-ref-type")
);

function toInternalRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/RouteRef") {
    throw new Error(`Invalid RouteRef, bad type '${r.$$type}'`);
  }
  return r;
}

function toInternalSubRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/SubRouteRef") {
    throw new Error(`Invalid SubRouteRef, bad type '${r.$$type}'`);
  }
  return r;
}

function toInternalExternalRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/ExternalRouteRef") {
    throw new Error(`Invalid ExternalRouteRef, bad type '${r.$$type}'`);
  }
  return r;
}

function convertLegacyRouteRefs(refs) {
  return Object.fromEntries(
    Object.entries(refs).map(([name, ref]) => [
      name,
      convertLegacyRouteRef(ref)
    ])
  );
}
function convertLegacyRouteRef(ref) {
  if ("$$type" in ref) {
    return ref;
  }
  const type = ref[routeRefType];
  if (type === "absolute") {
    const legacyRef = ref;
    const legacyRefStr = String(legacyRef);
    const newRef = toInternalRouteRef(
      createRouteRef({
        params: legacyRef.params
      })
    );
    return Object.assign(legacyRef, {
      $$type: "@backstage/RouteRef",
      version: "v1",
      T: newRef.T,
      getParams() {
        return newRef.getParams();
      },
      getDescription() {
        return legacyRefStr;
      },
      setId(id) {
        newRef.setId(id);
      },
      toString() {
        return legacyRefStr;
      }
    });
  }
  if (type === "sub") {
    const legacyRef = ref;
    const legacyRefStr = String(legacyRef);
    const newRef = toInternalSubRouteRef(
      createSubRouteRef({
        path: legacyRef.path,
        parent: convertLegacyRouteRef(legacyRef.parent)
      })
    );
    return Object.assign(legacyRef, {
      $$type: "@backstage/SubRouteRef",
      version: "v1",
      T: newRef.T,
      getParams() {
        return newRef.getParams();
      },
      getParent() {
        return newRef.getParent();
      },
      getDescription() {
        return legacyRefStr;
      },
      toString() {
        return legacyRefStr;
      }
    });
  }
  if (type === "external") {
    const legacyRef = ref;
    const legacyRefStr = String(legacyRef);
    const newRef = toInternalExternalRouteRef(
      createExternalRouteRef({
        params: legacyRef.params,
        optional: legacyRef.optional
      })
    );
    return Object.assign(legacyRef, {
      $$type: "@backstage/ExternalRouteRef",
      version: "v1",
      T: newRef.T,
      optional: newRef.optional,
      getParams() {
        return newRef.getParams();
      },
      getDescription() {
        return legacyRefStr;
      },
      getDefaultTarget() {
        return void 0;
      },
      setId(id) {
        newRef.setId(id);
      },
      toString() {
        return legacyRefStr;
      }
    });
  }
  throw new Error(`Failed to convert legacy route ref, unknown type '${type}'`);
}

const legacyPluginStore = getOrCreateGlobalSingleton(
  "legacy-plugin-compatibility-store",
  () => /* @__PURE__ */ new WeakMap()
);
function toLegacyPlugin(plugin) {
  let legacy = legacyPluginStore.get(plugin);
  if (legacy) {
    return legacy;
  }
  const errorMsg = "Not implemented in legacy plugin compatibility layer";
  const notImplemented = () => {
    throw new Error(errorMsg);
  };
  legacy = {
    getId() {
      return plugin.id;
    },
    get routes() {
      return {};
    },
    get externalRoutes() {
      return {};
    },
    getApis: notImplemented,
    getFeatureFlags: notImplemented,
    provide: notImplemented
  };
  legacyPluginStore.set(plugin, legacy);
  return legacy;
}
function toNewPlugin(plugin) {
  return createPlugin({
    id: plugin.getId()
  });
}
function LegacyAppContextProvider(props) {
  const appTreeApi = useApi(appTreeApiRef);
  const componentsApi = useApi(componentsApiRef);
  const iconsApi = useApi(iconsApiRef);
  const appContext = useMemo(() => {
    const { tree } = appTreeApi.getTree();
    let gatheredPlugins = void 0;
    const ErrorBoundaryFallback = componentsApi.getComponent(
      coreComponentRefs.errorBoundaryFallback
    );
    const ErrorBoundaryFallbackWrapper = ({ plugin, ...rest }) => /* @__PURE__ */ React.createElement(
      ErrorBoundaryFallback,
      {
        ...rest,
        plugin: plugin && toNewPlugin(plugin)
      }
    );
    return {
      getPlugins() {
        if (gatheredPlugins) {
          return gatheredPlugins;
        }
        const pluginSet = /* @__PURE__ */ new Set();
        for (const node of tree.nodes.values()) {
          const plugin = node.spec.source;
          if (plugin) {
            pluginSet.add(toLegacyPlugin(plugin));
          }
        }
        gatheredPlugins = Array.from(pluginSet);
        return gatheredPlugins;
      },
      getSystemIcon(key) {
        return iconsApi.getIcon(key);
      },
      getSystemIcons() {
        return Object.fromEntries(
          iconsApi.listIconKeys().map((key) => [key, iconsApi.getIcon(key)])
        );
      },
      getComponents() {
        return {
          NotFoundErrorPage: componentsApi.getComponent(
            coreComponentRefs.notFoundErrorPage
          ),
          BootErrorPage() {
            throw new Error(
              "The BootErrorPage app component should not be accessed by plugins"
            );
          },
          Progress: componentsApi.getComponent(coreComponentRefs.progress),
          Router() {
            throw new Error(
              "The Router app component should not be accessed by plugins"
            );
          },
          ErrorBoundaryFallback: ErrorBoundaryFallbackWrapper
        };
      }
    };
  }, [appTreeApi, componentsApi, iconsApi]);
  return /* @__PURE__ */ React.createElement(AppContextProvider, { appContext }, props.children);
}
const RoutingContext = createVersionedContext(
  "routing-context"
);
function LegacyRoutingProvider(props) {
  const routeResolutionApi = useApi(routeResolutionApiRef);
  const value = useMemo(() => {
    return createVersionedValueMap({
      1: {
        resolve(anyRouteRef, location) {
          var _a;
          const sourcePath = typeof location === "string" ? location : (_a = location.pathname) != null ? _a : "";
          return routeResolutionApi.resolve(
            // This removes the requirement to use convertLegacyRouteRef inside plugins, but
            // they still need to converted when passed to the plugin instance
            convertLegacyRouteRef(anyRouteRef),
            { sourcePath }
          );
        }
      }
    });
  }, [routeResolutionApi]);
  return /* @__PURE__ */ React.createElement(RoutingContext.Provider, { value }, props.children);
}
function BackwardsCompatProvider(props) {
  return /* @__PURE__ */ React.createElement(LegacyRoutingProvider, null, /* @__PURE__ */ React.createElement(LegacyAppContextProvider, null, props.children));
}

function ForwardsCompatProvider(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, props.children);
}

function BidirectionalCompatProvider(props) {
  const isInNewApp = !useVersionedContext("app-context");
  if (isInNewApp) {
    return /* @__PURE__ */ React.createElement(BackwardsCompatProvider, { ...props });
  }
  return /* @__PURE__ */ React.createElement(ForwardsCompatProvider, { ...props });
}
function compatWrapper(element) {
  return /* @__PURE__ */ React.createElement(BidirectionalCompatProvider, null, element);
}

class MultipleAnalyticsApi {
  constructor(actualApis) {
    this.actualApis = actualApis;
  }
  /**
   * Create an AnalyticsApi implementation from an array of concrete
   * implementations.
   *
   * @example
   *
   * ```jsx
   * MultipleAnalyticsApi.fromApis([
   *   SomeAnalyticsApi.fromConfig(configApi),
   *   new CustomAnalyticsApi(),
   * ]);
   * ```
   */
  static fromApis(actualApis) {
    return new MultipleAnalyticsApi(actualApis);
  }
  /**
   * Forward the event to all configured analytics API implementations.
   */
  captureEvent(event) {
    this.actualApis.forEach((analyticsApi) => {
      try {
        analyticsApi.captureEvent(event);
      } catch {
      }
    });
  }
}

class NoOpAnalyticsApi {
  captureEvent(_event) {
  }
}

function makeRoutingShimExtension(options) {
  const { name, parentExtensionId, routePath, routeRef } = options;
  return createExtension({
    kind: "routing-shim",
    name,
    attachTo: { id: parentExtensionId, input: "childRoutingShims" },
    inputs: {
      childRoutingShims: createExtensionInput({
        routePath: coreExtensionData.routePath.optional(),
        routeRef: coreExtensionData.routeRef.optional()
      })
    },
    output: {
      routePath: coreExtensionData.routePath.optional(),
      routeRef: coreExtensionData.routeRef.optional()
    },
    factory: () => ({
      routePath,
      routeRef: routeRef ? convertLegacyRouteRef(routeRef) : void 0
    })
  });
}
function visitRouteChildren(options) {
  const { children, parentExtensionId, context } = options;
  const { pluginId, extensions, getUniqueName, discoverPlugin } = context;
  Children.forEach(children, (node) => {
    var _a;
    if (!isValidElement(node)) {
      return;
    }
    const plugin = getComponentData(node, "core.plugin");
    const routeRef = getComponentData(
      node,
      "core.mountPoint"
    );
    const routePath = (_a = node.props) == null ? void 0 : _a.path;
    if (plugin) {
      discoverPlugin(plugin);
    }
    let nextParentExtensionId = parentExtensionId;
    if (routeRef || routePath) {
      const nextParentExtensionName = getUniqueName();
      nextParentExtensionId = `routing-shim:${pluginId}/${nextParentExtensionName}`;
      extensions.push(
        makeRoutingShimExtension({
          name: nextParentExtensionName,
          parentExtensionId,
          routePath,
          routeRef
        })
      );
    }
    visitRouteChildren({
      children: node.props.children,
      parentExtensionId: nextParentExtensionId,
      context
    });
  });
}
function collectLegacyRoutes(flatRoutesElement) {
  const pluginExtensions = /* @__PURE__ */ new Map();
  const getUniqueName = /* @__PURE__ */ (() => {
    let currentIndex = 1;
    return () => String(currentIndex++);
  })();
  const getPluginExtensions = (plugin) => {
    let extensions = pluginExtensions.get(plugin);
    if (!extensions) {
      extensions = [];
      pluginExtensions.set(plugin, extensions);
    }
    return extensions;
  };
  React.Children.forEach(
    flatRoutesElement.props.children,
    (route) => {
      if (!React.isValidElement(route)) {
        throw new Error(
          `Invalid element inside FlatRoutes, expected Route but found element of type ${typeof route}.`
        );
      }
      if (route.type !== Route) {
        throw new Error(
          `Invalid element inside FlatRoutes, expected Route but found ${route.type}.`
        );
      }
      const routeElement = route.props.element;
      const path = route.props.path;
      const plugin = getComponentData(
        routeElement,
        "core.plugin"
      );
      const routeRef = getComponentData(
        routeElement,
        "core.mountPoint"
      );
      if (!plugin) {
        throw new Error(
          // TODO(vinzscam): add See <link-to-app-migration-docs> for more info
          `Route with path ${path} has en element that can not be converted as it does not belong to a plugin. Make sure that the top-level React element of the element prop is an extension from a Backstage plugin, or remove the Route completely.`
        );
      }
      if (path === void 0) {
        throw new Error(
          `Route element inside FlatRoutes had no path prop value given`
        );
      }
      const extensions = getPluginExtensions(plugin);
      const pageExtensionName = extensions.length ? getUniqueName() : void 0;
      const pageExtensionId = `page:${plugin.getId()}${pageExtensionName ? `/${pageExtensionName}` : pageExtensionName}`;
      extensions.push(
        createPageExtension({
          name: pageExtensionName,
          defaultPath: path[0] === "/" ? path.slice(1) : path,
          routeRef: routeRef ? convertLegacyRouteRef(routeRef) : void 0,
          inputs: {
            childRoutingShims: createExtensionInput({
              routePath: coreExtensionData.routePath.optional(),
              routeRef: coreExtensionData.routeRef.optional()
            })
          },
          loader: async () => compatWrapper(
            route.props.children ? /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, { path: "*", element: routeElement }, /* @__PURE__ */ React.createElement(Route, { path: "*", element: route.props.children }))) : routeElement
          )
        })
      );
      visitRouteChildren({
        children: route.props.children,
        parentExtensionId: pageExtensionId,
        context: {
          pluginId: plugin.getId(),
          extensions,
          getUniqueName,
          discoverPlugin: getPluginExtensions
        }
      });
    }
  );
  return Array.from(pluginExtensions).map(
    ([plugin, extensions]) => {
      var _a, _b;
      return createPlugin({
        id: plugin.getId(),
        extensions: [
          ...extensions,
          ...Array.from(plugin.getApis()).map(
            (factory) => createApiExtension({ factory })
          )
        ],
        routes: convertLegacyRouteRefs((_a = plugin.routes) != null ? _a : {}),
        externalRoutes: convertLegacyRouteRefs((_b = plugin.externalRoutes) != null ? _b : {})
      });
    }
  );
}

function selectChildren(rootNode, selector, strictError) {
  return Children.toArray(rootNode).flatMap((node) => {
    if (!isValidElement(node)) {
      return [];
    }
    if (node.type === Fragment) {
      return selectChildren(node.props.children, selector, strictError);
    }
    if (selector === void 0 || selector(node)) {
      return [node];
    }
    if (strictError) {
      throw new Error(strictError);
    }
    return selectChildren(node.props.children, selector, strictError);
  });
}
function convertLegacyApp(rootElement) {
  if (getComponentData(rootElement, "core.type") === "FlatRoutes") {
    return collectLegacyRoutes(rootElement);
  }
  const appRouterEls = selectChildren(
    rootElement,
    (el) => getComponentData(el, "core.type") === "AppRouter"
  );
  if (appRouterEls.length !== 1) {
    throw new Error(
      "Failed to convert legacy app, AppRouter element could not been found. Make sure it's at the top level of the App element tree"
    );
  }
  const rootEls = selectChildren(
    appRouterEls[0].props.children,
    (el) => Boolean(el.props.children) && selectChildren(
      el.props.children,
      (innerEl) => getComponentData(innerEl, "core.type") === "FlatRoutes"
    ).length === 1
  );
  if (rootEls.length !== 1) {
    throw new Error(
      "Failed to convert legacy app, Root element containing FlatRoutes could not been found. Make sure it's within the AppRouter element of the App element tree"
    );
  }
  const [rootEl] = rootEls;
  const routesEls = selectChildren(
    rootEls[0].props.children,
    (el) => getComponentData(el, "core.type") === "FlatRoutes"
  );
  if (routesEls.length !== 1) {
    throw new Error(
      "Unexpectedly failed to find FlatRoutes in app element tree"
    );
  }
  const [routesEl] = routesEls;
  const CoreLayoutOverride = createExtension({
    namespace: "app",
    name: "layout",
    attachTo: { id: "app", input: "root" },
    inputs: {
      content: createExtensionInput(
        {
          element: coreExtensionData.reactElement
        },
        { singleton: true }
      )
    },
    output: {
      element: coreExtensionData.reactElement
    },
    factory({ inputs }) {
      return {
        element: React.cloneElement(
          rootEl,
          void 0,
          inputs.content.output.element
        )
      };
    }
  });
  const CoreNavOverride = createExtension({
    namespace: "app",
    name: "nav",
    attachTo: { id: "app/layout", input: "nav" },
    output: {},
    factory: () => ({}),
    disabled: true
  });
  const collectedRoutes = collectLegacyRoutes(routesEl);
  return [
    ...collectedRoutes,
    createExtensionOverrides({
      extensions: [CoreLayoutOverride, CoreNavOverride]
    })
  ];
}

export { MultipleAnalyticsApi, NoOpAnalyticsApi, compatWrapper, convertLegacyApp, convertLegacyRouteRef, convertLegacyRouteRefs };
//# sourceMappingURL=index.esm.js.map
