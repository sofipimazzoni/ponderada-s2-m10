'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var alpha = require('@backstage/plugin-catalog-common/alpha');
var pluginPermissionNode = require('@backstage/plugin-permission-node');
var CatalogBuilder = require('./cjs/CatalogBuilder-WfXI1o7H.cjs.js');
var backendPluginApi = require('@backstage/backend-plugin-api');
var alpha$1 = require('@backstage/plugin-catalog-node/alpha');
var lodash = require('lodash');
require('@backstage/backend-common');
require('@backstage/catalog-model');
require('@backstage/integration');
require('crypto');
require('@backstage/errors');
require('core-js/features/promise');
require('codeowners-utils');
require('git-url-parse');
require('@backstage/plugin-catalog-node');
require('fs-extra');
require('glob');
require('path');
require('util');
require('yaml');
require('p-limit');
require('uuid');
require('luxon');
require('prom-client');
require('@opentelemetry/api');
require('fast-json-stable-stringify');
require('lodash/uniq');
require('lodash/chunk');
require('zod');
require('@backstage/types');
require('@backstage/catalog-client');
require('yn');
require('@backstage/backend-openapi-utils');
require('@backstage/plugin-permission-common');
require('minimatch');
require('@backstage/config');

const { conditions, createConditionalDecision } = pluginPermissionNode.createConditionExports({
  pluginId: "catalog",
  resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
  rules: CatalogBuilder.permissionRules
});
const catalogConditions = conditions;
const createCatalogConditionalDecision = createConditionalDecision;

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _processors, _entityProviders, _placeholderResolvers, _onProcessingErrorHandler, _locationAnalyzers, _permissions, _permissionRules, _fieldValidators, _entityDataParser;
class CatalogProcessingExtensionPointImpl {
  constructor() {
    __privateAdd(this, _processors, new Array());
    __privateAdd(this, _entityProviders, new Array());
    __privateAdd(this, _placeholderResolvers, {});
    __privateAdd(this, _onProcessingErrorHandler, void 0);
  }
  addProcessor(...processors) {
    __privateGet(this, _processors).push(...processors.flat());
  }
  addEntityProvider(...providers) {
    __privateGet(this, _entityProviders).push(...providers.flat());
  }
  addPlaceholderResolver(key, resolver) {
    if (key in __privateGet(this, _placeholderResolvers))
      throw new Error(
        `A placeholder resolver for '${key}' has already been set up, please check your config.`
      );
    __privateGet(this, _placeholderResolvers)[key] = resolver;
  }
  setOnProcessingErrorHandler(handler) {
    __privateSet(this, _onProcessingErrorHandler, handler);
  }
  get processors() {
    return __privateGet(this, _processors);
  }
  get entityProviders() {
    return __privateGet(this, _entityProviders);
  }
  get placeholderResolvers() {
    return __privateGet(this, _placeholderResolvers);
  }
  get onProcessingErrorHandler() {
    return __privateGet(this, _onProcessingErrorHandler);
  }
}
_processors = new WeakMap();
_entityProviders = new WeakMap();
_placeholderResolvers = new WeakMap();
_onProcessingErrorHandler = new WeakMap();
class CatalogAnalysisExtensionPointImpl {
  constructor() {
    __privateAdd(this, _locationAnalyzers, new Array());
  }
  addLocationAnalyzer(analyzer) {
    __privateGet(this, _locationAnalyzers).push(analyzer);
  }
  get locationAnalyzers() {
    return __privateGet(this, _locationAnalyzers);
  }
}
_locationAnalyzers = new WeakMap();
class CatalogPermissionExtensionPointImpl {
  constructor() {
    __privateAdd(this, _permissions, new Array());
    __privateAdd(this, _permissionRules, new Array());
  }
  addPermissions(...permission) {
    __privateGet(this, _permissions).push(...permission.flat());
  }
  addPermissionRules(...rules) {
    __privateGet(this, _permissionRules).push(...rules.flat());
  }
  get permissions() {
    return __privateGet(this, _permissions);
  }
  get permissionRules() {
    return __privateGet(this, _permissionRules);
  }
}
_permissions = new WeakMap();
_permissionRules = new WeakMap();
class CatalogModelExtensionPointImpl {
  constructor() {
    __privateAdd(this, _fieldValidators, {});
    __privateAdd(this, _entityDataParser, void 0);
  }
  setFieldValidators(validators) {
    lodash.merge(__privateGet(this, _fieldValidators), validators);
  }
  get fieldValidators() {
    return __privateGet(this, _fieldValidators);
  }
  setEntityDataParser(parser) {
    if (__privateGet(this, _entityDataParser)) {
      throw new Error(
        "Attempted to install second EntityDataParser. Only one can be set."
      );
    }
    __privateSet(this, _entityDataParser, parser);
  }
  get entityDataParser() {
    return __privateGet(this, _entityDataParser);
  }
}
_fieldValidators = new WeakMap();
_entityDataParser = new WeakMap();
const catalogPlugin = backendPluginApi.createBackendPlugin({
  pluginId: "catalog",
  register(env) {
    const processingExtensions = new CatalogProcessingExtensionPointImpl();
    env.registerExtensionPoint(
      alpha$1.catalogProcessingExtensionPoint,
      processingExtensions
    );
    const analysisExtensions = new CatalogAnalysisExtensionPointImpl();
    env.registerExtensionPoint(
      alpha$1.catalogAnalysisExtensionPoint,
      analysisExtensions
    );
    const permissionExtensions = new CatalogPermissionExtensionPointImpl();
    env.registerExtensionPoint(
      alpha$1.catalogPermissionExtensionPoint,
      permissionExtensions
    );
    const modelExtensions = new CatalogModelExtensionPointImpl();
    env.registerExtensionPoint(alpha$1.catalogModelExtensionPoint, modelExtensions);
    env.registerInit({
      deps: {
        logger: backendPluginApi.coreServices.logger,
        config: backendPluginApi.coreServices.rootConfig,
        reader: backendPluginApi.coreServices.urlReader,
        permissions: backendPluginApi.coreServices.permissions,
        database: backendPluginApi.coreServices.database,
        httpRouter: backendPluginApi.coreServices.httpRouter,
        lifecycle: backendPluginApi.coreServices.lifecycle,
        scheduler: backendPluginApi.coreServices.scheduler,
        discovery: backendPluginApi.coreServices.discovery,
        auth: backendPluginApi.coreServices.auth,
        httpAuth: backendPluginApi.coreServices.httpAuth
      },
      async init({
        logger,
        config,
        reader,
        database,
        permissions,
        httpRouter,
        lifecycle,
        scheduler,
        discovery,
        auth,
        httpAuth
      }) {
        const builder = await CatalogBuilder.CatalogBuilder.create({
          config,
          reader,
          permissions,
          database,
          scheduler,
          logger,
          discovery,
          auth,
          httpAuth
        });
        if (processingExtensions.onProcessingErrorHandler) {
          builder.subscribe({
            onProcessingError: processingExtensions.onProcessingErrorHandler
          });
        }
        builder.addProcessor(...processingExtensions.processors);
        builder.addEntityProvider(...processingExtensions.entityProviders);
        if (modelExtensions.entityDataParser) {
          builder.setEntityDataParser(modelExtensions.entityDataParser);
        }
        Object.entries(processingExtensions.placeholderResolvers).forEach(
          ([key, resolver]) => builder.setPlaceholderResolver(key, resolver)
        );
        builder.addLocationAnalyzers(...analysisExtensions.locationAnalyzers);
        builder.addPermissions(...permissionExtensions.permissions);
        builder.addPermissionRules(...permissionExtensions.permissionRules);
        builder.setFieldFormatValidators(modelExtensions.fieldValidators);
        const { processingEngine, router } = await builder.build();
        await processingEngine.start();
        lifecycle.addShutdownHook(() => processingEngine.stop());
        httpRouter.use(router);
      }
    });
  }
});

exports.createCatalogPermissionRule = CatalogBuilder.createCatalogPermissionRule;
exports.permissionRules = CatalogBuilder.permissionRules;
exports.catalogConditions = catalogConditions;
exports.createCatalogConditionalDecision = createCatalogConditionalDecision;
exports.default = catalogPlugin;
//# sourceMappingURL=alpha.cjs.js.map
