import { parseEntityRef } from '@backstage/catalog-model';
import { ResponseError } from '@backstage/errors';
import qs from 'qs';
import ObservableImpl from 'zen-observable';
import { EventSourcePolyfill } from 'event-source-polyfill';
import { createExternalRouteRef, createRouteRef, createSubRouteRef } from '@backstage/core-plugin-api';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ScaffolderClient {
  constructor(options) {
    __publicField(this, "discoveryApi");
    __publicField(this, "scmIntegrationsApi");
    __publicField(this, "fetchApi");
    __publicField(this, "identityApi");
    __publicField(this, "useLongPollingLogs");
    var _a, _b;
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = (_a = options.fetchApi) != null ? _a : { fetch };
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.useLongPollingLogs = (_b = options.useLongPollingLogs) != null ? _b : false;
    this.identityApi = options.identityApi;
  }
  async listTasks(options) {
    if (!this.identityApi) {
      throw new Error(
        "IdentityApi is not available in the ScaffolderClient, please pass through the IdentityApi to the ScaffolderClient constructor in order to use the listTasks method"
      );
    }
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const { userEntityRef } = await this.identityApi.getBackstageIdentity();
    const query = qs.stringify(
      options.filterByOwnership === "owned" ? { createdBy: userEntityRef } : {}
    );
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/tasks?${query}`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async getIntegrationsList(options) {
    const integrations = [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list().filter(
        (item) => !this.scmIntegrationsApi.bitbucketCloud.byHost(item.config.host) && !this.scmIntegrationsApi.bitbucketServer.byHost(item.config.host)
      ),
      ...this.scmIntegrationsApi.bitbucketCloud.list(),
      ...this.scmIntegrationsApi.bitbucketServer.list(),
      ...this.scmIntegrationsApi.gerrit.list(),
      ...this.scmIntegrationsApi.gitea.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({ type: c.type, title: c.title, host: c.config.host })).filter((c) => options.allowedHosts.includes(c.host));
    return {
      integrations
    };
  }
  async getTemplateParameterSchema(templateRef) {
    const { namespace, kind, name } = parseEntityRef(templateRef, {
      defaultKind: "template"
    });
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const templatePath = [namespace, kind, name].map((s) => encodeURIComponent(s)).join("/");
    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const schema = await response.json();
    return schema;
  }
  async scaffold(options) {
    const { templateRef, values, secrets = {} } = options;
    const url = `${await this.discoveryApi.getBaseUrl("scaffolder")}/v2/tasks`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        templateRef,
        values: { ...values },
        secrets
      })
    });
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const { id } = await response.json();
    return { taskId: id };
  }
  async getTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  streamLogs(options) {
    if (this.useLongPollingLogs) {
      return this.streamLogsPolling(options);
    }
    return this.streamLogsEventStream(options);
  }
  async dryRun(options) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/dry-run`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        template: options.template,
        values: options.values,
        secrets: options.secrets,
        directoryContents: options.directoryContents
      })
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
  streamLogsEventStream({
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      var _a;
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      Promise.all([
        this.discoveryApi.getBaseUrl("scaffolder"),
        (_a = this.identityApi) == null ? void 0 : _a.getCredentials()
      ]).then(
        ([baseUrl, credentials]) => {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/eventstream`;
          const processEvent = (event) => {
            if (event.data) {
              try {
                subscriber.next(JSON.parse(event.data));
              } catch (ex) {
                subscriber.error(ex);
              }
            }
          };
          const eventSource = new EventSourcePolyfill(url, {
            withCredentials: true,
            headers: (credentials == null ? void 0 : credentials.token) ? { Authorization: `Bearer ${credentials.token}` } : {}
          });
          eventSource.addEventListener("log", processEvent);
          eventSource.addEventListener("recovered", processEvent);
          eventSource.addEventListener("cancelled", processEvent);
          eventSource.addEventListener("completion", (event) => {
            processEvent(event);
            eventSource.close();
            subscriber.complete();
          });
          eventSource.addEventListener("error", (event) => {
            subscriber.error(event);
          });
        },
        (error) => {
          subscriber.error(error);
        }
      );
    });
  }
  streamLogsPolling({
    taskId,
    after: inputAfter
  }) {
    let after = inputAfter;
    return new ObservableImpl((subscriber) => {
      this.discoveryApi.getBaseUrl("scaffolder").then(async (baseUrl) => {
        while (!subscriber.closed) {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/events?${qs.stringify({ after })}`;
          const response = await this.fetchApi.fetch(url);
          if (!response.ok) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
            continue;
          }
          const logs = await response.json();
          for (const event of logs) {
            after = Number(event.id);
            subscriber.next(event);
            if (event.type === "completion") {
              subscriber.complete();
              return;
            }
          }
        }
      });
    });
  }
  async listActions() {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/actions`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async cancelTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/cancel`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST"
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
}

const registerComponentRouteRef = createExternalRouteRef({
  id: "register-component",
  optional: true
});
const viewTechDocRouteRef = createExternalRouteRef({
  id: "view-techdoc",
  optional: true,
  params: ["namespace", "kind", "name"]
});
const rootRouteRef = createRouteRef({
  id: "scaffolder"
});
createSubRouteRef({
  id: "scaffolder/legacy/selected-template",
  parent: rootRouteRef,
  path: "/templates/:templateName"
});
const selectedTemplateRouteRef = createSubRouteRef({
  id: "scaffolder/selected-template",
  parent: rootRouteRef,
  path: "/templates/:namespace/:templateName"
});
const scaffolderTaskRouteRef = createSubRouteRef({
  id: "scaffolder/task",
  parent: rootRouteRef,
  path: "/tasks/:taskId"
});
const scaffolderListTaskRouteRef = createSubRouteRef({
  id: "scaffolder/list-tasks",
  parent: rootRouteRef,
  path: "/tasks"
});
const actionsRouteRef = createSubRouteRef({
  id: "scaffolder/actions",
  parent: rootRouteRef,
  path: "/actions"
});
const editRouteRef = createSubRouteRef({
  id: "scaffolder/edit",
  parent: rootRouteRef,
  path: "/edit"
});

export { ScaffolderClient as S, scaffolderTaskRouteRef as a, actionsRouteRef as b, scaffolderListTaskRouteRef as c, registerComponentRouteRef as d, editRouteRef as e, rootRouteRef as r, selectedTemplateRouteRef as s, viewTechDocRouteRef as v };
//# sourceMappingURL=routes-BvToNy4N.esm.js.map
