import React, { useState, Fragment, useCallback, createContext, useRef, useMemo, useContext, useEffect, Component, Children, memo } from 'react';
import { useNavigate, Link as Link$1, Navigate, useOutlet, Routes, Route } from 'react-router-dom';
import { useTemplateSecrets, scaffolderApiRef, useCustomFieldExtensions, useCustomLayouts, SecretsContextProvider } from '@backstage/plugin-scaffolder-react';
import { E as EntityPicker, a as EntityPickerSchema, b as EntityNamePicker, e as entityNamePickerValidation, c as EntityNamePickerSchema, l as EntityTagsPicker, m as EntityTagsPickerSchema, R as RepoUrlPicker, r as repoPickerValidation, f as RepoUrlPickerSchema, O as OwnerPicker, g as OwnerPickerSchema, j as OwnedEntityPicker, k as OwnedEntityPickerSchema, h as MyGroupsPicker, i as MyGroupsPickerSchema, M as MultiEntityPicker, d as MultiEntityPickerSchema, v as validateMultiEntityPickerValidation, n as OngoingTask } from './OngoingTask-ClfJCJcE.esm.js';
import { ScaffolderField, ScaffolderPageContextMenu, TemplateCategoryPicker, TemplateGroups, Workflow, createAsyncValidators, Stepper, Form } from '@backstage/plugin-scaffolder-react/alpha';
import Input from '@material-ui/core/Input';
import InputLabel from '@material-ui/core/InputLabel';
import { e as editRouteRef, c as scaffolderListTaskRouteRef, r as rootRouteRef, b as actionsRouteRef, d as registerComponentRouteRef, v as viewTechDocRouteRef, s as selectedTemplateRouteRef, a as scaffolderTaskRouteRef } from './routes-BvToNy4N.esm.js';
import { Progress, ErrorPage, MarkdownContent, Page, Header, Content, CodeSnippet, StatusError, StatusOK, StatusPending, ErrorPanel, EmptyState, Table as Table$1, Link, DocsIcon, ContentHeader, SupportButton, LogViewer } from '@backstage/core-components';
import useAsync from 'react-use/esm/useAsync';
import Accordion from '@material-ui/core/Accordion';
import AccordionDetails from '@material-ui/core/AccordionDetails';
import AccordionSummary from '@material-ui/core/AccordionSummary';
import Box from '@material-ui/core/Box';
import Collapse from '@material-ui/core/Collapse';
import Grid from '@material-ui/core/Grid';
import Paper from '@material-ui/core/Paper';
import Table from '@material-ui/core/Table';
import TableBody from '@material-ui/core/TableBody';
import TableCell from '@material-ui/core/TableCell';
import TableContainer from '@material-ui/core/TableContainer';
import TableHead from '@material-ui/core/TableHead';
import TableRow from '@material-ui/core/TableRow';
import Typography from '@material-ui/core/Typography';
import { makeStyles, createStyles } from '@material-ui/core/styles';
import classNames from 'classnames';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ExpandLessIcon from '@material-ui/icons/ExpandLess';
import { useApi, useRouteRef, useApp, useRouteRefParams, AnalyticsContext, useApiHolder, alertApiRef } from '@backstage/core-plugin-api';
import Chip from '@material-ui/core/Chip';
import { catalogApiRef, EntityRefLink, CatalogFilterLayout, EntityListProvider, EntitySearchBar, EntityKindPicker, UserListPicker, EntityTagPicker, entityRouteRef, humanizeEntityRef } from '@backstage/plugin-catalog-react';
import Card from '@material-ui/core/Card';
import List from '@material-ui/core/List';
import ListItemIcon from '@material-ui/core/ListItemIcon';
import ListItemText from '@material-ui/core/ListItemText';
import MenuItem from '@material-ui/core/MenuItem';
import SettingsIcon from '@material-ui/icons/Settings';
import AllIcon from '@material-ui/icons/FontDownload';
import { DateTime, Interval } from 'luxon';
import humanizeDuration from 'humanize-duration';
import { parseEntityRef, stringifyEntityRef, ANNOTATION_EDIT_URL } from '@backstage/catalog-model';
import Button from '@material-ui/core/Button';
import IconButton from '@material-ui/core/IconButton';
import useMediaQuery from '@material-ui/core/useMediaQuery';
import CreateComponentIcon from '@material-ui/icons/AddCircleOutline';
import { catalogEntityCreatePermission } from '@backstage/plugin-catalog-common/alpha';
import { usePermission } from '@backstage/plugin-permission-react';
import MenuList from '@material-ui/core/MenuList';
import Popover from '@material-ui/core/Popover';
import Edit from '@material-ui/icons/Edit';
import MoreVert from '@material-ui/icons/MoreVert';
import { StreamLanguage } from '@codemirror/language';
import { yaml as yaml$1 } from '@codemirror/legacy-modes/mode/yaml';
import CardContent from '@material-ui/core/CardContent';
import CardHeader from '@material-ui/core/CardHeader';
import FormControl from '@material-ui/core/FormControl';
import Select from '@material-ui/core/Select';
import CloseIcon from '@material-ui/icons/Close';
import CodeMirror from '@uiw/react-codemirror';
import yaml from 'yaml';
import useDebounce from 'react-use/esm/useDebounce';
import { useAsync as useAsync$1, useRerender, useKeyboardEvent, usePrevious } from '@react-hookz/web';
import validator from '@rjsf/validator-ajv8';
import Divider from '@material-ui/core/Divider';
import Tooltip from '@material-ui/core/Tooltip';
import RefreshIcon from '@material-ui/icons/Refresh';
import SaveIcon from '@material-ui/icons/Save';
import TreeView from '@material-ui/lab/TreeView';
import ChevronRightIcon from '@material-ui/icons/ChevronRight';
import TreeItem from '@material-ui/lab/TreeItem';
import { showPanel } from '@codemirror/view';
import ListItem from '@material-ui/core/ListItem';
import ListItemSecondaryAction from '@material-ui/core/ListItemSecondaryAction';
import Cancel from '@material-ui/icons/Cancel';
import CheckIcon from '@material-ui/icons/Check';
import DeleteIcon from '@material-ui/icons/Delete';
import DownloadIcon from '@material-ui/icons/GetApp';
import Tab from '@material-ui/core/Tab';
import Tabs from '@material-ui/core/Tabs';
import LanguageIcon from '@material-ui/icons/Language';
import Step from '@material-ui/core/Step';
import StepLabel from '@material-ui/core/StepLabel';
import Stepper$1 from '@material-ui/core/Stepper';
import StepButton from '@material-ui/core/StepButton';
import CircularProgress from '@material-ui/core/CircularProgress';
import FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';
import useInterval from 'react-use/esm/useInterval';
import LinearProgress from '@material-ui/core/LinearProgress';
import CardActionArea from '@material-ui/core/CardActionArea';
import InfoOutlinedIcon from '@material-ui/icons/InfoOutlined';
import '@material-ui/core/TextField';
import 'zod';
import '@backstage/catalog-client';
import '@material-ui/lab/Autocomplete';
import '@backstage/integration-react';
import '@material-ui/core/FormHelperText';
import 'react-use/esm/useEffectOnce';
import 'zod-to-json-schema';
import '@backstage/errors';
import 'qs';
import '@material-ui/icons/Repeat';
import '@material-ui/icons/Toc';
import '@material-ui/icons/ControlPoint';
import 'zen-observable';
import 'event-source-polyfill';

const SecretInput = (props) => {
  var _a;
  const { setSecrets, secrets } = useTemplateSecrets();
  const {
    name,
    onChange,
    schema: { title, description },
    rawErrors,
    disabled,
    errors,
    required
  } = props;
  return /* @__PURE__ */ React.createElement(
    ScaffolderField,
    {
      rawErrors,
      rawDescription: description,
      disabled,
      errors,
      required
    },
    /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: title }, title),
    /* @__PURE__ */ React.createElement(
      Input,
      {
        id: title,
        "aria-describedby": title,
        onChange: (e) => {
          var _a2, _b;
          onChange(Array((_a2 = e.target) == null ? void 0 : _a2.value.length).fill("*").join(""));
          setSecrets({ [name]: (_b = e.target) == null ? void 0 : _b.value });
        },
        value: (_a = secrets[name]) != null ? _a : "",
        type: "password",
        autoComplete: "off"
      }
    )
  );
};

const DEFAULT_SCAFFOLDER_FIELD_EXTENSIONS = [
  {
    component: EntityPicker,
    name: "EntityPicker",
    schema: EntityPickerSchema
  },
  {
    component: EntityNamePicker,
    name: "EntityNamePicker",
    validation: entityNamePickerValidation,
    schema: EntityNamePickerSchema
  },
  {
    component: EntityTagsPicker,
    name: "EntityTagsPicker",
    schema: EntityTagsPickerSchema
  },
  {
    component: RepoUrlPicker,
    name: "RepoUrlPicker",
    validation: repoPickerValidation,
    schema: RepoUrlPickerSchema
  },
  {
    component: OwnerPicker,
    name: "OwnerPicker",
    schema: OwnerPickerSchema
  },
  {
    component: OwnedEntityPicker,
    name: "OwnedEntityPicker",
    schema: OwnedEntityPickerSchema
  },
  {
    component: MyGroupsPicker,
    name: "MyGroupsPicker",
    schema: MyGroupsPickerSchema
  },
  {
    component: SecretInput,
    name: "Secret"
  },
  {
    component: MultiEntityPicker,
    name: "MultiEntityPicker",
    schema: MultiEntityPickerSchema,
    validation: validateMultiEntityPickerValidation
  }
];

const useStyles$g = makeStyles((theme) => ({
  code: {
    fontFamily: "Menlo, monospace",
    padding: theme.spacing(1),
    backgroundColor: theme.palette.type === "dark" ? theme.palette.grey[700] : theme.palette.grey[300],
    display: "inline-block",
    borderRadius: 5,
    border: `1px solid ${theme.palette.grey[500]}`,
    position: "relative"
  },
  codeRequired: {
    "&::after": {
      position: "absolute",
      content: '"*"',
      top: 0,
      right: theme.spacing(0.5),
      fontWeight: "bolder",
      color: theme.palette.error.light
    }
  }
}));
const ExamplesTable = (props) => {
  return /* @__PURE__ */ React.createElement(Grid, { container: true }, props.examples.map((example, index) => {
    return /* @__PURE__ */ React.createElement(Fragment, { key: `example-${index}` }, /* @__PURE__ */ React.createElement(Grid, { item: true, lg: 3 }, /* @__PURE__ */ React.createElement(Box, { padding: 4 }, /* @__PURE__ */ React.createElement(Typography, null, example.description))), /* @__PURE__ */ React.createElement(Grid, { item: true, lg: 9 }, /* @__PURE__ */ React.createElement(Box, { padding: 1 }, /* @__PURE__ */ React.createElement(
      CodeSnippet,
      {
        text: example.example,
        showLineNumbers: true,
        showCopyCodeButton: true,
        language: "yaml"
      }
    ))));
  }));
};
const ActionsPage = () => {
  const api = useApi(scaffolderApiRef);
  const navigate = useNavigate();
  const editorLink = useRouteRef(editRouteRef);
  const tasksLink = useRouteRef(scaffolderListTaskRouteRef);
  const createLink = useRouteRef(rootRouteRef);
  const scaffolderPageContextMenuProps = {
    onEditorClicked: () => navigate(editorLink()),
    onActionsClicked: void 0,
    onTasksClicked: () => navigate(tasksLink()),
    onCreateClicked: () => navigate(createLink())
  };
  const classes = useStyles$g();
  const { loading, value, error } = useAsync(async () => {
    return api.listActions();
  });
  const [isExpanded, setIsExpanded] = useState({});
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  if (error) {
    return /* @__PURE__ */ React.createElement(
      ErrorPage,
      {
        statusMessage: "Failed to load installed actions",
        status: "500",
        stack: error.stack
      }
    );
  }
  const renderTable = (rows) => {
    if (!rows || rows.length < 1) {
      return /* @__PURE__ */ React.createElement(Typography, null, "No schema defined");
    }
    return /* @__PURE__ */ React.createElement(TableContainer, { component: Paper }, /* @__PURE__ */ React.createElement(Table, { size: "small" }, /* @__PURE__ */ React.createElement(TableHead, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, "Name"), /* @__PURE__ */ React.createElement(TableCell, null, "Title"), /* @__PURE__ */ React.createElement(TableCell, null, "Description"), /* @__PURE__ */ React.createElement(TableCell, null, "Type"))), /* @__PURE__ */ React.createElement(TableBody, null, rows)));
  };
  const getTypes = (properties) => {
    var _a, _b;
    if (!properties.type) {
      return ["unknown"];
    }
    if (properties.type !== "array") {
      return [properties.type].flat();
    }
    return [
      `${properties.type}(${(_b = (_a = properties.items) == null ? void 0 : _a.type) != null ? _b : "unknown"})`
    ];
  };
  const formatRows = (parentId, input) => {
    const properties = input == null ? void 0 : input.properties;
    if (!properties) {
      return void 0;
    }
    return Object.entries(properties).map((entry) => {
      var _a, _b, _c;
      const [key] = entry;
      const id = `${parentId}.${key}`;
      const props = entry[1];
      const codeClassname = classNames(classes.code, {
        [classes.codeRequired]: (_a = input.required) == null ? void 0 : _a.includes(key)
      });
      const types = getTypes(props);
      return /* @__PURE__ */ React.createElement(React.Fragment, { key: id }, /* @__PURE__ */ React.createElement(TableRow, { key: id }, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement("div", { className: codeClassname }, key)), /* @__PURE__ */ React.createElement(TableCell, null, props.title), /* @__PURE__ */ React.createElement(TableCell, null, props.description), /* @__PURE__ */ React.createElement(TableCell, null, types.map(
        (type) => type.includes("object") ? /* @__PURE__ */ React.createElement(
          Chip,
          {
            label: type,
            key: type,
            icon: isExpanded[id] ? /* @__PURE__ */ React.createElement(ExpandLessIcon, null) : /* @__PURE__ */ React.createElement(ExpandMoreIcon, null),
            variant: "outlined",
            onClick: () => setIsExpanded((prevState) => {
              const state = { ...prevState };
              state[id] = !prevState[id];
              return state;
            })
          }
        ) : /* @__PURE__ */ React.createElement(Chip, { label: type, key: type, variant: "outlined" })
      ))), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, { style: { paddingBottom: 0, paddingTop: 0 }, colSpan: 6 }, /* @__PURE__ */ React.createElement(Collapse, { in: isExpanded[id], timeout: "auto", unmountOnExit: true }, /* @__PURE__ */ React.createElement(Box, { sx: { margin: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", component: "div" }, key), renderTable(
        formatRows(
          id,
          props.type === "array" ? {
            properties: (_c = (_b = props.items) == null ? void 0 : _b.properties) != null ? _c : {}
          } : props
        )
      ))))));
    });
  };
  const renderTables = (name, id, input) => {
    if (!input) {
      return void 0;
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", component: "h4" }, name), input.map((i, index) => /* @__PURE__ */ React.createElement("div", { key: index }, renderTable(
      formatRows(`${id}.${index}`, i)
    ))));
  };
  const items = value == null ? void 0 : value.map((action) => {
    var _a, _b, _c, _d, _e, _f;
    if (action.id.startsWith("legacy:")) {
      return void 0;
    }
    const oneOf = renderTables(
      "oneOf",
      `${action.id}.input`,
      (_b = (_a = action.schema) == null ? void 0 : _a.input) == null ? void 0 : _b.oneOf
    );
    return /* @__PURE__ */ React.createElement(Box, { pb: 4, key: action.id }, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", component: "h2", className: classes.code }, action.id), action.description && /* @__PURE__ */ React.createElement(MarkdownContent, { content: action.description }), ((_c = action.schema) == null ? void 0 : _c.input) && /* @__PURE__ */ React.createElement(Box, { pb: 2 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", component: "h3" }, "Input"), renderTable(
      formatRows(`${action.id}.input`, (_d = action == null ? void 0 : action.schema) == null ? void 0 : _d.input)
    ), oneOf), ((_e = action.schema) == null ? void 0 : _e.output) && /* @__PURE__ */ React.createElement(Box, { pb: 2 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", component: "h3" }, "Output"), renderTable(
      formatRows(`${action.id}.output`, (_f = action == null ? void 0 : action.schema) == null ? void 0 : _f.output)
    )), action.examples && /* @__PURE__ */ React.createElement(Accordion, null, /* @__PURE__ */ React.createElement(AccordionSummary, { expandIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, null) }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", component: "h3" }, "Examples")), /* @__PURE__ */ React.createElement(AccordionDetails, null, /* @__PURE__ */ React.createElement(Box, { pb: 2 }, /* @__PURE__ */ React.createElement(ExamplesTable, { examples: action.examples })))));
  });
  return /* @__PURE__ */ React.createElement(Page, { themeId: "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: "Create a New Component",
      title: "Installed actions",
      subtitle: "This is the collection of all installed actions"
    },
    /* @__PURE__ */ React.createElement(ScaffolderPageContextMenu, { ...scaffolderPageContextMenuProps })
  ), /* @__PURE__ */ React.createElement(Content, null, items));
};

const useStyles$f = makeStyles(
  (theme) => ({
    root: {
      backgroundColor: "rgba(0, 0, 0, .11)",
      boxShadow: "none",
      margin: theme.spacing(1, 0, 1, 0)
    },
    title: {
      margin: theme.spacing(1, 0, 0, 1),
      textTransform: "uppercase",
      fontSize: 12,
      fontWeight: "bold"
    },
    listIcon: {
      minWidth: 30,
      color: theme.palette.text.primary
    },
    menuItem: {
      minHeight: theme.spacing(6)
    },
    groupWrapper: {
      margin: theme.spacing(1, 1, 2, 1)
    }
  }),
  {
    name: "ScaffolderReactOwnerListPicker"
  }
);
function getFilterGroups() {
  return [
    {
      name: "Task Owner",
      items: [
        {
          id: "owned",
          label: "Owned",
          icon: SettingsIcon
        },
        {
          id: "all",
          label: "All",
          icon: AllIcon
        }
      ]
    }
  ];
}
const OwnerListPicker = (props) => {
  const { filter, onSelectOwner } = props;
  const classes = useStyles$f();
  const filterGroups = getFilterGroups();
  return /* @__PURE__ */ React.createElement(Card, { className: classes.root }, filterGroups.map((group) => /* @__PURE__ */ React.createElement(Fragment, { key: group.name }, /* @__PURE__ */ React.createElement(
    Typography,
    {
      variant: "subtitle2",
      component: "span",
      className: classes.title
    },
    group.name
  ), /* @__PURE__ */ React.createElement(Card, { className: classes.groupWrapper }, /* @__PURE__ */ React.createElement(List, { disablePadding: true, dense: true, role: "menu" }, group.items.map((item) => /* @__PURE__ */ React.createElement(
    MenuItem,
    {
      key: item.id,
      divider: true,
      ContainerProps: { role: "menuitem" },
      onClick: () => onSelectOwner(item.id),
      selected: item.id === filter,
      className: classes.menuItem,
      "data-testid": `owner-picker-${item.id}`
    },
    item.icon && /* @__PURE__ */ React.createElement(ListItemIcon, { className: classes.listIcon }, /* @__PURE__ */ React.createElement(item.icon, { fontSize: "small" })),
    /* @__PURE__ */ React.createElement(ListItemText, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, item.label))
  )))))));
};

const CreatedAtColumn = ({ createdAt }) => {
  const createdAtTime = DateTime.fromISO(createdAt);
  const formatted = Interval.fromDateTimes(createdAtTime, DateTime.local()).toDuration().valueOf();
  return /* @__PURE__ */ React.createElement(Typography, { paragraph: true }, humanizeDuration(formatted, { round: true }), " ago");
};

const OwnerEntityColumn = ({ entityRef }) => {
  var _a, _b, _c;
  const catalogApi = useApi(catalogApiRef);
  const { value, loading, error } = useAsync(
    () => catalogApi.getEntityByRef(entityRef || ""),
    [catalogApi, entityRef]
  );
  if (!entityRef) {
    return /* @__PURE__ */ React.createElement(Typography, { paragraph: true }, "Unknown");
  }
  if (loading || error) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(
    EntityRefLink,
    {
      entityRef: parseEntityRef(entityRef),
      title: (_c = (_b = (_a = value == null ? void 0 : value.spec) == null ? void 0 : _a.profile) == null ? void 0 : _b.displayName) != null ? _c : value == null ? void 0 : value.metadata.name
    }
  );
};

const TaskStatusColumn = ({ status }) => {
  switch (status) {
    case "processing":
      return /* @__PURE__ */ React.createElement(StatusPending, null, status);
    case "completed":
      return /* @__PURE__ */ React.createElement(StatusOK, null, status);
    case "error":
    default:
      return /* @__PURE__ */ React.createElement(StatusError, null, status);
  }
};

const TemplateTitleColumn = ({ entityRef }) => {
  const scaffolder = useApi(scaffolderApiRef);
  const { value, loading, error } = useAsync(
    () => scaffolder.getTemplateParameterSchema(entityRef || ""),
    [scaffolder, entityRef]
  );
  if (loading || error || !entityRef) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: parseEntityRef(entityRef), title: value == null ? void 0 : value.title });
};

const ListTaskPageContent = (props) => {
  var _a;
  const { initiallySelectedFilter = "owned" } = props;
  const scaffolderApi = useApi(scaffolderApiRef);
  const rootLink = useRouteRef(rootRouteRef);
  const [ownerFilter, setOwnerFilter] = useState(initiallySelectedFilter);
  const { value, loading, error } = useAsync(() => {
    var _a2;
    if (scaffolderApi.listTasks) {
      return (_a2 = scaffolderApi.listTasks) == null ? void 0 : _a2.call(scaffolderApi, { filterByOwnership: ownerFilter });
    }
    console.warn(
      "listTasks is not implemented in the scaffolderApi, please make sure to implement this method."
    );
    return Promise.resolve({ tasks: [] });
  }, [scaffolderApi, ownerFilter]);
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  if (error) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ErrorPanel, { error }), /* @__PURE__ */ React.createElement(
      EmptyState,
      {
        missing: "info",
        title: "No information to display",
        description: "There is no Tasks or there was an issue communicating with backend."
      }
    ));
  }
  return /* @__PURE__ */ React.createElement(CatalogFilterLayout, null, /* @__PURE__ */ React.createElement(CatalogFilterLayout.Filters, null, /* @__PURE__ */ React.createElement(
    OwnerListPicker,
    {
      filter: ownerFilter,
      onSelectOwner: (id) => setOwnerFilter(id)
    }
  )), /* @__PURE__ */ React.createElement(CatalogFilterLayout.Content, null, /* @__PURE__ */ React.createElement(
    Table$1,
    {
      data: (_a = value == null ? void 0 : value.tasks) != null ? _a : [],
      title: "Tasks",
      columns: [
        {
          title: "Task ID",
          field: "id",
          render: (row) => /* @__PURE__ */ React.createElement(Link, { to: `${rootLink()}/tasks/${row.id}` }, row.id)
        },
        {
          title: "Template",
          field: "spec.templateInfo.entity.metadata.title",
          render: (row) => {
            var _a2;
            return /* @__PURE__ */ React.createElement(
              TemplateTitleColumn,
              {
                entityRef: (_a2 = row.spec.templateInfo) == null ? void 0 : _a2.entityRef
              }
            );
          }
        },
        {
          title: "Created",
          field: "createdAt",
          render: (row) => /* @__PURE__ */ React.createElement(CreatedAtColumn, { createdAt: row.createdAt })
        },
        {
          title: "Owner",
          field: "createdBy",
          render: (row) => {
            var _a2, _b;
            return /* @__PURE__ */ React.createElement(OwnerEntityColumn, { entityRef: (_b = (_a2 = row.spec) == null ? void 0 : _a2.user) == null ? void 0 : _b.ref });
          }
        },
        {
          title: "Status",
          field: "status",
          render: (row) => /* @__PURE__ */ React.createElement(TaskStatusColumn, { status: row.status })
        }
      ]
    }
  )));
};
const ListTasksPage = (props) => {
  const navigate = useNavigate();
  const editorLink = useRouteRef(editRouteRef);
  const actionsLink = useRouteRef(actionsRouteRef);
  const createLink = useRouteRef(rootRouteRef);
  const scaffolderPageContextMenuProps = {
    onEditorClicked: () => navigate(editorLink()),
    onActionsClicked: () => navigate(actionsLink()),
    onTasksClicked: void 0,
    onCreateClicked: () => navigate(createLink())
  };
  return /* @__PURE__ */ React.createElement(Page, { themeId: "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: "Templates Tasks",
      title: "List template tasks",
      subtitle: "All tasks that have been started"
    },
    /* @__PURE__ */ React.createElement(ScaffolderPageContextMenu, { ...scaffolderPageContextMenuProps })
  ), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ListTaskPageContent, { ...props })));
};

const RegisterExistingButton = (props) => {
  const { title, to } = props;
  const { allowed } = usePermission({
    permission: catalogEntityCreatePermission
  });
  const isXSScreen = useMediaQuery(
    (theme) => theme.breakpoints.down("xs")
  );
  if (!to || !allowed) {
    return null;
  }
  return isXSScreen ? /* @__PURE__ */ React.createElement(
    IconButton,
    {
      component: Link$1,
      color: "primary",
      title,
      size: "small",
      to
    },
    /* @__PURE__ */ React.createElement(CreateComponentIcon, null)
  ) : /* @__PURE__ */ React.createElement(Button, { component: Link$1, variant: "contained", color: "primary", to }, title);
};

const defaultGroup = {
  title: "Templates",
  filter: () => true
};
const createGroupsWithOther = (groups) => [
  ...groups,
  {
    title: "Other Templates",
    filter: (e) => ![...groups].some(({ filter }) => filter(e))
  }
];
const TemplateListPage = (props) => {
  var _a, _b, _c;
  const registerComponentLink = useRouteRef(registerComponentRouteRef);
  const {
    TemplateCardComponent,
    groups: givenGroups = [],
    templateFilter,
    headerOptions
  } = props;
  const navigate = useNavigate();
  const editorLink = useRouteRef(editRouteRef);
  const actionsLink = useRouteRef(actionsRouteRef);
  const tasksLink = useRouteRef(scaffolderListTaskRouteRef);
  const viewTechDocsLink = useRouteRef(viewTechDocRouteRef);
  const templateRoute = useRouteRef(selectedTemplateRouteRef);
  const app = useApp();
  const groups = givenGroups.length ? createGroupsWithOther(givenGroups) : [defaultGroup];
  const scaffolderPageContextMenuProps = {
    onEditorClicked: ((_a = props == null ? void 0 : props.contextMenu) == null ? void 0 : _a.editor) !== false ? () => navigate(editorLink()) : void 0,
    onActionsClicked: ((_b = props == null ? void 0 : props.contextMenu) == null ? void 0 : _b.actions) !== false ? () => navigate(actionsLink()) : void 0,
    onTasksClicked: ((_c = props == null ? void 0 : props.contextMenu) == null ? void 0 : _c.tasks) !== false ? () => navigate(tasksLink()) : void 0
  };
  const additionalLinksForEntity = useCallback(
    (template) => {
      var _a2, _b2;
      const { kind, namespace, name } = parseEntityRef(
        stringifyEntityRef(template)
      );
      return ((_a2 = template.metadata.annotations) == null ? void 0 : _a2["backstage.io/techdocs-ref"]) && viewTechDocsLink ? [
        {
          icon: (_b2 = app.getSystemIcon("docs")) != null ? _b2 : DocsIcon,
          text: "View TechDocs",
          url: viewTechDocsLink({ kind, namespace, name })
        }
      ] : [];
    },
    [app, viewTechDocsLink]
  );
  const onTemplateSelected = useCallback(
    (template) => {
      const { namespace, name } = parseEntityRef(stringifyEntityRef(template));
      navigate(templateRoute({ namespace, templateName: name }));
    },
    [navigate, templateRoute]
  );
  return /* @__PURE__ */ React.createElement(EntityListProvider, null, /* @__PURE__ */ React.createElement(Page, { themeId: "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: "Create a new component",
      title: "Create a new component",
      subtitle: "Create new software components using standard templates in your organization",
      ...headerOptions
    },
    /* @__PURE__ */ React.createElement(ScaffolderPageContextMenu, { ...scaffolderPageContextMenuProps })
  ), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ContentHeader, { title: "Available Templates" }, /* @__PURE__ */ React.createElement(
    RegisterExistingButton,
    {
      title: "Register Existing Component",
      to: registerComponentLink && registerComponentLink()
    }
  ), /* @__PURE__ */ React.createElement(SupportButton, null, "Create new software components using standard templates. Different templates create different kinds of components (services, websites, documentation, ...).")), /* @__PURE__ */ React.createElement(CatalogFilterLayout, null, /* @__PURE__ */ React.createElement(CatalogFilterLayout.Filters, null, /* @__PURE__ */ React.createElement(EntitySearchBar, null), /* @__PURE__ */ React.createElement(EntityKindPicker, { initialFilter: "template", hidden: true }), /* @__PURE__ */ React.createElement(
    UserListPicker,
    {
      initialFilter: "all",
      availableFilters: ["all", "starred"]
    }
  ), /* @__PURE__ */ React.createElement(TemplateCategoryPicker, null), /* @__PURE__ */ React.createElement(EntityTagPicker, null)), /* @__PURE__ */ React.createElement(CatalogFilterLayout.Content, null, /* @__PURE__ */ React.createElement(
    TemplateGroups,
    {
      groups,
      templateFilter,
      TemplateCardComponent,
      onTemplateSelected,
      additionalLinksForEntity
    }
  ))))));
};

const useStyles$e = makeStyles((theme) => ({
  button: {
    color: theme.page.fontColor
  }
}));
function TemplateWizardPageContextMenu(props) {
  const { editUrl } = props;
  const classes = useStyles$e();
  const [anchorEl, setAnchorEl] = useState();
  if (!editUrl) {
    return null;
  }
  const onOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const onClose = () => {
    setAnchorEl(void 0);
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      id: "long-menu",
      "aria-label": "more",
      "aria-controls": "long-menu",
      "aria-expanded": !!anchorEl,
      "aria-haspopup": "true",
      role: "button",
      onClick: onOpen,
      "data-testid": "menu-button",
      color: "inherit",
      className: classes.button
    },
    /* @__PURE__ */ React.createElement(MoreVert, null)
  ), /* @__PURE__ */ React.createElement(
    Popover,
    {
      "aria-labelledby": "long-menu",
      open: Boolean(anchorEl),
      onClose,
      anchorEl,
      anchorOrigin: { vertical: "bottom", horizontal: "right" },
      transformOrigin: { vertical: "top", horizontal: "right" }
    },
    /* @__PURE__ */ React.createElement(MenuList, null, /* @__PURE__ */ React.createElement(MenuItem, { onClick: () => window.open(editUrl, "_blank") }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Edit, { fontSize: "small" })), /* @__PURE__ */ React.createElement(ListItemText, { primary: "Edit Configuration" })))
  ));
}

const TemplateWizardPage = (props) => {
  const rootRef = useRouteRef(rootRouteRef);
  const taskRoute = useRouteRef(scaffolderTaskRouteRef);
  const { secrets } = useTemplateSecrets();
  const scaffolderApi = useApi(scaffolderApiRef);
  const catalogApi = useApi(catalogApiRef);
  const navigate = useNavigate();
  const { templateName, namespace } = useRouteRefParams(
    selectedTemplateRouteRef
  );
  const templateRef = stringifyEntityRef({
    kind: "Template",
    namespace,
    name: templateName
  });
  const { value: editUrl } = useAsync(async () => {
    var _a;
    const data = await catalogApi.getEntityByRef(templateRef);
    return (_a = data == null ? void 0 : data.metadata.annotations) == null ? void 0 : _a[ANNOTATION_EDIT_URL];
  }, [templateRef, catalogApi]);
  const onCreate = async (values) => {
    const { taskId } = await scaffolderApi.scaffold({
      templateRef,
      values,
      secrets
    });
    navigate(taskRoute({ taskId }));
  };
  const onError = () => /* @__PURE__ */ React.createElement(Navigate, { to: rootRef() });
  return /* @__PURE__ */ React.createElement(AnalyticsContext, { attributes: { entityRef: templateRef } }, /* @__PURE__ */ React.createElement(Page, { themeId: "website" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: "Create a new component",
      title: "Create a new component",
      subtitle: "Create new software components using standard templates in your organization",
      ...props.headerOptions
    },
    /* @__PURE__ */ React.createElement(TemplateWizardPageContextMenu, { editUrl })
  ), /* @__PURE__ */ React.createElement(
    Workflow,
    {
      namespace,
      templateName,
      onCreate,
      components: props.components,
      onError,
      extensions: props.customFieldExtensions,
      formProps: props.formProps,
      layouts: props.layouts
    }
  )));
};

const showDirectoryPicker = window.showDirectoryPicker;
class WebFileAccess {
  constructor(path, handle) {
    this.path = path;
    this.handle = handle;
  }
  file() {
    return this.handle.getFile();
  }
  async save(data) {
    const writable = await this.handle.createWritable();
    await writable.write(data);
    await writable.close();
  }
}
class WebDirectoryAccess {
  constructor(handle) {
    this.handle = handle;
  }
  async listFiles() {
    const content = [];
    for await (const entry of this.listDirectoryContents(this.handle)) {
      content.push(entry);
    }
    return content;
  }
  async *listDirectoryContents(dirHandle, basePath = []) {
    for await (const handle of dirHandle.values()) {
      if (handle.kind === "file") {
        yield new WebFileAccess([...basePath, handle.name].join("/"), handle);
      } else if (handle.kind === "directory") {
        if (handle.name === ".git") {
          continue;
        }
        yield* this.listDirectoryContents(handle, [...basePath, handle.name]);
      }
    }
  }
}
class WebFileSystemAccess {
  static isSupported() {
    return Boolean(showDirectoryPicker);
  }
  static async requestDirectoryAccess() {
    if (!showDirectoryPicker) {
      throw new Error("File system access is not supported");
    }
    const handle = await showDirectoryPicker();
    return new WebDirectoryAccess(handle);
  }
  constructor() {
  }
}

const MAX_CONTENT_SIZE = 64 * 1024;
const CHUNK_SIZE = 32 * 1024;
const DryRunContext = createContext(void 0);
function base64EncodeContent(content) {
  if (content.length > MAX_CONTENT_SIZE) {
    return window.btoa("<file too large>");
  }
  try {
    return window.btoa(content);
  } catch {
    const decoder = new TextEncoder();
    const buffer = decoder.encode(content);
    const chunks = new Array();
    for (let offset = 0; offset < buffer.length; offset += CHUNK_SIZE) {
      chunks.push(
        String.fromCharCode(...buffer.slice(offset, offset + CHUNK_SIZE))
      );
    }
    return window.btoa(chunks.join(""));
  }
}
function DryRunProvider(props) {
  const scaffolderApi = useApi(scaffolderApiRef);
  const [state, setState] = useState({
    results: [],
    selectedResult: void 0
  });
  const idRef = useRef(1);
  const selectResult = useCallback((id) => {
    setState((prevState) => {
      const result = prevState.results.find((r) => r.id === id);
      if (result === prevState.selectedResult) {
        return prevState;
      }
      return {
        results: prevState.results,
        selectedResult: result
      };
    });
  }, []);
  const deleteResult = useCallback((id) => {
    setState((prevState) => {
      var _a;
      const index = prevState.results.findIndex((r) => r.id === id);
      if (index === -1) {
        return prevState;
      }
      const newResults = prevState.results.slice();
      const [deleted] = newResults.splice(index, 1);
      return {
        results: newResults,
        selectedResult: ((_a = prevState.selectedResult) == null ? void 0 : _a.id) === deleted.id ? newResults[0] : prevState.selectedResult
      };
    });
  }, []);
  const execute = useCallback(
    async (options) => {
      if (!scaffolderApi.dryRun) {
        throw new Error("Scaffolder API does not support dry-run");
      }
      const parsed = yaml.parse(options.templateContent);
      const response = await scaffolderApi.dryRun({
        template: parsed,
        values: options.values,
        secrets: {},
        directoryContents: options.files.map((file) => ({
          path: file.path,
          base64Content: base64EncodeContent(file.content)
        }))
      });
      const result = {
        ...response,
        id: idRef.current++
      };
      setState((prevState) => {
        var _a;
        return {
          results: [...prevState.results, result],
          selectedResult: (_a = prevState.selectedResult) != null ? _a : result
        };
      });
    },
    [scaffolderApi]
  );
  const dryRun = useMemo(
    () => ({
      ...state,
      selectResult,
      deleteResult,
      execute
    }),
    [state, selectResult, deleteResult, execute]
  );
  return /* @__PURE__ */ React.createElement(DryRunContext.Provider, { value: dryRun }, props.children);
}
function useDryRun() {
  const value = useContext(DryRunContext);
  if (!value) {
    throw new Error("must be used within a DryRunProvider");
  }
  return value;
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _access, _signalUpdate, _content, _savedContent, _access2, _listeners, _files, _selectedFile, _signalUpdate2;
const MAX_SIZE = 1024 * 1024;
const MAX_SIZE_MESSAGE = "This file is too large to be displayed";
class DirectoryEditorFileManager {
  constructor(access, signalUpdate) {
    __privateAdd(this, _access, void 0);
    __privateAdd(this, _signalUpdate, void 0);
    __privateAdd(this, _content, void 0);
    __privateAdd(this, _savedContent, void 0);
    __privateSet(this, _access, access);
    __privateSet(this, _signalUpdate, signalUpdate);
  }
  get path() {
    return __privateGet(this, _access).path;
  }
  get content() {
    var _a;
    return (_a = __privateGet(this, _content)) != null ? _a : MAX_SIZE_MESSAGE;
  }
  updateContent(content) {
    if (__privateGet(this, _content) === void 0) {
      return;
    }
    __privateSet(this, _content, content);
    __privateGet(this, _signalUpdate).call(this);
  }
  get dirty() {
    return __privateGet(this, _content) !== __privateGet(this, _savedContent);
  }
  async save() {
    if (__privateGet(this, _content) !== void 0) {
      await __privateGet(this, _access).save(__privateGet(this, _content));
      __privateSet(this, _savedContent, __privateGet(this, _content));
      __privateGet(this, _signalUpdate).call(this);
    }
  }
  async reload() {
    const file = await __privateGet(this, _access).file();
    if (file.size > MAX_SIZE) {
      if (__privateGet(this, _content) !== void 0) {
        __privateSet(this, _content, void 0);
        __privateSet(this, _savedContent, void 0);
        __privateGet(this, _signalUpdate).call(this);
      }
      return;
    }
    const content = await file.text();
    if (__privateGet(this, _content) !== content) {
      __privateSet(this, _content, content);
      __privateSet(this, _savedContent, content);
      __privateGet(this, _signalUpdate).call(this);
    }
  }
}
_access = new WeakMap();
_signalUpdate = new WeakMap();
_content = new WeakMap();
_savedContent = new WeakMap();
class DirectoryEditorManager {
  constructor(access) {
    __privateAdd(this, _access2, void 0);
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    __privateAdd(this, _files, []);
    __privateAdd(this, _selectedFile, void 0);
    __publicField$1(this, "setSelectedFile", (path) => {
      const prev = __privateGet(this, _selectedFile);
      const next = __privateGet(this, _files).find((file) => file.path === path);
      if (prev !== next) {
        __privateSet(this, _selectedFile, next);
        __privateGet(this, _signalUpdate2).call(this);
      }
    });
    __privateAdd(this, _signalUpdate2, () => {
      __privateGet(this, _listeners).forEach((listener) => listener());
    });
    __privateSet(this, _access2, access);
  }
  get files() {
    return __privateGet(this, _files);
  }
  get selectedFile() {
    return __privateGet(this, _selectedFile);
  }
  get dirty() {
    return __privateGet(this, _files).some((file) => file.dirty);
  }
  async save() {
    await Promise.all(__privateGet(this, _files).map((file) => file.save()));
  }
  async reload() {
    var _a;
    const selectedPath = (_a = __privateGet(this, _selectedFile)) == null ? void 0 : _a.path;
    const files = await __privateGet(this, _access2).listFiles();
    const fileManagers = await Promise.all(
      files.map(async (file) => {
        const manager = new DirectoryEditorFileManager(
          file,
          __privateGet(this, _signalUpdate2)
        );
        await manager.reload();
        return manager;
      })
    );
    __privateGet(this, _files).length = 0;
    __privateGet(this, _files).push(...fileManagers);
    this.setSelectedFile(selectedPath);
    __privateGet(this, _signalUpdate2).call(this);
  }
  subscribe(listener) {
    __privateGet(this, _listeners).add(listener);
    return () => {
      __privateGet(this, _listeners).delete(listener);
    };
  }
}
_access2 = new WeakMap();
_listeners = new WeakMap();
_files = new WeakMap();
_selectedFile = new WeakMap();
_signalUpdate2 = new WeakMap();
const DirectoryEditorContext = createContext(
  void 0
);
function useDirectoryEditor() {
  const value = useContext(DirectoryEditorContext);
  const rerender = useRerender();
  useEffect(() => value == null ? void 0 : value.subscribe(rerender), [value, rerender]);
  if (!value) {
    throw new Error("must be used within a DirectoryEditorProvider");
  }
  return value;
}
function DirectoryEditorProvider(props) {
  const { directory } = props;
  const [{ result, error }, { execute }] = useAsync$1(
    async (dir) => {
      const manager = new DirectoryEditorManager(dir);
      await manager.reload();
      const firstYaml = manager.files.find((file) => file.path.match(/\.ya?ml$/));
      if (firstYaml) {
        manager.setSelectedFile(firstYaml.path);
      }
      return manager;
    }
  );
  useEffect(() => {
    execute(directory);
  }, [execute, directory]);
  if (error) {
    return /* @__PURE__ */ React.createElement(ErrorPanel, { error });
  } else if (!result) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  return /* @__PURE__ */ React.createElement(DirectoryEditorContext.Provider, { value: result }, props.children);
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const useStyles$d = makeStyles({
  containerWrapper: {
    position: "relative",
    width: "100%",
    height: "100%"
  },
  container: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    overflow: "auto"
  }
});
class ErrorBoundary extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      shouldRender: true
    });
  }
  componentDidUpdate(prevProps) {
    if (prevProps.invalidator !== this.props.invalidator) {
      this.setState({ shouldRender: true });
    }
  }
  componentDidCatch(error) {
    this.props.setErrorText(error.message);
    this.setState({ shouldRender: false });
  }
  render() {
    return this.state.shouldRender ? this.props.children : null;
  }
}
function isJsonObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function TemplateEditorForm(props) {
  const {
    content,
    contentIsSpec,
    onDryRun,
    setErrorText,
    fieldExtensions = [],
    layouts = []
  } = props;
  const classes = useStyles$d();
  const apiHolder = useApiHolder();
  const [steps, setSteps] = useState();
  const fields = useMemo(() => {
    return Object.fromEntries(
      fieldExtensions.map(({ name, component }) => [name, component])
    );
  }, [fieldExtensions]);
  useDebounce(
    () => {
      try {
        if (!content) {
          setSteps(void 0);
          return;
        }
        const parsed = yaml.parseAllDocuments(content).filter((c) => c).map((c) => c.toJSON())[0];
        if (!isJsonObject(parsed)) {
          setSteps(void 0);
          return;
        }
        let rootObj = parsed;
        if (!contentIsSpec) {
          const isTemplate = String(parsed.kind).toLocaleLowerCase("en-US") === "template";
          if (!isTemplate) {
            setSteps(void 0);
            return;
          }
          rootObj = isJsonObject(parsed.spec) ? parsed.spec : {};
        }
        const { parameters } = rootObj;
        if (!Array.isArray(parameters)) {
          setErrorText("Template parameters must be an array");
          setSteps(void 0);
          return;
        }
        const fieldValidators = Object.fromEntries(
          fieldExtensions.map(({ name, validation }) => [name, validation])
        );
        setErrorText();
        setSteps(
          parameters.flatMap(
            (param) => isJsonObject(param) ? [
              {
                title: String(param.title),
                schema: param,
                validate: createAsyncValidators(param, fieldValidators, {
                  apiHolder
                })
              }
            ] : []
          )
        );
      } catch (e) {
        setErrorText(e.message);
      }
    },
    250,
    [contentIsSpec, content, apiHolder]
  );
  if (!steps) {
    return null;
  }
  return /* @__PURE__ */ React.createElement("div", { className: classes.containerWrapper }, /* @__PURE__ */ React.createElement("div", { className: classes.container }, /* @__PURE__ */ React.createElement(ErrorBoundary, { invalidator: steps, setErrorText }, /* @__PURE__ */ React.createElement(
    Stepper,
    {
      manifest: { steps, title: "Template Editor" },
      extensions: fieldExtensions,
      components: fields,
      onCreate: async (options) => {
        await (onDryRun == null ? void 0 : onDryRun(options));
      },
      layouts
    }
  ))));
}
function TemplateEditorFormDirectoryEditorDryRun(props) {
  const { setErrorText, fieldExtensions = [], layouts } = props;
  const dryRun = useDryRun();
  const directoryEditor = useDirectoryEditor();
  const { selectedFile } = directoryEditor;
  const handleDryRun = async (data) => {
    if (!selectedFile) {
      return;
    }
    try {
      await dryRun.execute({
        templateContent: selectedFile.content,
        values: data,
        files: directoryEditor.files
      });
      setErrorText();
    } catch (e) {
      setErrorText(String(e.cause || e));
      throw e;
    }
  };
  const content = selectedFile && selectedFile.path.match(/\.ya?ml$/) ? selectedFile.content : void 0;
  return /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      onDryRun: handleDryRun,
      fieldExtensions,
      setErrorText,
      content,
      layouts
    }
  );
}
TemplateEditorForm.DirectoryEditorDryRun = TemplateEditorFormDirectoryEditorDryRun;

const useStyles$c = makeStyles((theme) => ({
  root: {
    gridArea: "pageContent",
    display: "grid",
    gridTemplateAreas: `
      "controls controls"
      "fieldForm preview"
    `,
    gridTemplateRows: "auto 1fr",
    gridTemplateColumns: "1fr 1fr"
  },
  controls: {
    gridArea: "controls",
    display: "flex",
    flexFlow: "row nowrap",
    alignItems: "center",
    margin: theme.spacing(1)
  },
  fieldForm: {
    gridArea: "fieldForm"
  },
  preview: {
    gridArea: "preview"
  }
}));
const CustomFieldExplorer = ({
  customFieldExtensions = [],
  onClose
}) => {
  var _a, _b;
  const classes = useStyles$c();
  const fieldOptions = customFieldExtensions.filter((field) => !!field.schema);
  const [selectedField, setSelectedField] = useState(fieldOptions[0]);
  const [fieldFormState, setFieldFormState] = useState({});
  const [refreshKey, setRefreshKey] = useState(Date.now());
  const sampleFieldTemplate = useMemo(
    () => {
      var _a2, _b2;
      return yaml.stringify({
        parameters: [
          {
            title: `${selectedField.name} Example`,
            properties: {
              [selectedField.name]: {
                type: (_b2 = (_a2 = selectedField.schema) == null ? void 0 : _a2.returnValue) == null ? void 0 : _b2.type,
                "ui:field": selectedField.name,
                "ui:options": fieldFormState
              }
            }
          }
        ]
      });
    },
    [fieldFormState, selectedField]
  );
  const fieldComponents = useMemo(() => {
    return Object.fromEntries(
      customFieldExtensions.map(({ name, component }) => [name, component])
    );
  }, [customFieldExtensions]);
  const handleSelectionChange = useCallback(
    (selection) => {
      setSelectedField(selection);
      setFieldFormState({});
    },
    [setFieldFormState, setSelectedField]
  );
  const handleFieldConfigChange = useCallback(
    (state) => {
      setFieldFormState(state);
      setRefreshKey(Date.now());
    },
    [setFieldFormState, setRefreshKey]
  );
  return /* @__PURE__ */ React.createElement("main", { className: classes.root }, /* @__PURE__ */ React.createElement("div", { className: classes.controls }, /* @__PURE__ */ React.createElement(FormControl, { variant: "outlined", size: "small", fullWidth: true }, /* @__PURE__ */ React.createElement(InputLabel, { id: "select-field-label" }, "Choose Custom Field Extension"), /* @__PURE__ */ React.createElement(
    Select,
    {
      value: selectedField,
      label: "Choose Custom Field Extension",
      labelId: "select-field-label",
      onChange: (e) => handleSelectionChange(e.target.value)
    },
    fieldOptions.map((option, idx) => /* @__PURE__ */ React.createElement(MenuItem, { key: idx, value: option }, option.name))
  )), /* @__PURE__ */ React.createElement(IconButton, { size: "medium", onClick: onClose, "aria-label": "Close" }, /* @__PURE__ */ React.createElement(CloseIcon, null))), /* @__PURE__ */ React.createElement("div", { className: classes.fieldForm }, /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardHeader, { title: "Field Options" }), /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(
    Form,
    {
      showErrorList: false,
      fields: { ...fieldComponents },
      noHtml5Validate: true,
      formData: fieldFormState,
      formContext: { fieldFormState },
      onSubmit: (e) => handleFieldConfigChange(e.formData),
      validator,
      schema: ((_a = selectedField.schema) == null ? void 0 : _a.uiOptions) || {},
      experimental_defaultFormStateBehavior: {
        allOf: "populateDefaults"
      }
    },
    /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "primary",
        type: "submit",
        disabled: !((_b = selectedField.schema) == null ? void 0 : _b.uiOptions)
      },
      "Apply"
    )
  )))), /* @__PURE__ */ React.createElement("div", { className: classes.preview }, /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardHeader, { title: "Example Template Spec" }), /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(
    CodeMirror,
    {
      readOnly: true,
      theme: "dark",
      height: "100%",
      extensions: [StreamLanguage.define(yaml$1)],
      value: sampleFieldTemplate
    }
  ))), /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      key: refreshKey,
      content: sampleFieldTemplate,
      contentIsSpec: true,
      fieldExtensions: customFieldExtensions,
      setErrorText: () => null
    }
  )));
};

const useStyles$b = makeStyles({
  root: {
    whiteSpace: "nowrap",
    overflowY: "auto"
  }
});
function parseFileEntires(paths) {
  const root = {
    type: "directory",
    name: "",
    path: "",
    children: []
  };
  for (const path of paths.slice().sort()) {
    const parts = path.split("/");
    let current = root;
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (part === "") {
        throw new Error(`Invalid path part: ''`);
      }
      const entryPath = parts.slice(0, i + 1).join("/");
      const existing = current.children.find((child) => child.name === part);
      if ((existing == null ? void 0 : existing.type) === "file") {
        throw new Error(`Duplicate filename at '${entryPath}'`);
      } else if (existing) {
        current = existing;
      } else {
        if (i < parts.length - 1) {
          const newEntry = {
            type: "directory",
            name: part,
            path: entryPath,
            children: []
          };
          const firstFileIndex = current.children.findIndex(
            (child) => child.type === "file"
          );
          current.children.splice(firstFileIndex, 0, newEntry);
          current = newEntry;
        } else {
          current.children.push({
            type: "file",
            name: part,
            path: entryPath
          });
        }
      }
    }
  }
  return root.children;
}
function FileTreeItem({ entry }) {
  if (entry.type === "file") {
    return /* @__PURE__ */ React.createElement(TreeItem, { nodeId: entry.path, label: entry.name });
  }
  return /* @__PURE__ */ React.createElement(TreeItem, { nodeId: entry.path, label: entry.name }, entry.children.map((child) => /* @__PURE__ */ React.createElement(FileTreeItem, { key: child.path, entry: child })));
}
function FileBrowser(props) {
  const classes = useStyles$b();
  const fileTree = useMemo(
    () => parseFileEntires(props.filePaths),
    [props.filePaths]
  );
  return /* @__PURE__ */ React.createElement(
    TreeView,
    {
      selected: props.selected,
      className: classes.root,
      defaultCollapseIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, null),
      defaultExpandIcon: /* @__PURE__ */ React.createElement(ChevronRightIcon, null),
      onNodeSelect: (_e, nodeId) => {
        if (props.onSelect && props.filePaths.includes(nodeId)) {
          props.onSelect(nodeId);
        }
      }
    },
    fileTree.map((entry) => /* @__PURE__ */ React.createElement(FileTreeItem, { key: entry.path, entry }))
  );
}

const useStyles$a = makeStyles((theme) => ({
  button: {
    padding: theme.spacing(1)
  },
  buttons: {
    display: "flex",
    flexFlow: "row nowrap",
    alignItems: "center",
    justifyContent: "flex-start"
  },
  buttonsGap: {
    flex: "1 1 auto"
  },
  buttonsDivider: {
    marginBottom: theme.spacing(1)
  }
}));
function TemplateEditorBrowser(props) {
  var _a, _b;
  const classes = useStyles$a();
  const directoryEditor = useDirectoryEditor();
  const changedFiles = directoryEditor.files.filter((file) => file.dirty);
  const handleClose = () => {
    if (!props.onClose) {
      return;
    }
    if (changedFiles.length > 0) {
      const accepted = window.confirm(
        "Are you sure? Unsaved changes will be lost"
      );
      if (!accepted) {
        return;
      }
    }
    props.onClose();
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: classes.buttons }, /* @__PURE__ */ React.createElement(Tooltip, { title: "Save all files" }, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      className: classes.button,
      disabled: directoryEditor.files.every((file) => !file.dirty),
      onClick: () => directoryEditor.save()
    },
    /* @__PURE__ */ React.createElement(SaveIcon, null)
  )), /* @__PURE__ */ React.createElement(Tooltip, { title: "Reload directory" }, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      className: classes.button,
      onClick: () => directoryEditor.reload()
    },
    /* @__PURE__ */ React.createElement(RefreshIcon, null)
  )), /* @__PURE__ */ React.createElement("div", { className: classes.buttonsGap }), /* @__PURE__ */ React.createElement(Tooltip, { title: "Close directory" }, /* @__PURE__ */ React.createElement(IconButton, { className: classes.button, onClick: handleClose }, /* @__PURE__ */ React.createElement(CloseIcon, null)))), /* @__PURE__ */ React.createElement(Divider, { className: classes.buttonsDivider }), /* @__PURE__ */ React.createElement(
    FileBrowser,
    {
      selected: (_b = (_a = directoryEditor.selectedFile) == null ? void 0 : _a.path) != null ? _b : "",
      onSelect: directoryEditor.setSelectedFile,
      filePaths: directoryEditor.files.map((file) => file.path)
    }
  ));
}

const useStyles$9 = makeStyles((theme) => ({
  container: {
    position: "relative",
    width: "100%",
    height: "100%"
  },
  codeMirror: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  errorPanel: {
    color: theme.palette.error.main,
    lineHeight: 2,
    margin: theme.spacing(0, 1)
  },
  floatingButtons: {
    position: "absolute",
    top: theme.spacing(1),
    right: theme.spacing(3)
  },
  floatingButton: {
    padding: theme.spacing(1)
  }
}));
function TemplateEditorTextArea(props) {
  const { errorText } = props;
  const classes = useStyles$9();
  const panelExtension = useMemo(() => {
    if (!errorText) {
      return showPanel.of(null);
    }
    const dom = document.createElement("div");
    dom.classList.add(classes.errorPanel);
    dom.textContent = errorText;
    return showPanel.of(() => ({ dom, bottom: true }));
  }, [classes, errorText]);
  useKeyboardEvent(
    (e) => e.key === "s" && (e.ctrlKey || e.metaKey),
    (e) => {
      e.preventDefault();
      if (props.onSave) {
        props.onSave();
      }
    }
  );
  return /* @__PURE__ */ React.createElement("div", { className: classes.container }, /* @__PURE__ */ React.createElement(
    CodeMirror,
    {
      className: classes.codeMirror,
      theme: "dark",
      height: "100%",
      extensions: [StreamLanguage.define(yaml$1), panelExtension],
      value: props.content,
      onChange: props.onUpdate
    }
  ), (props.onSave || props.onReload) && /* @__PURE__ */ React.createElement("div", { className: classes.floatingButtons }, /* @__PURE__ */ React.createElement(Paper, null, props.onSave && /* @__PURE__ */ React.createElement(Tooltip, { title: "Save file" }, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      className: classes.floatingButton,
      onClick: () => {
        var _a;
        return (_a = props.onSave) == null ? void 0 : _a.call(props);
      }
    },
    /* @__PURE__ */ React.createElement(SaveIcon, null)
  )), props.onReload && /* @__PURE__ */ React.createElement(Tooltip, { title: "Reload file" }, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      className: classes.floatingButton,
      onClick: () => {
        var _a;
        return (_a = props.onReload) == null ? void 0 : _a.call(props);
      }
    },
    /* @__PURE__ */ React.createElement(RefreshIcon, null)
  )))));
}
function TemplateEditorDirectoryEditorTextArea(props) {
  var _a, _b;
  const directoryEditor = useDirectoryEditor();
  const actions = ((_a = directoryEditor.selectedFile) == null ? void 0 : _a.dirty) ? {
    onSave: () => directoryEditor.save(),
    onReload: () => directoryEditor.reload()
  } : {
    onReload: () => directoryEditor.reload()
  };
  return /* @__PURE__ */ React.createElement(
    TemplateEditorTextArea,
    {
      errorText: props.errorText,
      content: (_b = directoryEditor.selectedFile) == null ? void 0 : _b.content,
      onUpdate: (content) => {
        var _a2;
        return (_a2 = directoryEditor.selectedFile) == null ? void 0 : _a2.updateContent(content);
      },
      ...actions
    }
  );
}
TemplateEditorTextArea.DirectoryEditor = TemplateEditorDirectoryEditorTextArea;

function downloadBlob(blob, name) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
}

const useStyles$8 = makeStyles((theme) => ({
  root: {
    overflowY: "auto",
    background: theme.palette.background.default
  },
  iconSuccess: {
    minWidth: 0,
    marginRight: theme.spacing(1),
    color: theme.palette.status.ok
  },
  iconFailure: {
    minWidth: 0,
    marginRight: theme.spacing(1),
    color: theme.palette.status.error
  }
}));
function DryRunResultsList() {
  const classes = useStyles$8();
  const dryRun = useDryRun();
  return /* @__PURE__ */ React.createElement(List, { className: classes.root, dense: true }, dryRun.results.map((result) => {
    var _a;
    const failed = result.log.some((l) => l.body.status === "failed");
    let isLoading = false;
    async function downloadResult() {
      isLoading = true;
      await downloadDirectoryContents(
        result.directoryContents,
        `dry-run-result-${result.id}.zip`
      );
      isLoading = false;
    }
    return /* @__PURE__ */ React.createElement(
      ListItem,
      {
        button: true,
        key: result.id,
        selected: ((_a = dryRun.selectedResult) == null ? void 0 : _a.id) === result.id,
        onClick: () => dryRun.selectResult(result.id)
      },
      /* @__PURE__ */ React.createElement(
        ListItemIcon,
        {
          className: failed ? classes.iconFailure : classes.iconSuccess
        },
        failed ? /* @__PURE__ */ React.createElement(Cancel, null) : /* @__PURE__ */ React.createElement(CheckIcon, null)
      ),
      /* @__PURE__ */ React.createElement(ListItemText, { primary: `Result ${result.id}` }),
      /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, /* @__PURE__ */ React.createElement(
        IconButton,
        {
          edge: "end",
          "aria-label": "download",
          title: "Download as .zip",
          disabled: isLoading,
          onClick: () => downloadResult()
        },
        /* @__PURE__ */ React.createElement(DownloadIcon, null)
      ), /* @__PURE__ */ React.createElement(
        IconButton,
        {
          edge: "end",
          "aria-label": "delete",
          title: "Delete result",
          onClick: () => dryRun.deleteResult(result.id)
        },
        /* @__PURE__ */ React.createElement(DeleteIcon, null)
      ))
    );
  }));
}
async function downloadDirectoryContents(directoryContents, name) {
  const { default: JSZip } = await import('jszip');
  const zip = new JSZip();
  for (const d of directoryContents) {
    const converted = atob(d.base64Content);
    await zip.file(d.path, converted);
  }
  const blob = await zip.generateAsync({ type: "blob" });
  downloadBlob(blob, name);
}

const useStyles$7 = makeStyles((theme) => ({
  root: {
    display: "grid",
    gridTemplateColumns: "280px auto 3fr",
    gridTemplateRows: "1fr"
  },
  child: {
    overflowY: "auto",
    height: "100%",
    minHeight: 0
  },
  firstChild: {
    background: theme.palette.background.paper
  }
}));
function DryRunResultsSplitView(props) {
  const classes = useStyles$7();
  const childArray = Children.toArray(props.children);
  if (childArray.length !== 2) {
    throw new Error("must have exactly 2 children");
  }
  return /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement("div", { className: classNames(classes.child, classes.firstChild) }, childArray[0]), /* @__PURE__ */ React.createElement(Divider, { orientation: "horizontal" }), /* @__PURE__ */ React.createElement("div", { className: classes.child }, childArray[1]));
}

const useStyles$6 = makeStyles({
  svgIcon: {
    display: "inline-block",
    "& svg": {
      display: "inline-block",
      fontSize: "inherit",
      verticalAlign: "baseline"
    }
  }
});
const IconLink = (props) => {
  const { href, text, Icon, ...linkProps } = props;
  const classes = useStyles$6();
  return /* @__PURE__ */ React.createElement(Grid, { container: true, direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(Typography, { component: "div", className: classes.svgIcon }, Icon ? /* @__PURE__ */ React.createElement(Icon, null) : /* @__PURE__ */ React.createElement(LanguageIcon, null))), /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(Link, { to: href, ...linkProps }, text || href)));
};

const TaskPageLinks = ({ output }) => {
  const { links = [] } = output;
  const app = useApp();
  const entityRoute = useRouteRef(entityRouteRef);
  const iconResolver = (key) => {
    var _a;
    return key ? (_a = app.getSystemIcon(key)) != null ? _a : LanguageIcon : LanguageIcon;
  };
  return /* @__PURE__ */ React.createElement(Box, { px: 3, pb: 3 }, links.filter(({ url, entityRef }) => url || entityRef).map(({ url, entityRef, title, icon }) => {
    if (entityRef) {
      const entityName = parseEntityRef(entityRef, {
        defaultKind: "<unknown>",
        defaultNamespace: "<unknown>"
      });
      const target = entityRoute(entityName);
      return { title, icon, url: target };
    }
    return { title, icon, url };
  }).map(({ url, title, icon }, i) => /* @__PURE__ */ React.createElement(
    IconLink,
    {
      key: `output-link-${i}`,
      href: url,
      text: title != null ? title : url,
      Icon: iconResolver(icon),
      target: "_blank"
    }
  )));
};

const useStyles$5 = makeStyles(
  (theme) => createStyles({
    root: {
      width: "100%"
    },
    button: {
      marginBottom: theme.spacing(2),
      marginLeft: theme.spacing(2)
    },
    actionsContainer: {
      marginBottom: theme.spacing(2)
    },
    resetContainer: {
      padding: theme.spacing(3)
    },
    labelWrapper: {
      display: "flex",
      flex: 1,
      flexDirection: "row",
      justifyContent: "space-between"
    },
    stepWrapper: {
      width: "100%"
    }
  })
);
const useStepIconStyles = makeStyles(
  (theme) => createStyles({
    root: {
      color: theme.palette.text.disabled,
      display: "flex",
      height: 22,
      alignItems: "center"
    },
    completed: {
      color: theme.palette.status.ok
    },
    error: {
      color: theme.palette.status.error
    }
  })
);
const StepTimeTicker = ({ step }) => {
  const [time, setTime] = useState("");
  useInterval(() => {
    if (!step.startedAt) {
      setTime("");
      return;
    }
    const end = step.endedAt ? DateTime.fromISO(step.endedAt) : DateTime.local();
    const startedAt = DateTime.fromISO(step.startedAt);
    const formatted = Interval.fromDateTimes(startedAt, end).toDuration().valueOf();
    setTime(humanizeDuration(formatted, { round: true }));
  }, 1e3);
  return /* @__PURE__ */ React.createElement(Typography, { variant: "caption" }, time);
};
function TaskStepIconComponent(props) {
  const classes = useStepIconStyles();
  const { active, completed, error } = props;
  const getMiddle = () => {
    if (active) {
      return /* @__PURE__ */ React.createElement(CircularProgress, { size: "24px" });
    }
    if (completed) {
      return /* @__PURE__ */ React.createElement(CheckIcon, null);
    }
    if (error) {
      return /* @__PURE__ */ React.createElement(Cancel, null);
    }
    return /* @__PURE__ */ React.createElement(FiberManualRecordIcon, null);
  };
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      className: classNames(classes.root, {
        [classes.completed]: completed,
        [classes.error]: error
      })
    },
    getMiddle()
  );
}
const TaskStatusStepper = memo(
  (props) => {
    const { steps, currentStepId, onUserStepChange } = props;
    const classes = useStyles$5(props);
    return /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(
      Stepper$1,
      {
        activeStep: steps.findIndex((s) => s.id === currentStepId),
        orientation: "vertical",
        nonLinear: true
      },
      steps.map((step, index) => {
        const isCancelled = step.status === "cancelled";
        const isActive = step.status === "processing";
        const isCompleted = step.status === "completed";
        const isFailed = step.status === "failed";
        const isSkipped = step.status === "skipped";
        return /* @__PURE__ */ React.createElement(Step, { key: String(index), expanded: true }, /* @__PURE__ */ React.createElement(StepButton, { onClick: () => onUserStepChange(step.id) }, /* @__PURE__ */ React.createElement(
          StepLabel,
          {
            StepIconProps: {
              completed: isCompleted,
              error: isFailed || isCancelled,
              active: isActive
            },
            StepIconComponent: TaskStepIconComponent,
            className: classes.stepWrapper
          },
          /* @__PURE__ */ React.createElement("div", { className: classes.labelWrapper }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2" }, step.name), isSkipped ? /* @__PURE__ */ React.createElement(Typography, { variant: "caption" }, "Skipped") : /* @__PURE__ */ React.createElement(StepTimeTicker, { step }))
        )));
      })
    ));
  }
);

const useStyles$4 = makeStyles({
  root: {
    display: "flex",
    flexFlow: "column nowrap"
  },
  contentWrapper: {
    flex: 1,
    position: "relative"
  },
  content: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    "& > *": {
      flex: 1
    }
  },
  codeMirror: {
    height: "100%",
    overflowY: "auto"
  }
});
function FilesContent() {
  const classes = useStyles$4();
  const { selectedResult } = useDryRun();
  const [selectedPath, setSelectedPath] = useState("");
  const selectedFile = selectedResult == null ? void 0 : selectedResult.directoryContents.find(
    (f) => f.path === selectedPath
  );
  useEffect(() => {
    if (selectedResult) {
      const [firstFile] = selectedResult.directoryContents;
      if (firstFile) {
        setSelectedPath(firstFile.path);
      } else {
        setSelectedPath("");
      }
    }
    return void 0;
  }, [selectedResult]);
  if (!selectedResult) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(DryRunResultsSplitView, null, /* @__PURE__ */ React.createElement(
    FileBrowser,
    {
      selected: selectedPath,
      onSelect: setSelectedPath,
      filePaths: selectedResult.directoryContents.map((file) => file.path)
    }
  ), /* @__PURE__ */ React.createElement(
    CodeMirror,
    {
      className: classes.codeMirror,
      theme: "dark",
      height: "100%",
      extensions: [StreamLanguage.define(yaml$1)],
      readOnly: true,
      value: (selectedFile == null ? void 0 : selectedFile.base64Content) ? atob(selectedFile.base64Content) : ""
    }
  ));
}
function LogContent() {
  var _a, _b;
  const { selectedResult } = useDryRun();
  const [currentStepId, setUserSelectedStepId] = useState();
  const steps = useMemo(() => {
    var _a2;
    if (!selectedResult) {
      return [];
    }
    return (_a2 = selectedResult.steps.map((step) => {
      var _a3, _b2;
      const stepLog = selectedResult.log.filter(
        (l) => l.body.stepId === step.id
      );
      return {
        id: step.id,
        name: step.name,
        logString: stepLog.map((l) => l.body.message).join("\n"),
        status: (_b2 = (_a3 = stepLog[stepLog.length - 1]) == null ? void 0 : _a3.body.status) != null ? _b2 : "completed"
      };
    })) != null ? _a2 : [];
  }, [selectedResult]);
  if (!selectedResult) {
    return null;
  }
  const selectedStep = (_a = steps.find((s) => s.id === currentStepId)) != null ? _a : steps[0];
  return /* @__PURE__ */ React.createElement(DryRunResultsSplitView, null, /* @__PURE__ */ React.createElement(
    TaskStatusStepper,
    {
      steps,
      currentStepId: selectedStep.id,
      onUserStepChange: setUserSelectedStepId
    }
  ), /* @__PURE__ */ React.createElement(LogViewer, { text: (_b = selectedStep == null ? void 0 : selectedStep.logString) != null ? _b : "" }));
}
function OutputContent() {
  var _a, _b;
  const classes = useStyles$4();
  const { selectedResult } = useDryRun();
  if (!selectedResult) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(DryRunResultsSplitView, null, /* @__PURE__ */ React.createElement(Box, { pt: 2 }, ((_b = (_a = selectedResult.output) == null ? void 0 : _a.links) == null ? void 0 : _b.length) && /* @__PURE__ */ React.createElement(TaskPageLinks, { output: selectedResult.output })), /* @__PURE__ */ React.createElement(
    CodeMirror,
    {
      className: classes.codeMirror,
      theme: "dark",
      height: "100%",
      extensions: [StreamLanguage.define(yaml$1)],
      readOnly: true,
      value: JSON.stringify(selectedResult.output, null, 2)
    }
  ));
}
function DryRunResultsView() {
  const classes = useStyles$4();
  const [selectedTab, setSelectedTab] = useState(
    "files"
  );
  return /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(Tabs, { value: selectedTab, onChange: (_, v) => setSelectedTab(v) }, /* @__PURE__ */ React.createElement(Tab, { value: "files", label: "Files" }), /* @__PURE__ */ React.createElement(Tab, { value: "log", label: "Log" }), /* @__PURE__ */ React.createElement(Tab, { value: "output", label: "Output" })), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement("div", { className: classes.contentWrapper }, /* @__PURE__ */ React.createElement("div", { className: classes.content }, selectedTab === "files" && /* @__PURE__ */ React.createElement(FilesContent, null), selectedTab === "log" && /* @__PURE__ */ React.createElement(LogContent, null), selectedTab === "output" && /* @__PURE__ */ React.createElement(OutputContent, null))));
}

const useStyles$3 = makeStyles((theme) => ({
  header: {
    height: 48,
    minHeight: 0,
    "&.Mui-expanded": {
      height: 48,
      minHeight: 0
    }
  },
  content: {
    display: "grid",
    background: theme.palette.background.default,
    gridTemplateColumns: "180px auto 1fr",
    gridTemplateRows: "1fr",
    padding: 0,
    height: 400
  }
}));
function DryRunResults() {
  const classes = useStyles$3();
  const dryRun = useDryRun();
  const [expanded, setExpanded] = useState(false);
  const [hidden, setHidden] = useState(true);
  const resultsLength = dryRun.results.length;
  const prevResultsLength = usePrevious(resultsLength);
  useEffect(() => {
    if (prevResultsLength === 0 && resultsLength === 1) {
      setHidden(false);
      setExpanded(true);
    } else if (prevResultsLength === 1 && resultsLength === 0) {
      setExpanded(false);
    }
  }, [prevResultsLength, resultsLength]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Accordion,
    {
      variant: "outlined",
      expanded,
      hidden: resultsLength === 0 && hidden,
      onChange: (_, exp) => setExpanded(exp),
      onTransitionEnd: () => resultsLength === 0 && setHidden(true)
    },
    /* @__PURE__ */ React.createElement(
      AccordionSummary,
      {
        className: classes.header,
        expandIcon: /* @__PURE__ */ React.createElement(ExpandLessIcon, null)
      },
      /* @__PURE__ */ React.createElement(Typography, null, "Dry-run results")
    ),
    /* @__PURE__ */ React.createElement(Divider, { orientation: "horizontal" }),
    /* @__PURE__ */ React.createElement(AccordionDetails, { className: classes.content }, /* @__PURE__ */ React.createElement(DryRunResultsList, null), /* @__PURE__ */ React.createElement(Divider, { orientation: "horizontal" }), /* @__PURE__ */ React.createElement(DryRunResultsView, null))
  ));
}

const useStyles$2 = makeStyles({
  // Reset and fix sizing to make sure scrolling behaves correctly
  root: {
    gridArea: "pageContent",
    display: "grid",
    gridTemplateAreas: `
      "browser editor preview"
      "results results results"
    `,
    gridTemplateColumns: "1fr 3fr 2fr",
    gridTemplateRows: "1fr auto"
  },
  browser: {
    gridArea: "browser",
    overflow: "auto"
  },
  editor: {
    gridArea: "editor",
    overflow: "auto"
  },
  preview: {
    gridArea: "preview",
    overflow: "auto"
  },
  results: {
    gridArea: "results"
  }
});
const TemplateEditor = (props) => {
  const classes = useStyles$2();
  const [errorText, setErrorText] = useState();
  return /* @__PURE__ */ React.createElement(DirectoryEditorProvider, { directory: props.directory }, /* @__PURE__ */ React.createElement(DryRunProvider, null, /* @__PURE__ */ React.createElement("main", { className: classes.root }, /* @__PURE__ */ React.createElement("section", { className: classes.browser }, /* @__PURE__ */ React.createElement(TemplateEditorBrowser, { onClose: props.onClose })), /* @__PURE__ */ React.createElement("section", { className: classes.editor }, /* @__PURE__ */ React.createElement(TemplateEditorTextArea.DirectoryEditor, { errorText })), /* @__PURE__ */ React.createElement("section", { className: classes.preview }, /* @__PURE__ */ React.createElement(
    TemplateEditorForm.DirectoryEditorDryRun,
    {
      setErrorText,
      fieldExtensions: props.fieldExtensions,
      layouts: props.layouts
    }
  )), /* @__PURE__ */ React.createElement("section", { className: classes.results }, /* @__PURE__ */ React.createElement(DryRunResults, null)))));
};

const EXAMPLE_TEMPLATE_PARAMS_YAML = `# Edit the template parameters below to see how they will render in the scaffolder form UI
parameters:
  - title: Fill in some steps
    required:
      - name
    properties:
      name:
        title: Name
        type: string
        description: Unique name of the component
      owner:
        title: Owner
        type: string
        description: Owner of the component
        ui:field: OwnerPicker
        ui:options:
          catalogFilter:
            kind: Group
  - title: Choose a location
    required:
      - repoUrl
    properties:
      repoUrl:
        title: Repository Location
        type: string
        ui:field: RepoUrlPicker
        ui:options:
          allowedHosts:
            - github.com
steps:
  - id: fetch-base
    name: Fetch Base
    action: fetch:template
    input:
      url: ./template
      values:
        name: \${{parameters.name}}
`;
const useStyles$1 = makeStyles((theme) => ({
  root: {
    gridArea: "pageContent",
    display: "grid",
    gridTemplateAreas: `
      "controls controls"
      "textArea preview"
    `,
    gridTemplateRows: "auto 1fr",
    gridTemplateColumns: "1fr 1fr"
  },
  controls: {
    gridArea: "controls",
    display: "flex",
    flexFlow: "row nowrap",
    alignItems: "center",
    margin: theme.spacing(1)
  },
  textArea: {
    gridArea: "textArea"
  },
  preview: {
    gridArea: "preview"
  }
}));
const TemplateFormPreviewer = ({
  defaultPreviewTemplate = EXAMPLE_TEMPLATE_PARAMS_YAML,
  customFieldExtensions = [],
  onClose,
  layouts = []
}) => {
  const classes = useStyles$1();
  const alertApi = useApi(alertApiRef);
  const catalogApi = useApi(catalogApiRef);
  const [selectedTemplate, setSelectedTemplate] = useState("");
  const [errorText, setErrorText] = useState();
  const [templateOptions, setTemplateOptions] = useState([]);
  const [templateYaml, setTemplateYaml] = useState(defaultPreviewTemplate);
  const { loading } = useAsync(
    () => catalogApi.getEntities({
      filter: { kind: "template" },
      fields: [
        "kind",
        "metadata.namespace",
        "metadata.name",
        "metadata.title",
        "spec.parameters",
        "spec.steps",
        "spec.output"
      ]
    }).then(
      ({ items }) => setTemplateOptions(
        items.map((template) => {
          var _a;
          return {
            label: (_a = template.metadata.title) != null ? _a : humanizeEntityRef(template, { defaultKind: "template" }),
            value: template
          };
        })
      )
    ).catch(
      (e) => alertApi.post({
        message: `Error loading exisiting templates: ${e.message}`,
        severity: "error"
      })
    ),
    [catalogApi]
  );
  const handleSelectChange = useCallback(
    // TODO(Rugvip): Afaik this should be Entity, but didn't want to make runtime changes while fixing types
    (selected) => {
      setSelectedTemplate(selected);
      setTemplateYaml(yaml.stringify(selected.spec));
    },
    [setTemplateYaml]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, loading && /* @__PURE__ */ React.createElement(LinearProgress, null), /* @__PURE__ */ React.createElement("main", { className: classes.root }, /* @__PURE__ */ React.createElement("div", { className: classes.controls }, /* @__PURE__ */ React.createElement(FormControl, { variant: "outlined", size: "small", fullWidth: true }, /* @__PURE__ */ React.createElement(InputLabel, { id: "select-template-label" }, "Load Existing Template"), /* @__PURE__ */ React.createElement(
    Select,
    {
      value: selectedTemplate,
      label: "Load Existing Template",
      labelId: "select-template-label",
      onChange: (e) => handleSelectChange(e.target.value)
    },
    templateOptions.map((option, idx) => /* @__PURE__ */ React.createElement(MenuItem, { key: idx, value: option.value }, option.label))
  )), /* @__PURE__ */ React.createElement(IconButton, { size: "medium", onClick: onClose }, /* @__PURE__ */ React.createElement(CloseIcon, null))), /* @__PURE__ */ React.createElement("div", { className: classes.textArea }, /* @__PURE__ */ React.createElement(
    TemplateEditorTextArea,
    {
      content: templateYaml,
      onUpdate: setTemplateYaml,
      errorText
    }
  )), /* @__PURE__ */ React.createElement("div", { className: classes.preview }, /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      content: templateYaml,
      contentIsSpec: true,
      fieldExtensions: customFieldExtensions,
      setErrorText,
      layouts
    }
  ))));
};

const useStyles = makeStyles((theme) => ({
  introText: {
    textAlign: "center",
    marginTop: theme.spacing(2)
  },
  card: {
    position: "relative",
    maxWidth: 340,
    marginTop: theme.spacing(4),
    margin: theme.spacing(0, 2)
  },
  infoIcon: {
    position: "absolute",
    top: theme.spacing(1),
    right: theme.spacing(1)
  }
}));
function TemplateEditorIntro(props) {
  const classes = useStyles();
  const supportsLoad = WebFileSystemAccess.isSupported();
  const cardLoadLocal = /* @__PURE__ */ React.createElement(Card, { className: classes.card, elevation: 4 }, /* @__PURE__ */ React.createElement(
    CardActionArea,
    {
      disabled: !supportsLoad,
      onClick: () => {
        var _a;
        return (_a = props.onSelect) == null ? void 0 : _a.call(props, "local");
      }
    },
    /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "h4",
        component: "h3",
        gutterBottom: true,
        color: supportsLoad ? void 0 : "textSecondary",
        style: { display: "flex", flexFlow: "row nowrap" }
      },
      "Load Template Directory"
    ), /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "body1",
        color: supportsLoad ? void 0 : "textSecondary"
      },
      "Load a local template directory, allowing you to both edit and try executing your own template."
    ))
  ), !supportsLoad && /* @__PURE__ */ React.createElement("div", { className: classes.infoIcon }, /* @__PURE__ */ React.createElement(
    Tooltip,
    {
      placement: "top",
      title: "Only supported in some Chromium-based browsers"
    },
    /* @__PURE__ */ React.createElement(InfoOutlinedIcon, null)
  )));
  const cardFormEditor = /* @__PURE__ */ React.createElement(Card, { className: classes.card, elevation: 4 }, /* @__PURE__ */ React.createElement(CardActionArea, { onClick: () => {
    var _a;
    return (_a = props.onSelect) == null ? void 0 : _a.call(props, "form");
  } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", component: "h3", gutterBottom: true }, "Edit Template Form"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, "Preview and edit a template form, either using a sample template or by loading a template from the catalog."))));
  const cardFieldExplorer = /* @__PURE__ */ React.createElement(Card, { className: classes.card, elevation: 4 }, /* @__PURE__ */ React.createElement(CardActionArea, { onClick: () => {
    var _a;
    return (_a = props.onSelect) == null ? void 0 : _a.call(props, "field-explorer");
  } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", component: "h3", gutterBottom: true }, "Custom Field Explorer"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, "View and play around with available installed custom field extensions."))));
  return /* @__PURE__ */ React.createElement("div", { style: props.style }, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", component: "h2", className: classes.introText }, "Get started by choosing one of the options below"), /* @__PURE__ */ React.createElement(
    "div",
    {
      style: {
        display: "flex",
        flexFlow: "row wrap",
        alignItems: "flex-start",
        justifyContent: "center",
        alignContent: "flex-start"
      }
    },
    supportsLoad && cardLoadLocal,
    cardFormEditor,
    !supportsLoad && cardLoadLocal,
    cardFieldExplorer
  ));
}

function TemplateEditorPage(props) {
  const [selection, setSelection] = useState();
  const navigate = useNavigate();
  const actionsLink = useRouteRef(actionsRouteRef);
  const tasksLink = useRouteRef(scaffolderListTaskRouteRef);
  const createLink = useRouteRef(rootRouteRef);
  const scaffolderPageContextMenuProps = {
    onEditorClicked: void 0,
    onActionsClicked: () => navigate(actionsLink()),
    onTasksClicked: () => navigate(tasksLink()),
    onCreateClicked: () => navigate(createLink())
  };
  let content = null;
  if ((selection == null ? void 0 : selection.type) === "local") {
    content = /* @__PURE__ */ React.createElement(
      TemplateEditor,
      {
        directory: selection.directory,
        fieldExtensions: props.customFieldExtensions,
        onClose: () => setSelection(void 0),
        layouts: props.layouts
      }
    );
  } else if ((selection == null ? void 0 : selection.type) === "form") {
    content = /* @__PURE__ */ React.createElement(
      TemplateFormPreviewer,
      {
        defaultPreviewTemplate: props.defaultPreviewTemplate,
        customFieldExtensions: props.customFieldExtensions,
        onClose: () => setSelection(void 0),
        layouts: props.layouts
      }
    );
  } else if ((selection == null ? void 0 : selection.type) === "field-explorer") {
    content = /* @__PURE__ */ React.createElement(
      CustomFieldExplorer,
      {
        customFieldExtensions: props.customFieldExtensions,
        onClose: () => setSelection(void 0)
      }
    );
  } else {
    content = /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(
      TemplateEditorIntro,
      {
        onSelect: (option) => {
          if (option === "local") {
            WebFileSystemAccess.requestDirectoryAccess().then((directory) => setSelection({ type: "local", directory })).catch(() => {
            });
          } else if (option === "form") {
            setSelection({ type: "form" });
          } else if (option === "field-explorer") {
            setSelection({ type: "field-explorer" });
          }
        }
      }
    ));
  }
  return /* @__PURE__ */ React.createElement(Page, { themeId: "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      title: "Template Editor",
      subtitle: "Edit, preview, and try out templates and template forms"
    },
    /* @__PURE__ */ React.createElement(ScaffolderPageContextMenu, { ...scaffolderPageContextMenuProps })
  ), content);
}

const Router = (props) => {
  const {
    components: {
      TemplateCardComponent,
      TaskPageComponent = OngoingTask,
      ReviewStepComponent,
      EXPERIMENTAL_TemplateOutputsComponent: TemplateOutputsComponent,
      EXPERIMENTAL_TemplateListPageComponent: TemplateListPageComponent = TemplateListPage,
      EXPERIMENTAL_TemplateWizardPageComponent: TemplateWizardPageComponent = TemplateWizardPage
    } = {}
  } = props;
  const outlet = useOutlet() || props.children;
  const customFieldExtensions = useCustomFieldExtensions(outlet);
  const fieldExtensions = [
    ...customFieldExtensions,
    ...DEFAULT_SCAFFOLDER_FIELD_EXTENSIONS.filter(
      ({ name }) => !customFieldExtensions.some(
        (customFieldExtension) => customFieldExtension.name === name
      )
    )
  ];
  const customLayouts = useCustomLayouts(outlet);
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(
    Route,
    {
      path: "/",
      element: /* @__PURE__ */ React.createElement(
        TemplateListPageComponent,
        {
          TemplateCardComponent,
          contextMenu: props.contextMenu,
          groups: props.groups,
          templateFilter: props.templateFilter,
          headerOptions: props.headerOptions
        }
      )
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: selectedTemplateRouteRef.path,
      element: /* @__PURE__ */ React.createElement(SecretsContextProvider, null, /* @__PURE__ */ React.createElement(
        TemplateWizardPageComponent,
        {
          headerOptions: props.headerOptions,
          customFieldExtensions: fieldExtensions,
          layouts: customLayouts,
          components: { ReviewStepComponent },
          formProps: props.formProps
        }
      ))
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: scaffolderTaskRouteRef.path,
      element: /* @__PURE__ */ React.createElement(
        TaskPageComponent,
        {
          TemplateOutputsComponent
        }
      )
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: editRouteRef.path,
      element: /* @__PURE__ */ React.createElement(SecretsContextProvider, null, /* @__PURE__ */ React.createElement(
        TemplateEditorPage,
        {
          customFieldExtensions: fieldExtensions,
          layouts: customLayouts
        }
      ))
    }
  ), /* @__PURE__ */ React.createElement(Route, { path: actionsRouteRef.path, element: /* @__PURE__ */ React.createElement(ActionsPage, null) }), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: scaffolderListTaskRouteRef.path,
      element: /* @__PURE__ */ React.createElement(ListTasksPage, null)
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: "*",
      element: /* @__PURE__ */ React.createElement(ErrorPage, { status: "404", statusMessage: "Page not found" })
    }
  ));
};

export { Router };
//# sourceMappingURL=index-UcPid-q1.esm.js.map
