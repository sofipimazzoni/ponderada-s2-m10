import { convertLegacyRouteRef, compatWrapper, convertLegacyRouteRefs } from '@backstage/core-compat-api';
import { createApiExtension, createPageExtension, createExtensionInput, coreExtensionData, createExtension, ExtensionBoundary, createSchemaFromZod, createNavItemExtension, createPlugin } from '@backstage/frontend-plugin-api';
import { catalogApiRef, starredEntitiesApiRef, entityPresentationApiRef, entityRouteRef, AsyncEntityProvider } from '@backstage/plugin-catalog-react';
import { D as DefaultStarredEntitiesApi, b as DefaultEntityPresentationApi, r as rootRouteRef, v as viewTechDocRouteRef, c as createComponentRouteRef, a as createFromTemplateRouteRef, u as unregisterRedirectRouteRef } from './routes-D5H5grpG.esm.js';
import { createApiFactory, discoveryApiRef, fetchApiRef, storageApiRef } from '@backstage/core-plugin-api';
import { CatalogClient } from '@backstage/catalog-client';
import React, { useMemo, lazy } from 'react';
import { catalogExtensionData, createEntityCardExtension, createEntityContentExtension } from '@backstage/plugin-catalog-react/alpha';
import { u as useEntityFromUrl } from './useEntityFromUrl-ajYEHLdg.esm.js';
import Grid from '@material-ui/core/Grid';
import { InputError } from '@backstage/errors';
import HomeIcon from '@material-ui/icons/Home';
import { createSearchResultListItemExtension } from '@backstage/plugin-search-react/alpha';

const catalogApi = createApiExtension({
  factory: createApiFactory({
    api: catalogApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      fetchApi: fetchApiRef
    },
    factory: ({ discoveryApi, fetchApi }) => new CatalogClient({ discoveryApi, fetchApi })
  })
});
const catalogStarredEntitiesApi = createApiExtension({
  factory: createApiFactory({
    api: starredEntitiesApiRef,
    deps: { storageApi: storageApiRef },
    factory: ({ storageApi }) => new DefaultStarredEntitiesApi({ storageApi })
  })
});
const entityPresentationApi = createApiExtension({
  factory: createApiFactory({
    api: entityPresentationApiRef,
    deps: { catalogApiImp: catalogApiRef },
    factory: ({ catalogApiImp }) => DefaultEntityPresentationApi.create({ catalogApi: catalogApiImp })
  })
});
var apis = [catalogApi, catalogStarredEntitiesApi, entityPresentationApi];

function createKindMatcher(parameters, _onParseError) {
  const items = parameters.map((p) => p.toLocaleLowerCase("en-US"));
  return (entity) => items.includes(entity.kind.toLocaleLowerCase("en-US"));
}

function createTypeMatcher(parameters, _onParseError) {
  const items = parameters.map((p) => p.toLocaleLowerCase("en-US"));
  return (entity) => {
    var _a;
    const value = (_a = entity.spec) == null ? void 0 : _a.type;
    return typeof value === "string" && items.includes(value.toLocaleLowerCase("en-US"));
  };
}

const allowedMatchers$1 = {
  orphan: (entity) => {
    var _a;
    return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a["backstage.io/orphan"]);
  }
};
function createIsMatcher(parameters, onParseError) {
  const matchers = parameters.flatMap((parameter) => {
    const matcher = allowedMatchers$1[parameter.toLocaleLowerCase("en-US")];
    if (!matcher) {
      const known = Object.keys(allowedMatchers$1).map((m) => `'${m}'`);
      onParseError(
        new InputError(
          `'${parameter}' is not a valid parameter for 'is' filter expressions, expected one of ${known}`
        )
      );
      return [];
    }
    return [matcher];
  });
  return (entity) => matchers.length ? matchers.some((matcher) => matcher(entity)) : true;
}

const allowedMatchers = {
  labels: (entity) => {
    var _a;
    return Object.keys((_a = entity.metadata.labels) != null ? _a : {}).length > 0;
  },
  links: (entity) => {
    var _a;
    return ((_a = entity.metadata.links) != null ? _a : []).length > 0;
  }
};
function createHasMatcher(parameters, onParseError) {
  const matchers = parameters.flatMap((parameter) => {
    const matcher = allowedMatchers[parameter.toLocaleLowerCase("en-US")];
    if (!matcher) {
      const known = Object.keys(allowedMatchers).map((m) => `'${m}'`);
      onParseError(
        new InputError(
          `'${parameter}' is not a valid parameter for 'has' filter expressions, expected one of ${known}`
        )
      );
      return [];
    }
    return [matcher];
  });
  return (entity) => matchers.length ? matchers.some((matcher) => matcher(entity)) : true;
}

const rootMatcherFactories = {
  kind: createKindMatcher,
  type: createTypeMatcher,
  is: createIsMatcher,
  has: createHasMatcher
};
function parseFilterExpression(expression) {
  const expressionParseErrors = [];
  const parts = splitFilterExpression(
    expression,
    (e) => expressionParseErrors.push(e)
  );
  const matchers = parts.flatMap((part) => {
    const factory = rootMatcherFactories[part.key];
    if (!factory) {
      const known = Object.keys(rootMatcherFactories).map((m) => `'${m}'`);
      expressionParseErrors.push(
        new InputError(
          `'${part.key}' is not a valid filter expression key, expected one of ${known}`
        )
      );
      return [];
    }
    const matcher = factory(
      part.parameters,
      (e) => expressionParseErrors.push(e)
    );
    return [matcher];
  });
  const filterFn = (entity) => matchers.every((matcher) => {
    try {
      return matcher(entity);
    } catch {
      return false;
    }
  });
  return {
    filterFn,
    expressionParseErrors
  };
}
function splitFilterExpression(expression, onParseError) {
  const words = expression.split(" ").map((w) => w.trim()).filter(Boolean);
  const result = new Array();
  for (const word of words) {
    const match = word.match(/^([^:]+):(.+)$/);
    if (!match) {
      onParseError(
        new InputError(
          `'${word}' is not a valid filter expression, expected 'key:parameter' form`
        )
      );
      continue;
    }
    const key = match[1];
    const parameters = match[2].split(",").filter(Boolean);
    result.push({ key, parameters });
  }
  return result;
}

const seenParseErrorExpressionStrings = /* @__PURE__ */ new Set();
const seenDuplicateExpressionStrings = /* @__PURE__ */ new Set();
function buildFilterFn(filterFunction, filterExpression) {
  if (filterFunction && filterExpression && !seenDuplicateExpressionStrings.has(filterExpression)) {
    console.warn(
      `Duplicate entity filter methods found, both '${filterExpression}' as well as a callback function, which is not permitted - using the callback`
    );
    seenDuplicateExpressionStrings.add(filterExpression);
  }
  const filter = filterFunction || filterExpression;
  if (!filter) {
    return () => true;
  } else if (typeof filter === "function") {
    return (subject) => filter(subject);
  }
  const result = parseFilterExpression(filter);
  if (result.expressionParseErrors.length && !seenParseErrorExpressionStrings.has(filter)) {
    console.warn(
      `Error(s) in entity filter expression '${filter}'`,
      result.expressionParseErrors
    );
    seenParseErrorExpressionStrings.add(filter);
  }
  return result.filterFn;
}
function FilterWrapper(props) {
  const { entity, element, filterFunction, filterExpression } = props;
  const filterFn = useMemo(
    () => buildFilterFn(filterFunction, filterExpression),
    [filterFunction, filterExpression]
  );
  return filterFn(entity) ? /* @__PURE__ */ React.createElement(Grid, { item: true, md: 6, xs: 12 }, element) : null;
}

const catalogPage = createPageExtension({
  defaultPath: "/catalog",
  routeRef: convertLegacyRouteRef(rootRouteRef),
  inputs: {
    filters: createExtensionInput({
      element: coreExtensionData.reactElement
    })
  },
  loader: async ({ inputs }) => {
    const { BaseCatalogPage } = await import('./index-B9rsO45f.esm.js');
    const filters = inputs.filters.map((filter) => filter.output.element);
    return compatWrapper(/* @__PURE__ */ React.createElement(BaseCatalogPage, { filters: /* @__PURE__ */ React.createElement(React.Fragment, null, filters) }));
  }
});
const catalogEntityPage = createPageExtension({
  name: "entity",
  defaultPath: "/catalog/:namespace/:kind/:name",
  routeRef: convertLegacyRouteRef(entityRouteRef),
  inputs: {
    contents: createExtensionInput({
      element: coreExtensionData.reactElement,
      path: coreExtensionData.routePath,
      routeRef: coreExtensionData.routeRef.optional(),
      title: catalogExtensionData.entityContentTitle,
      filterFunction: catalogExtensionData.entityFilterFunction.optional(),
      filterExpression: catalogExtensionData.entityFilterExpression.optional()
    })
  },
  loader: async ({ inputs }) => {
    const { EntityLayout } = await import('./index-DghFYtyU.esm.js');
    const Component = () => {
      return /* @__PURE__ */ React.createElement(AsyncEntityProvider, { ...useEntityFromUrl() }, /* @__PURE__ */ React.createElement(EntityLayout, null, inputs.contents.map(({ output }) => /* @__PURE__ */ React.createElement(
        EntityLayout.Route,
        {
          key: output.path,
          path: output.path,
          title: output.title,
          if: buildFilterFn(
            output.filterFunction,
            output.filterExpression
          )
        },
        output.element
      ))));
    };
    return compatWrapper(/* @__PURE__ */ React.createElement(Component, null));
  }
});
var pages = [catalogPage, catalogEntityPage];

function createCatalogFilterExtension(options) {
  var _a;
  return createExtension({
    kind: "catalog-filter",
    namespace: options.namespace,
    name: options.name,
    attachTo: { id: "page:catalog", input: "filters" },
    inputs: (_a = options.inputs) != null ? _a : {},
    configSchema: options.configSchema,
    output: {
      element: coreExtensionData.reactElement
    },
    factory({ config, node }) {
      const ExtensionComponent = lazy(
        () => options.loader({ config }).then((element) => ({ default: () => element }))
      );
      return {
        element: /* @__PURE__ */ React.createElement(ExtensionBoundary, { node }, /* @__PURE__ */ React.createElement(ExtensionComponent, null))
      };
    }
  });
}

const catalogTagCatalogFilter = createCatalogFilterExtension({
  name: "tag",
  loader: async () => {
    const { EntityTagPicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(EntityTagPicker, null);
  }
});
const catalogKindCatalogFilter = createCatalogFilterExtension({
  name: "kind",
  configSchema: createSchemaFromZod(
    (z) => z.object({
      initialFilter: z.string().default("component")
    })
  ),
  loader: async ({ config }) => {
    const { EntityKindPicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(EntityKindPicker, { initialFilter: config.initialFilter });
  }
});
const catalogTypeCatalogFilter = createCatalogFilterExtension({
  name: "type",
  loader: async () => {
    const { EntityTypePicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(EntityTypePicker, null);
  }
});
const catalogModeCatalogFilter = createCatalogFilterExtension({
  name: "mode",
  configSchema: createSchemaFromZod(
    (z) => z.object({
      mode: z.enum(["owners-only", "all"]).optional()
    })
  ),
  loader: async ({ config }) => {
    const { EntityOwnerPicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(EntityOwnerPicker, { mode: config.mode });
  }
});
const catalogNamespaceCatalogFilter = createCatalogFilterExtension({
  name: "namespace",
  loader: async () => {
    const { EntityNamespacePicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(EntityNamespacePicker, null);
  }
});
const catalogLifecycleCatalogFilter = createCatalogFilterExtension({
  name: "lifecycle",
  loader: async () => {
    const { EntityLifecyclePicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(EntityLifecyclePicker, null);
  }
});
const catalogProcessingStatusCatalogFilter = createCatalogFilterExtension({
  name: "processing-status",
  loader: async () => {
    const { EntityProcessingStatusPicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(EntityProcessingStatusPicker, null);
  }
});
const catalogListCatalogFilter = createCatalogFilterExtension({
  name: "list",
  configSchema: createSchemaFromZod(
    (z) => z.object({
      initialFilter: z.enum(["owned", "starred", "all"]).default("owned")
    })
  ),
  loader: async ({ config }) => {
    const { UserListPicker } = await import('@backstage/plugin-catalog-react');
    return /* @__PURE__ */ React.createElement(UserListPicker, { initialFilter: config.initialFilter });
  }
});
var filters = [
  catalogTagCatalogFilter,
  catalogKindCatalogFilter,
  catalogTypeCatalogFilter,
  catalogModeCatalogFilter,
  catalogNamespaceCatalogFilter,
  catalogLifecycleCatalogFilter,
  catalogProcessingStatusCatalogFilter,
  catalogListCatalogFilter
];

const catalogNavItem = createNavItemExtension({
  routeRef: convertLegacyRouteRef(rootRouteRef),
  title: "Catalog",
  icon: HomeIcon
});
var navItems = [catalogNavItem];

const catalogAboutEntityCard = createEntityCardExtension({
  name: "about",
  loader: async () => import('./index-CTye7k-V.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.AboutCard, { variant: "gridItem" }))
  )
});
const catalogLinksEntityCard = createEntityCardExtension({
  name: "links",
  filter: "has:links",
  loader: async () => import('./index-G-F7Xm_y.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.EntityLinksCard, { variant: "gridItem" }))
  )
});
const catalogLabelsEntityCard = createEntityCardExtension({
  name: "labels",
  filter: "has:labels",
  loader: async () => import('./index-B-CCESaQ.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.EntityLabelsCard, { variant: "gridItem" }))
  )
});
const catalogDependsOnComponentsEntityCard = createEntityCardExtension({
  name: "depends-on-components",
  loader: async () => import('./index-IXphZwiH.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.DependsOnComponentsCard, { variant: "gridItem" }))
  )
});
const catalogDependsOnResourcesEntityCard = createEntityCardExtension({
  name: "depends-on-resources",
  loader: async () => import('./index-1Ncw0nQK.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.DependsOnResourcesCard, { variant: "gridItem" }))
  )
});
const catalogHasComponentsEntityCard = createEntityCardExtension({
  name: "has-components",
  loader: async () => import('./index-Cj8OffZ7.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.HasComponentsCard, { variant: "gridItem" }))
  )
});
const catalogHasResourcesEntityCard = createEntityCardExtension({
  name: "has-resources",
  loader: async () => import('./index-BfN39k1W.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.HasResourcesCard, { variant: "gridItem" }))
  )
});
const catalogHasSubcomponentsEntityCard = createEntityCardExtension({
  name: "has-subcomponents",
  loader: async () => import('./index-BiuwwYop.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.HasSubcomponentsCard, { variant: "gridItem" }))
  )
});
const catalogHasSystemsEntityCard = createEntityCardExtension({
  name: "has-systems",
  loader: async () => import('./index-D5HvChUh.esm.js').then(
    (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.HasSystemsCard, { variant: "gridItem" }))
  )
});
var entityCards = [
  catalogAboutEntityCard,
  catalogLinksEntityCard,
  catalogLabelsEntityCard,
  catalogDependsOnComponentsEntityCard,
  catalogDependsOnResourcesEntityCard,
  catalogHasComponentsEntityCard,
  catalogHasResourcesEntityCard,
  catalogHasSubcomponentsEntityCard,
  catalogHasSystemsEntityCard
];

const catalogOverviewEntityContent = createEntityContentExtension({
  name: "overview",
  defaultPath: "/",
  defaultTitle: "Overview",
  disabled: false,
  inputs: {
    cards: createExtensionInput({
      element: coreExtensionData.reactElement,
      filterFunction: catalogExtensionData.entityFilterFunction.optional(),
      filterExpression: catalogExtensionData.entityFilterExpression.optional()
    })
  },
  loader: async ({ inputs }) => import('./EntityOverviewPage-BrKzcB2g.esm.js').then((m) => /* @__PURE__ */ React.createElement(m.EntityOverviewPage, { cards: inputs.cards.map((c) => c.output) }))
});
var entityContents = [catalogOverviewEntityContent];

const catalogSearchResultListItem = createSearchResultListItemExtension({
  predicate: (result) => result.type === "software-catalog",
  component: () => import('./index-Deu-nY7x.esm.js').then(
    (m) => m.CatalogSearchResultListItem
  )
});
var searchResultItems = [catalogSearchResultListItem];

var plugin = createPlugin({
  id: "catalog",
  routes: convertLegacyRouteRefs({
    catalogIndex: rootRouteRef,
    catalogEntity: entityRouteRef
  }),
  externalRoutes: convertLegacyRouteRefs({
    viewTechDoc: viewTechDocRouteRef,
    createComponent: createComponentRouteRef,
    createFromTemplate: createFromTemplateRouteRef,
    unregisterRedirect: unregisterRedirectRouteRef
  }),
  extensions: [
    ...apis,
    ...pages,
    ...filters,
    ...navItems,
    ...entityCards,
    ...entityContents,
    ...searchResultItems
  ]
});

export { FilterWrapper as F, createCatalogFilterExtension as c, plugin as p };
//# sourceMappingURL=alpha-DpxXch-c.esm.js.map
