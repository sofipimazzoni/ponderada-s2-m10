import { RELATION_PART_OF, RELATION_OWNED_BY, stringifyEntityRef, ANNOTATION_VIEW_URL, ANNOTATION_EDIT_URL } from '@backstage/catalog-model';
import { OverflowTooltip, Table, WarningPanel, CodeSnippet } from '@backstage/core-components';
import { EntityRefLink, EntityRefLinks, humanizeEntityRef, EntitySearchBar, useStarredEntities, useEntityList, getEntityRelations } from '@backstage/plugin-catalog-react';
import Typography from '@material-ui/core/Typography';
import { makeStyles, withStyles } from '@material-ui/core/styles';
import { visuallyHidden } from '@mui/utils';
import EditIcon from '@material-ui/icons/Edit';
import OpenInNew from '@material-ui/icons/OpenInNew';
import Star from '@material-ui/icons/Star';
import StarBorder from '@material-ui/icons/StarBorder';
import { capitalize } from 'lodash';
import pluralize from 'pluralize';
import React, { useMemo } from 'react';
import Chip from '@material-ui/core/Chip';
import Toolbar from '@material-ui/core/Toolbar';

const columnFactories = Object.freeze({
  createNameColumn(options) {
    function formatContent(entity) {
      var _a;
      return ((_a = entity.metadata) == null ? void 0 : _a.title) || humanizeEntityRef(entity, {
        defaultKind: options == null ? void 0 : options.defaultKind
      });
    }
    return {
      title: "Name",
      field: "resolved.entityRef",
      highlight: true,
      customSort({ entity: entity1 }, { entity: entity2 }) {
        return formatContent(entity1).localeCompare(formatContent(entity2));
      },
      render: ({ entity }) => /* @__PURE__ */ React.createElement(
        EntityRefLink,
        {
          entityRef: entity,
          defaultKind: (options == null ? void 0 : options.defaultKind) || "Component"
        }
      )
    };
  },
  createSystemColumn() {
    return {
      title: "System",
      field: "resolved.partOfSystemRelationTitle",
      render: ({ resolved }) => /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: resolved.partOfSystemRelations,
          defaultKind: "system"
        }
      )
    };
  },
  createOwnerColumn() {
    return {
      title: "Owner",
      field: "resolved.ownedByRelationsTitle",
      render: ({ resolved }) => /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: resolved.ownedByRelations,
          defaultKind: "group"
        }
      )
    };
  },
  createSpecTargetsColumn() {
    return {
      title: "Targets",
      field: "entity.spec.targets",
      customFilterAndSearch: (query, row) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        let targets = [];
        if (((_b = (_a = row.entity) == null ? void 0 : _a.spec) == null ? void 0 : _b.targets) && Array.isArray((_d = (_c = row.entity) == null ? void 0 : _c.spec) == null ? void 0 : _d.targets)) {
          targets = (_f = (_e = row.entity) == null ? void 0 : _e.spec) == null ? void 0 : _f.targets;
        } else if ((_h = (_g = row.entity) == null ? void 0 : _g.spec) == null ? void 0 : _h.target) {
          targets = [(_j = (_i = row.entity) == null ? void 0 : _i.spec) == null ? void 0 : _j.target];
        }
        return targets.join(", ").toLocaleUpperCase("en-US").includes(query.toLocaleUpperCase("en-US"));
      },
      render: ({ entity }) => {
        var _a, _b;
        return /* @__PURE__ */ React.createElement(React.Fragment, null, (((_a = entity == null ? void 0 : entity.spec) == null ? void 0 : _a.targets) || ((_b = entity == null ? void 0 : entity.spec) == null ? void 0 : _b.target)) && /* @__PURE__ */ React.createElement(
          OverflowTooltip,
          {
            text: (entity.spec.targets || [entity.spec.target]).join(", "),
            placement: "bottom-start"
          }
        ));
      }
    };
  },
  createSpecTypeColumn(options = { hidden: false }) {
    return {
      title: "Type",
      field: "entity.spec.type",
      hidden: options.hidden,
      width: "auto"
    };
  },
  createSpecLifecycleColumn() {
    return {
      title: "Lifecycle",
      field: "entity.spec.lifecycle"
    };
  },
  createMetadataDescriptionColumn() {
    return {
      title: "Description",
      field: "entity.metadata.description",
      render: ({ entity }) => /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: entity.metadata.description,
          placement: "bottom-start"
        }
      ),
      width: "auto"
    };
  },
  createTagsColumn() {
    return {
      title: "Tags",
      field: "entity.metadata.tags",
      cellStyle: {
        padding: "0px 16px 0px 20px"
      },
      render: ({ entity }) => /* @__PURE__ */ React.createElement(React.Fragment, null, entity.metadata.tags && entity.metadata.tags.map((t) => /* @__PURE__ */ React.createElement(
        Chip,
        {
          key: t,
          label: t,
          size: "small",
          variant: "outlined",
          style: { marginBottom: "0px" }
        }
      ))),
      width: "auto"
    };
  },
  createTitleColumn(options) {
    return {
      title: "Title",
      field: "entity.metadata.title",
      hidden: options == null ? void 0 : options.hidden,
      searchable: true
    };
  },
  createLabelColumn(key, options) {
    function formatContent(keyLabel, entity) {
      var _a;
      const labels = (_a = entity.metadata) == null ? void 0 : _a.labels;
      return labels && labels[keyLabel] || "";
    }
    return {
      title: (options == null ? void 0 : options.title) || "Label",
      field: "entity.metadata.labels",
      cellStyle: {
        padding: "0px 16px 0px 20px"
      },
      customSort({ entity: entity1 }, { entity: entity2 }) {
        return formatContent(key, entity1).localeCompare(
          formatContent(key, entity2)
        );
      },
      render: ({ entity }) => {
        var _a;
        const labels = (_a = entity.metadata) == null ? void 0 : _a.labels;
        const specifiedLabelValue = labels && labels[key] || (options == null ? void 0 : options.defaultValue);
        return /* @__PURE__ */ React.createElement(React.Fragment, null, specifiedLabelValue && /* @__PURE__ */ React.createElement(
          Chip,
          {
            key: specifiedLabelValue,
            label: specifiedLabelValue,
            size: "small",
            variant: "outlined"
          }
        ));
      },
      width: "auto"
    };
  },
  createNamespaceColumn() {
    return {
      title: "Namespace",
      field: "entity.metadata.namespace",
      width: "auto"
    };
  }
});

const useToolbarStyles = makeStyles(
  (theme) => ({
    root: {
      paddingTop: theme.spacing(1.25),
      paddingLeft: theme.spacing(2.5),
      paddingBottom: theme.spacing(0.75),
      display: "flex",
      justifyContent: "space-between"
    },
    text: {
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis"
    }
  }),
  { name: "BackstageTableToolbar" }
);
function CatalogTableToolbar(props) {
  const styles = useToolbarStyles();
  return /* @__PURE__ */ React.createElement(Toolbar, { className: styles.root }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", className: styles.text }, props.title), /* @__PURE__ */ React.createElement(EntitySearchBar, null));
}

function PaginatedCatalogTable(props) {
  const { columns, data, next, prev, title, isLoading, options } = props;
  return /* @__PURE__ */ React.createElement(
    Table,
    {
      title: isLoading ? "" : title,
      columns,
      data,
      options: {
        ...options,
        // These settings are configured to force server side pagination
        paginationPosition: "both",
        pageSizeOptions: [],
        showFirstLastPageButtons: false,
        pageSize: Number.MAX_SAFE_INTEGER,
        emptyRowsWhenPaging: false
      },
      onPageChange: (page) => {
        if (page > 0) {
          next == null ? void 0 : next();
        } else {
          prev == null ? void 0 : prev();
        }
      },
      components: {
        Toolbar: CatalogTableToolbar
      },
      page: prev ? 1 : 0,
      totalCount: next ? Number.MAX_VALUE : Number.MAX_SAFE_INTEGER,
      localization: { pagination: { labelDisplayedRows: "" } }
    }
  );
}

const defaultCatalogTableColumnsFunc = ({
  filters,
  entities
}) => {
  var _a;
  const showTypeColumn = filters.type === void 0;
  return [
    columnFactories.createTitleColumn({ hidden: true }),
    columnFactories.createNameColumn({ defaultKind: (_a = filters.kind) == null ? void 0 : _a.value }),
    ...createEntitySpecificColumns(),
    columnFactories.createMetadataDescriptionColumn(),
    columnFactories.createTagsColumn()
  ];
  function createEntitySpecificColumns() {
    var _a2;
    const baseColumns = [
      columnFactories.createSystemColumn(),
      columnFactories.createOwnerColumn(),
      columnFactories.createSpecTypeColumn({ hidden: !showTypeColumn }),
      columnFactories.createSpecLifecycleColumn()
    ];
    switch ((_a2 = filters.kind) == null ? void 0 : _a2.value) {
      case "user":
        return [];
      case "domain":
      case "system":
        return [columnFactories.createOwnerColumn()];
      case "group":
      case "template":
        return [
          columnFactories.createSpecTypeColumn({ hidden: !showTypeColumn })
        ];
      case "location":
        return [
          columnFactories.createSpecTypeColumn({ hidden: !showTypeColumn }),
          columnFactories.createSpecTargetsColumn()
        ];
      default:
        return entities.every((entity) => entity.metadata.namespace === "default") ? baseColumns : [...baseColumns, columnFactories.createNamespaceColumn()];
    }
  }
};

const YellowStar = withStyles({
  root: {
    color: "#f3ba37"
  }
})(Star);
const refCompare = (a, b) => {
  const toRef = (entity) => entity.metadata.title || humanizeEntityRef(entity, {
    defaultKind: "Component"
  });
  return toRef(a).localeCompare(toRef(b));
};
const CatalogTable = (props) => {
  var _a, _b, _c, _d;
  const {
    columns = defaultCatalogTableColumnsFunc,
    tableOptions,
    subtitle,
    emptyContent
  } = props;
  const { isStarredEntity, toggleStarredEntity } = useStarredEntities();
  const entityListContext = useEntityList();
  const { loading, error, entities, filters, pageInfo, totalItems } = entityListContext;
  const enablePagination = !!pageInfo;
  const tableColumns = useMemo(
    () => typeof columns === "function" ? columns(entityListContext) : columns,
    [columns, entityListContext]
  );
  if (error) {
    return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(
      WarningPanel,
      {
        severity: "error",
        title: "Could not fetch catalog entities."
      },
      /* @__PURE__ */ React.createElement(CodeSnippet, { language: "text", text: error.toString() })
    ));
  }
  const defaultActions = [
    ({ entity }) => {
      var _a2;
      const url = (_a2 = entity.metadata.annotations) == null ? void 0 : _a2[ANNOTATION_VIEW_URL];
      const title2 = "View";
      return {
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { style: visuallyHidden }, title2), /* @__PURE__ */ React.createElement(OpenInNew, { fontSize: "small" })),
        tooltip: title2,
        disabled: !url,
        onClick: () => {
          if (!url)
            return;
          window.open(url, "_blank");
        }
      };
    },
    ({ entity }) => {
      var _a2;
      const url = (_a2 = entity.metadata.annotations) == null ? void 0 : _a2[ANNOTATION_EDIT_URL];
      const title2 = "Edit";
      return {
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { style: visuallyHidden }, title2), /* @__PURE__ */ React.createElement(EditIcon, { fontSize: "small" })),
        tooltip: title2,
        disabled: !url,
        onClick: () => {
          if (!url)
            return;
          window.open(url, "_blank");
        }
      };
    },
    ({ entity }) => {
      const isStarred = isStarredEntity(entity);
      const title2 = isStarred ? "Remove from favorites" : "Add to favorites";
      return {
        cellStyle: { paddingLeft: "1em" },
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { style: visuallyHidden }, title2), isStarred ? /* @__PURE__ */ React.createElement(YellowStar, null) : /* @__PURE__ */ React.createElement(StarBorder, null)),
        tooltip: title2,
        onClick: () => toggleStarredEntity(entity)
      };
    }
  ];
  const currentKind = ((_a = filters.kind) == null ? void 0 : _a.value) || "";
  const currentType = ((_b = filters.type) == null ? void 0 : _b.value) || "";
  const titlePreamble = capitalize((_d = (_c = filters.user) == null ? void 0 : _c.value) != null ? _d : "all");
  const titleDisplay = [titlePreamble, currentType, pluralize(currentKind)].filter((s) => s).join(" ");
  const title = `${titleDisplay} (${totalItems})`;
  const actions = props.actions || defaultActions;
  const options = {
    actionsColumnIndex: -1,
    loadingType: "linear",
    showEmptyDataSourceMessage: !loading,
    padding: "dense",
    ...tableOptions
  };
  if (enablePagination) {
    return /* @__PURE__ */ React.createElement(
      PaginatedCatalogTable,
      {
        columns: tableColumns,
        emptyContent,
        isLoading: loading,
        title: titleDisplay,
        actions,
        subtitle,
        options,
        data: entities.map(toEntityRow),
        next: pageInfo.next,
        prev: pageInfo.prev
      }
    );
  }
  const rows = entities.sort(refCompare).map(toEntityRow);
  const pageSize = 20;
  const showPagination = rows.length > pageSize;
  return /* @__PURE__ */ React.createElement(
    Table,
    {
      isLoading: loading,
      columns: tableColumns,
      options: {
        paging: showPagination,
        pageSize,
        pageSizeOptions: [20, 50, 100],
        ...options
      },
      title,
      data: rows,
      actions,
      subtitle,
      emptyContent
    }
  );
};
CatalogTable.columns = columnFactories;
CatalogTable.defaultColumnsFunc = defaultCatalogTableColumnsFunc;
function toEntityRow(entity) {
  const partOfSystemRelations = getEntityRelations(entity, RELATION_PART_OF, {
    kind: "system"
  });
  const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
  return {
    entity,
    resolved: {
      // This name is here for backwards compatibility mostly; the
      // presentation of refs in the table should in general be handled with
      // EntityRefLink / EntityName components
      name: humanizeEntityRef(entity, {
        defaultKind: "Component"
      }),
      entityRef: stringifyEntityRef(entity),
      ownedByRelationsTitle: ownedByRelations.map((r) => humanizeEntityRef(r, { defaultKind: "group" })).join(", "),
      ownedByRelations,
      partOfSystemRelationTitle: partOfSystemRelations.map(
        (r) => humanizeEntityRef(r, {
          defaultKind: "system"
        })
      ).join(", "),
      partOfSystemRelations
    }
  };
}

export { CatalogTable as C };
//# sourceMappingURL=CatalogTable-B8071eCT.esm.js.map
