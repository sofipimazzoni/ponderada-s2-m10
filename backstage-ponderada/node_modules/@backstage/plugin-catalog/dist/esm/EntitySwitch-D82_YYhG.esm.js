import { catalogApiRef, useEntity, EntityRefLink, useAsyncEntity } from '@backstage/plugin-catalog-react';
import Alert from '@material-ui/lab/Alert';
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import Button from '@material-ui/core/Button';
import Dialog from '@material-ui/core/Dialog';
import DialogActions from '@material-ui/core/DialogActions';
import DialogTitle from '@material-ui/core/DialogTitle';
import { useApi, alertApiRef, useRouteRef, attachComponentData, useApiHolder, useElementFilter } from '@backstage/core-plugin-api';
import { assertError } from '@backstage/errors';
import { r as rootRouteRef } from './routes-D5H5grpG.esm.js';
import useAsync from 'react-use/esm/useAsync';
import Box from '@material-ui/core/Box';
import { ResponseErrorPanel } from '@backstage/core-components';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { ENTITY_STATUS_CATALOG_PROCESSING_TYPE } from '@backstage/catalog-client';

function DeleteEntityDialog(props) {
  const { open, onClose, onConfirm, entity } = props;
  const [busy, setBusy] = useState(false);
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const onDelete = async () => {
    setBusy(true);
    try {
      const uid = entity.metadata.uid;
      await catalogApi.removeEntityByUid(uid);
      onConfirm();
    } catch (err) {
      assertError(err);
      alertApi.post({ message: err.message });
    } finally {
      setBusy(false);
    }
  };
  return /* @__PURE__ */ React.createElement(Dialog, { open, onClose }, /* @__PURE__ */ React.createElement(DialogTitle, { id: "responsive-dialog-title" }, "Are you sure you want to delete this entity?"), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "secondary",
      disabled: busy,
      onClick: onDelete
    },
    "Delete"
  ), /* @__PURE__ */ React.createElement(Button, { onClick: onClose, color: "primary" }, "Cancel")));
}

function isOrphan(entity) {
  var _a, _b;
  return ((_b = (_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.annotations) == null ? void 0 : _b["backstage.io/orphan"]) === "true";
}
function EntityOrphanWarning() {
  const navigate = useNavigate();
  const catalogLink = useRouteRef(rootRouteRef);
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const { entity } = useEntity();
  const cleanUpAfterRemoval = async () => {
    setConfirmationDialogOpen(false);
    navigate(catalogLink());
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, { severity: "warning", onClick: () => setConfirmationDialogOpen(true) }, "This entity is not referenced by any location and is therefore not receiving updates. Click here to delete."), /* @__PURE__ */ React.createElement(
    DeleteEntityDialog,
    {
      open: confirmationDialogOpen,
      entity,
      onConfirm: cleanUpAfterRemoval,
      onClose: () => setConfirmationDialogOpen(false)
    }
  ));
}

async function getRelationWarnings(entity, catalogApi) {
  var _a;
  const entityRefRelations = (_a = entity.relations) == null ? void 0 : _a.map(
    (relation) => relation.targetRef
  );
  if (!entityRefRelations || (entityRefRelations == null ? void 0 : entityRefRelations.length) < 1 || entityRefRelations.length > 1e3) {
    return [];
  }
  const relatedEntities = await catalogApi.getEntitiesByRefs({
    entityRefs: entityRefRelations,
    fields: ["kind", "metadata.name", "metadata.namespace"]
  });
  return entityRefRelations.filter(
    (_, index) => relatedEntities.items[index] === void 0
  );
}
async function hasRelationWarnings(entity, context) {
  const catalogApi = context.apis.get(catalogApiRef);
  if (!catalogApi) {
    throw new Error(`No implementation available for ${catalogApiRef}`);
  }
  const relatedEntitiesMissing = await getRelationWarnings(entity, catalogApi);
  return relatedEntitiesMissing.length > 0;
}
function EntityRelationWarning() {
  const { entity } = useEntity();
  const catalogApi = useApi(catalogApiRef);
  const { loading, error, value } = useAsync(async () => {
    return getRelationWarnings(entity, catalogApi);
  }, [entity, catalogApi]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Box, { mb: 1 }, /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error }));
  }
  if (loading || !value || value.length === 0) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, { severity: "warning" }, "This entity has relations to other entities, which can't be found in the catalog. ", /* @__PURE__ */ React.createElement("br", null), "Entities not found are: ", value.join(", ")));
}

const errorFilter = (i) => i.error && i.level === "error" && i.type === ENTITY_STATUS_CATALOG_PROCESSING_TYPE;
async function getOwnAndAncestorsErrors(entityRef, catalogApi) {
  const ancestors = await catalogApi.getEntityAncestors({ entityRef });
  const items = ancestors.items.map((item) => {
    var _a, _b;
    const statuses = (_b = (_a = item.entity.status) == null ? void 0 : _a.items) != null ? _b : [];
    const errors = statuses.filter(errorFilter).map((e) => e.error).filter((e) => Boolean(e));
    return { errors, entity: item.entity };
  }).filter((item) => item.errors.length > 0);
  return { items };
}
async function hasCatalogProcessingErrors(entity, context) {
  const catalogApi = context.apis.get(catalogApiRef);
  if (!catalogApi) {
    throw new Error(`No implementation available for ${catalogApiRef}`);
  }
  const errors = await getOwnAndAncestorsErrors(
    stringifyEntityRef(entity),
    catalogApi
  );
  return errors.items.length > 0;
}
function EntityProcessingErrorsPanel() {
  const { entity } = useEntity();
  const entityRef = stringifyEntityRef(entity);
  const catalogApi = useApi(catalogApiRef);
  const { loading, error, value } = useAsync(async () => {
    return getOwnAndAncestorsErrors(entityRef, catalogApi);
  }, [entityRef, catalogApi]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Box, { mb: 1 }, /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error }));
  }
  if (loading || !value) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, value.items.map((ancestorError, index) => /* @__PURE__ */ React.createElement(Box, { key: index, mb: 1 }, stringifyEntityRef(entity) !== stringifyEntityRef(ancestorError.entity) && /* @__PURE__ */ React.createElement(Box, { p: 1 }, "The error below originates from", " ", /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: ancestorError.entity })), ancestorError.errors.map((e, i) => /* @__PURE__ */ React.createElement(ResponseErrorPanel, { key: i, error: e })))));
}

const ENTITY_SWITCH_KEY = "core.backstage.entitySwitch";
const EntitySwitchCaseComponent = (_props) => null;
attachComponentData(EntitySwitchCaseComponent, ENTITY_SWITCH_KEY, true);
const EntitySwitch = (props) => {
  var _a, _b;
  const { entity, loading } = useAsyncEntity();
  const apis = useApiHolder();
  const results = useElementFilter(
    props.children,
    (collection) => collection.selectByComponentData({
      key: ENTITY_SWITCH_KEY,
      withStrictError: "Child of EntitySwitch is not an EntitySwitch.Case"
    }).getElements().flatMap((element) => {
      if (loading && !entity) {
        return [];
      }
      const { if: condition, children: elementsChildren } = element.props;
      if (!entity) {
        return [
          {
            if: condition === void 0,
            children: elementsChildren
          }
        ];
      }
      return [
        {
          if: condition == null ? void 0 : condition(entity, { apis }),
          children: elementsChildren
        }
      ];
    }),
    [apis, entity, loading]
  );
  const hasAsyncCases = results.some(
    (r) => typeof r.if === "object" && "then" in r.if
  );
  if (hasAsyncCases) {
    return /* @__PURE__ */ React.createElement(
      AsyncEntitySwitch,
      {
        results,
        renderMultipleMatches: props.renderMultipleMatches
      }
    );
  }
  if (props.renderMultipleMatches === "all") {
    const children = results.filter((r) => r.if).map((r) => r.children);
    if (children.length === 0) {
      return getDefaultChildren(results);
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
  }
  return (_b = (_a = results.find((r) => r.if)) == null ? void 0 : _a.children) != null ? _b : getDefaultChildren(results);
};
function AsyncEntitySwitch({
  results,
  renderMultipleMatches
}) {
  const { loading, value } = useAsync(async () => {
    var _a;
    const promises = results.map(
      async ({ if: condition, children: output }) => {
        try {
          if (await condition) {
            return output;
          }
        } catch {
        }
        return null;
      }
    );
    if (renderMultipleMatches === "all") {
      const children = (await Promise.all(promises)).filter(Boolean);
      if (children.length === 0) {
        return getDefaultChildren(results);
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
    }
    return (_a = (await Promise.all(promises)).find(Boolean)) != null ? _a : getDefaultChildren(results);
  }, [results]);
  if (loading || !value) {
    return null;
  }
  return value;
}
function getDefaultChildren(results) {
  var _a, _b;
  return (_b = (_a = results.filter((r) => r.if === void 0)[0]) == null ? void 0 : _a.children) != null ? _b : null;
}
EntitySwitch.Case = EntitySwitchCaseComponent;

export { EntitySwitch as E, EntityOrphanWarning as a, EntityRelationWarning as b, hasCatalogProcessingErrors as c, EntityProcessingErrorsPanel as d, hasRelationWarnings as h, isOrphan as i };
//# sourceMappingURL=EntitySwitch-D82_YYhG.esm.js.map
