'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var passportBitbucketOauth2 = require('passport-bitbucket-oauth2');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var backendPluginApi = require('@backstage/backend-plugin-api');

const bitbucketAuthenticator = pluginAuthNode.createOAuthAuthenticator({
  defaultProfileTransform: pluginAuthNode.PassportOAuthAuthenticatorHelper.defaultProfileTransform,
  initialize({ callbackUrl, config }) {
    const clientID = config.getString("clientId");
    const clientSecret = config.getString("clientSecret");
    const baseURL = "https://bitbucket.org/site/oauth2";
    return pluginAuthNode.PassportOAuthAuthenticatorHelper.from(
      new passportBitbucketOauth2.Strategy(
        {
          clientID,
          clientSecret,
          callbackURL: callbackUrl,
          passReqToCallback: false,
          baseURL,
          authorizationURL: `${baseURL}/authorize`,
          tokenURL: `${baseURL}/access_token`
        },
        (accessToken, refreshToken, params, fullProfile, done) => {
          done(
            void 0,
            { fullProfile, params, accessToken },
            { refreshToken }
          );
        }
      )
    );
  },
  async start(input, helper) {
    return helper.start(input, {
      accessType: "offline",
      prompt: "consent"
    });
  },
  async authenticate(input, helper) {
    return helper.authenticate(input);
  },
  async refresh(input, helper) {
    return helper.refresh(input);
  }
});

exports.bitbucketSignInResolvers = void 0;
((bitbucketSignInResolvers2) => {
  bitbucketSignInResolvers2.userIdMatchingUserEntityAnnotation = pluginAuthNode.createSignInResolverFactory(
    {
      create() {
        return async (info, ctx) => {
          const { result } = info;
          const id = result.fullProfile.id;
          if (!id) {
            throw new Error("Bitbucket user profile does not contain an ID");
          }
          return ctx.signInWithCatalogUser({
            annotations: {
              "bitbucket.org/user-id": id
            }
          });
        };
      }
    }
  );
  bitbucketSignInResolvers2.usernameMatchingUserEntityAnnotation = pluginAuthNode.createSignInResolverFactory({
    create() {
      return async (info, ctx) => {
        const { result } = info;
        const username = result.fullProfile.username;
        if (!username) {
          throw new Error(
            "Bitbucket user profile does not contain a Username"
          );
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "bitbucket.org/username": username
          }
        });
      };
    }
  });
})(exports.bitbucketSignInResolvers || (exports.bitbucketSignInResolvers = {}));

const authModuleBitbucketProvider = backendPluginApi.createBackendModule({
  pluginId: "auth",
  moduleId: "bitbucket-provider",
  register(reg) {
    reg.registerInit({
      deps: {
        providers: pluginAuthNode.authProvidersExtensionPoint
      },
      async init({ providers }) {
        providers.registerProvider({
          providerId: "bitbucket",
          factory: pluginAuthNode.createOAuthProviderFactory({
            authenticator: bitbucketAuthenticator,
            signInResolverFactories: {
              ...exports.bitbucketSignInResolvers,
              ...pluginAuthNode.commonSignInResolvers
            }
          })
        });
      }
    });
  }
});

exports.bitbucketAuthenticator = bitbucketAuthenticator;
exports.default = authModuleBitbucketProvider;
//# sourceMappingURL=index.cjs.js.map
