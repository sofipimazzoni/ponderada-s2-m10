import { Progress, ResponseErrorPanel, Link, OverflowTooltip, InfoCard } from '@backstage/core-components';
import { catalogApiRef, humanizeEntityRef, getEntityRelations, useEntity } from '@backstage/plugin-catalog-react';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import ListItemSecondaryAction from '@material-ui/core/ListItemSecondaryAction';
import ListItemText from '@material-ui/core/ListItemText';
import Switch from '@material-ui/core/Switch';
import Tooltip from '@material-ui/core/Tooltip';
import { makeStyles, createStyles } from '@material-ui/core/styles';
import React, { useState, useEffect } from 'react';
import { useApi, useRouteRef } from '@backstage/core-plugin-api';
import Box from '@material-ui/core/Box';
import Grid from '@material-ui/core/Grid';
import Typography from '@material-ui/core/Typography';
import pluralize from 'pluralize';
import { c as catalogIndexRouteRef } from './routes-B-Sa5Rrg.esm.js';
import { parseEntityRef, stringifyEntityRef, RELATION_MEMBER_OF, RELATION_PARENT_OF } from '@backstage/catalog-model';
import limiterFactory from 'p-limit';
import useAsync from 'react-use/esm/useAsync';
import qs from 'qs';
import { uniq } from 'lodash';

const limiter = limiterFactory(10);
const getQueryParams = (ownersEntityRef, selectedEntity) => {
  const { kind, type } = selectedEntity;
  const owners = ownersEntityRef.map(
    (owner) => humanizeEntityRef(parseEntityRef(owner), { defaultKind: "group" })
  );
  const filters = {
    kind: kind.toLocaleLowerCase("en-US"),
    type,
    owners,
    user: "all"
  };
  return qs.stringify({ filters }, { arrayFormat: "repeat" });
};
const getMemberOfEntityRefs = (owner) => {
  const parentGroups = getEntityRelations(owner, RELATION_MEMBER_OF, {
    kind: "Group"
  });
  const ownerGroupsNames = parentGroups.map(
    ({ kind, namespace, name }) => stringifyEntityRef({
      kind,
      namespace,
      name
    })
  );
  return [...ownerGroupsNames, stringifyEntityRef(owner)];
};
const isEntity = (entity) => entity !== void 0;
const getChildOwnershipEntityRefs = async (entity, catalogApi, alreadyRetrievedParentRefs = []) => {
  const childGroups = getEntityRelations(entity, RELATION_PARENT_OF, {
    kind: "Group"
  });
  const hasChildGroups = childGroups.length > 0;
  const entityRef = stringifyEntityRef(entity);
  if (hasChildGroups) {
    const entityRefs = childGroups.map((r) => stringifyEntityRef(r));
    const childGroupResponse = await catalogApi.getEntitiesByRefs({
      fields: ["kind", "metadata.namespace", "metadata.name", "relations"],
      entityRefs
    });
    const childGroupEntities = childGroupResponse.items.filter(isEntity);
    const unknownChildren = childGroupEntities.filter(
      (childGroupEntity) => !alreadyRetrievedParentRefs.includes(
        stringifyEntityRef(childGroupEntity)
      )
    );
    const childrenRefs = (await Promise.all(
      unknownChildren.map(
        (childGroupEntity) => limiter(
          () => getChildOwnershipEntityRefs(childGroupEntity, catalogApi, [
            ...alreadyRetrievedParentRefs,
            entityRef
          ])
        )
      )
    )).flatMap((aggregated) => aggregated);
    return uniq([...childrenRefs, entityRef]);
  }
  return [entityRef];
};
const getOwners = async (entity, relations, catalogApi) => {
  const isGroup = entity.kind === "Group";
  const isAggregated = relations === "aggregated";
  const isUserEntity = entity.kind === "User";
  if (isAggregated && isGroup) {
    return getChildOwnershipEntityRefs(entity, catalogApi);
  }
  if (isAggregated && isUserEntity) {
    return getMemberOfEntityRefs(entity);
  }
  return [stringifyEntityRef(entity)];
};
const getOwnedEntitiesByOwners = (owners, kinds, catalogApi) => catalogApi.getEntities({
  filter: [
    {
      kind: kinds,
      "relations.ownedBy": owners
    }
  ],
  fields: [
    "kind",
    "metadata.name",
    "metadata.namespace",
    "spec.type",
    "relations"
  ]
});
function useGetEntities(entity, relations, entityFilterKind, entityLimit = 6) {
  const catalogApi = useApi(catalogApiRef);
  const kinds = entityFilterKind != null ? entityFilterKind : ["Component", "API", "System"];
  const {
    loading,
    error,
    value: componentsWithCounters
  } = useAsync(async () => {
    const owners = await getOwners(entity, relations, catalogApi);
    const ownedEntitiesList = await getOwnedEntitiesByOwners(
      owners,
      kinds,
      catalogApi
    );
    const counts = ownedEntitiesList.items.reduce(
      (acc, ownedEntity) => {
        var _a, _b;
        const match = acc.find(
          (x) => {
            var _a2;
            return x.kind === ownedEntity.kind && x.type === ((_a2 = ownedEntity.spec) == null ? void 0 : _a2.type);
          }
        );
        if (match) {
          match.count += 1;
        } else {
          acc.push({
            kind: ownedEntity.kind,
            type: (_b = (_a = ownedEntity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString(),
            count: 1
          });
        }
        return acc;
      },
      []
    );
    const topN = counts.sort((a, b) => b.count - a.count).slice(0, entityLimit);
    return topN.map((topOwnedEntity) => ({
      counter: topOwnedEntity.count,
      type: topOwnedEntity.type,
      kind: topOwnedEntity.kind,
      queryParams: getQueryParams(owners, topOwnedEntity)
    }));
  }, [catalogApi, entity, relations]);
  return {
    componentsWithCounters,
    loading,
    error
  };
}

const useStyles$1 = makeStyles(
  (theme) => createStyles({
    card: {
      border: `1px solid ${theme.palette.divider}`,
      boxShadow: theme.shadows[2],
      borderRadius: "4px",
      padding: theme.spacing(2),
      transition: `${theme.transitions.duration.standard}ms`,
      "&:hover": {
        boxShadow: theme.shadows[4]
      },
      height: "100%"
    },
    bold: {
      fontWeight: theme.typography.fontWeightBold
    },
    smallFont: {
      fontSize: theme.typography.body2.fontSize
    },
    entityTypeBox: {
      background: (props) => theme.getPageTheme({ themeId: props.type }).backgroundImage,
      color: (props) => theme.getPageTheme({ themeId: props.type }).fontColor
    }
  })
);
const EntityCountTile = ({
  counter,
  type,
  kind,
  url
}) => {
  const classes = useStyles$1({ type: type != null ? type : kind });
  const rawTitle = type != null ? type : kind;
  const isLongText = rawTitle.length > 10;
  return /* @__PURE__ */ React.createElement(Link, { to: url, variant: "body2" }, /* @__PURE__ */ React.createElement(
    Box,
    {
      className: `${classes.card} ${classes.entityTypeBox}`,
      display: "flex",
      flexDirection: "column",
      alignItems: "center"
    },
    /* @__PURE__ */ React.createElement(Typography, { className: classes.bold, variant: "h6" }, counter),
    /* @__PURE__ */ React.createElement(Box, { sx: { width: "100%", textAlign: "center" } }, /* @__PURE__ */ React.createElement(
      Typography,
      {
        className: `${classes.bold} ${isLongText && classes.smallFont}`,
        variant: "h6"
      },
      /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: pluralize(rawTitle.toLocaleUpperCase("en-US"), counter)
        }
      )
    )),
    type && /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1" }, kind)
  ));
};
const ComponentsGrid = ({
  className,
  entity,
  relationsType,
  entityFilterKind,
  entityLimit = 6
}) => {
  const catalogLink = useRouteRef(catalogIndexRouteRef);
  const { componentsWithCounters, loading, error } = useGetEntities(
    entity,
    relationsType,
    entityFilterKind,
    entityLimit
  );
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  return /* @__PURE__ */ React.createElement(Grid, { container: true, className }, componentsWithCounters == null ? void 0 : componentsWithCounters.map((c) => {
    var _a;
    return /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6, md: 6, lg: 4, key: (_a = c.type) != null ? _a : c.kind }, /* @__PURE__ */ React.createElement(
      EntityCountTile,
      {
        counter: c.counter,
        kind: c.kind,
        type: c.type,
        url: `${catalogLink()}/?${c.queryParams}`
      }
    ));
  }));
};

const useStyles = makeStyles((theme) => ({
  card: {
    maxHeight: "100%"
  },
  cardContent: {
    display: "flex",
    flexDirection: "column",
    overflow: "hidden"
  },
  list: {
    [theme.breakpoints.down("xs")]: {
      padding: `0 0 12px`
    }
  },
  listItemText: {
    [theme.breakpoints.down("xs")]: {
      paddingRight: 0,
      paddingLeft: 0
    }
  },
  listItemSecondaryAction: {
    [theme.breakpoints.down("xs")]: {
      width: "100%",
      top: "auto",
      right: "auto",
      position: "relative",
      transform: "unset"
    }
  },
  grid: {
    overflowY: "auto",
    marginTop: 0
  }
}));
const OwnershipCard = (props) => {
  const {
    variant,
    entityFilterKind,
    hideRelationsToggle,
    relationsType,
    entityLimit = 6
  } = props;
  const relationsToggle = hideRelationsToggle === void 0 ? false : hideRelationsToggle;
  const classes = useStyles();
  const { entity } = useEntity();
  const defaultRelationsType = entity.kind === "User" ? "aggregated" : "direct";
  const [getRelationsType, setRelationsType] = useState(
    relationsType != null ? relationsType : defaultRelationsType
  );
  useEffect(() => {
    if (!relationsType) {
      setRelationsType(defaultRelationsType);
    }
  }, [setRelationsType, defaultRelationsType, relationsType]);
  return /* @__PURE__ */ React.createElement(
    InfoCard,
    {
      title: "Ownership",
      variant,
      className: classes.card,
      cardClassName: classes.cardContent
    },
    !relationsToggle && /* @__PURE__ */ React.createElement(List, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, { className: classes.list }, /* @__PURE__ */ React.createElement(ListItemText, { className: classes.listItemText }), /* @__PURE__ */ React.createElement(
      ListItemSecondaryAction,
      {
        className: classes.listItemSecondaryAction
      },
      "Direct Relations",
      /* @__PURE__ */ React.createElement(
        Tooltip,
        {
          placement: "top",
          arrow: true,
          title: `${getRelationsType === "direct" ? "Direct" : "Aggregated"} Relations`
        },
        /* @__PURE__ */ React.createElement(
          Switch,
          {
            color: "primary",
            checked: getRelationsType !== "direct",
            onChange: () => {
              const updatedRelationsType = getRelationsType === "direct" ? "aggregated" : "direct";
              setRelationsType(updatedRelationsType);
            },
            name: "pin",
            inputProps: { "aria-label": "Ownership Type Switch" }
          }
        )
      ),
      "Aggregated Relations"
    ))),
    /* @__PURE__ */ React.createElement(
      ComponentsGrid,
      {
        className: classes.grid,
        entity,
        entityLimit,
        relationsType: getRelationsType,
        entityFilterKind
      }
    )
  );
};

export { OwnershipCard };
//# sourceMappingURL=OwnershipCard-DUaYCP-K.esm.js.map
