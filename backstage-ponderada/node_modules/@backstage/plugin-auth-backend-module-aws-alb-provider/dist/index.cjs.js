'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@backstage/errors');
var jose = require('jose');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var NodeCache = require('node-cache');
var crypto = require('crypto');
var fetch = require('node-fetch');
var backendPluginApi = require('@backstage/backend-plugin-api');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var NodeCache__default = /*#__PURE__*/_interopDefaultCompat(NodeCache);
var crypto__namespace = /*#__PURE__*/_interopNamespaceCompat(crypto);
var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);

const makeProfileInfo = (profile, idToken) => {
  var _a, _b;
  let email = void 0;
  if (profile.emails && profile.emails.length > 0) {
    const [firstEmail] = profile.emails;
    email = firstEmail.value;
  }
  let picture = void 0;
  if (profile.avatarUrl) {
    picture = profile.avatarUrl;
  } else if (profile.photos && profile.photos.length > 0) {
    const [firstPhoto] = profile.photos;
    picture = firstPhoto.value;
  }
  let displayName = (_b = (_a = profile.displayName) != null ? _a : profile.username) != null ? _b : profile.id;
  if ((!email || !picture || !displayName) && idToken) {
    try {
      const decoded = jose.decodeJwt(idToken);
      if (!email && decoded.email) {
        email = decoded.email;
      }
      if (!picture && decoded.picture) {
        picture = decoded.picture;
      }
      if (!displayName && decoded.name) {
        displayName = decoded.name;
      }
    } catch (e) {
      throw new Error(`Failed to parse id token and get profile info, ${e}`);
    }
  }
  return {
    email,
    picture,
    displayName
  };
};
const getPublicKeyEndpoint = (region) => {
  if (region.startsWith("us-gov")) {
    return `https://s3-${encodeURIComponent(
      region
    )}.amazonaws.com/aws-elb-public-keys-prod-${encodeURIComponent(region)}`;
  }
  return `https://public-keys.auth.elb.${encodeURIComponent(
    region
  )}.amazonaws.com`;
};
const provisionKeyCache = (region, keyCache) => {
  return async (header) => {
    if (!header.kid) {
      throw new errors.AuthenticationError("No key id was specified in header");
    }
    const optionalCacheKey = keyCache.get(header.kid);
    if (optionalCacheKey) {
      return crypto__namespace.createPublicKey(optionalCacheKey);
    }
    const keyText = await fetch__default.default(
      `${getPublicKeyEndpoint(region)}/${encodeURIComponent(header.kid)}`
    ).then((response) => response.text());
    const keyValue = crypto__namespace.createPublicKey(keyText);
    keyCache.set(header.kid, keyValue.export({ format: "pem", type: "spki" }));
    return keyValue;
  };
};

const ALB_JWT_HEADER = "x-amzn-oidc-data";
const ALB_ACCESS_TOKEN_HEADER = "x-amzn-oidc-accesstoken";
const awsAlbAuthenticator = pluginAuthNode.createProxyAuthenticator({
  defaultProfileTransform: async (result) => {
    return {
      profile: makeProfileInfo(result.fullProfile, result.accessToken)
    };
  },
  initialize({ config }) {
    const issuer = config.getString("issuer");
    const region = config.getString("region");
    const keyCache = new NodeCache__default.default({ stdTTL: 3600 });
    const getKey = provisionKeyCache(region, keyCache);
    return { issuer, getKey };
  },
  async authenticate({ req }, { issuer, getKey }) {
    const jwt = req.header(ALB_JWT_HEADER);
    const accessToken = req.header(ALB_ACCESS_TOKEN_HEADER);
    if (jwt === void 0) {
      throw new errors.AuthenticationError(
        `Missing ALB OIDC header: ${ALB_JWT_HEADER}`
      );
    }
    if (accessToken === void 0) {
      throw new errors.AuthenticationError(
        `Missing ALB OIDC header: ${ALB_ACCESS_TOKEN_HEADER}`
      );
    }
    try {
      const verifyResult = await jose.jwtVerify(jwt, getKey);
      const claims = verifyResult.payload;
      if (issuer && (claims == null ? void 0 : claims.iss) !== issuer) {
        throw new errors.AuthenticationError("Issuer mismatch on JWT token");
      }
      const fullProfile = {
        provider: "unknown",
        id: claims.sub,
        displayName: claims.name,
        username: claims.email.split("@")[0].toLowerCase(),
        name: {
          familyName: claims.family_name,
          givenName: claims.given_name
        },
        emails: [{ value: claims.email.toLowerCase() }],
        photos: [{ value: claims.picture }]
      };
      return {
        result: {
          fullProfile,
          accessToken,
          expiresInSeconds: claims.exp
        },
        providerInfo: {
          accessToken,
          expiresInSeconds: claims.exp
        }
      };
    } catch (e) {
      throw new Error(`Exception occurred during JWT processing: ${e}`);
    }
  }
});

exports.awsAlbSignInResolvers = void 0;
((awsAlbSignInResolvers2) => {
  awsAlbSignInResolvers2.emailMatchingUserEntityProfileEmail = pluginAuthNode.createSignInResolverFactory({
    create() {
      return async (info, ctx) => {
        if (!info.result.fullProfile.emails) {
          throw new Error(
            "Login failed, user profile does not contain an email"
          );
        }
        return ctx.signInWithCatalogUser({
          filter: {
            kind: ["User"],
            "spec.profile.email": info.result.fullProfile.emails[0].value
          }
        });
      };
    }
  });
})(exports.awsAlbSignInResolvers || (exports.awsAlbSignInResolvers = {}));

const authModuleAwsAlbProvider = backendPluginApi.createBackendModule({
  pluginId: "auth",
  moduleId: "awsAlbProvider",
  register(reg) {
    reg.registerInit({
      deps: {
        providers: pluginAuthNode.authProvidersExtensionPoint
      },
      async init({ providers }) {
        providers.registerProvider({
          providerId: "awsalb",
          factory: pluginAuthNode.createProxyAuthProviderFactory({
            authenticator: awsAlbAuthenticator,
            signInResolverFactories: {
              ...pluginAuthNode.commonSignInResolvers,
              ...exports.awsAlbSignInResolvers
            }
          })
        });
      }
    });
  }
});

exports.authModuleAwsAlbProvider = authModuleAwsAlbProvider;
exports.awsAlbAuthenticator = awsAlbAuthenticator;
exports.default = authModuleAwsAlbProvider;
//# sourceMappingURL=index.cjs.js.map
