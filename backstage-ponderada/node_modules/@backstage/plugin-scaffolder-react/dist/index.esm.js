import { attachComponentData, useElementFilter, useApi } from '@backstage/core-plugin-api';
import { s as scaffolderApiRef } from './esm/ref-NRtFlQHB.esm.js';
export { S as SecretsContextProvider, u as useTemplateSecrets } from './esm/ref-NRtFlQHB.esm.js';
import { useImmerReducer } from 'use-immer';
import { useEffect } from 'react';
import '@backstage/version-bridge';

const FIELD_EXTENSION_WRAPPER_KEY = "scaffolder.extensions.wrapper.v1";
const FIELD_EXTENSION_KEY = "scaffolder.extensions.field.v1";

function createScaffolderFieldExtension(options) {
  return {
    expose() {
      const FieldExtensionDataHolder = () => null;
      attachComponentData(
        FieldExtensionDataHolder,
        FIELD_EXTENSION_KEY,
        options
      );
      return FieldExtensionDataHolder;
    }
  };
}
const ScaffolderFieldExtensions = () => null;
attachComponentData(
  ScaffolderFieldExtensions,
  FIELD_EXTENSION_WRAPPER_KEY,
  true
);

const useCustomFieldExtensions = (outlet) => {
  return useElementFilter(
    outlet,
    (elements) => elements.selectByComponentData({
      key: FIELD_EXTENSION_WRAPPER_KEY
    }).findComponentData({
      key: FIELD_EXTENSION_KEY
    })
  );
};

const LAYOUTS_KEY = "scaffolder.layout.v1";
const LAYOUTS_WRAPPER_KEY = "scaffolder.layouts.wrapper.v1";

const useCustomLayouts = (outlet) => {
  return useElementFilter(
    outlet,
    (elements) => elements.selectByComponentData({
      key: LAYOUTS_WRAPPER_KEY
    }).findComponentData({
      key: LAYOUTS_KEY
    })
  );
};

function reducer(draft, action) {
  var _a, _b, _c;
  switch (action.type) {
    case "INIT": {
      draft.steps = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = { status: "open", id: next.id };
        return current;
      }, {});
      draft.stepLogs = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = [];
        return current;
      }, {});
      draft.loading = false;
      draft.error = void 0;
      draft.completed = false;
      draft.task = action.data;
      return;
    }
    case "LOGS": {
      const entries = action.data;
      for (const entry of entries) {
        const logLine = `${entry.createdAt} ${entry.body.message}`;
        if (!entry.body.stepId || !((_a = draft.steps) == null ? void 0 : _a[entry.body.stepId])) {
          continue;
        }
        const currentStepLog = (_b = draft.stepLogs) == null ? void 0 : _b[entry.body.stepId];
        const currentStep = (_c = draft.steps) == null ? void 0 : _c[entry.body.stepId];
        if (currentStep) {
          if (entry.body.status && entry.body.status !== currentStep.status) {
            currentStep.status = entry.body.status;
            if (currentStep.status === "processing") {
              currentStep.startedAt = entry.createdAt;
            }
            if (["cancelled", "completed", "failed"].includes(currentStep.status)) {
              currentStep.endedAt = entry.createdAt;
            }
          }
        }
        currentStepLog == null ? void 0 : currentStepLog.push(logLine);
      }
      return;
    }
    case "COMPLETED": {
      draft.completed = true;
      draft.output = action.data.body.output;
      draft.error = action.data.body.error;
      return;
    }
    case "CANCELLED": {
      draft.cancelled = true;
      return;
    }
    case "RECOVERED": {
      for (const stepId in draft.steps) {
        if (draft.steps.hasOwnProperty(stepId)) {
          draft.steps[stepId].startedAt = void 0;
          draft.steps[stepId].endedAt = void 0;
          draft.steps[stepId].status = "open";
        }
      }
      return;
    }
    case "ERROR": {
      draft.error = action.data;
      draft.loading = false;
      draft.completed = true;
      return;
    }
    default:
      return;
  }
}
const useTaskEventStream = (taskId) => {
  const scaffolderApi = useApi(scaffolderApiRef);
  const [state, dispatch] = useImmerReducer(reducer, {
    cancelled: false,
    loading: true,
    completed: false,
    stepLogs: {},
    steps: {}
  });
  useEffect(() => {
    let didCancel = false;
    let subscription;
    let logPusher;
    let retryCount = 1;
    const startStreamLogProcess = () => scaffolderApi.getTask(taskId).then(
      (task) => {
        if (didCancel) {
          return;
        }
        dispatch({ type: "INIT", data: task });
        const observable = scaffolderApi.streamLogs({ taskId });
        const collectedLogEvents = new Array();
        function emitLogs() {
          if (collectedLogEvents.length) {
            const logs = collectedLogEvents.splice(
              0,
              collectedLogEvents.length
            );
            dispatch({ type: "LOGS", data: logs });
          }
        }
        logPusher = setInterval(emitLogs, 500);
        subscription = observable.subscribe({
          next: (event) => {
            retryCount = 1;
            switch (event.type) {
              case "log":
                return collectedLogEvents.push(event);
              case "cancelled":
                dispatch({ type: "CANCELLED" });
                return void 0;
              case "completion":
                emitLogs();
                dispatch({ type: "COMPLETED", data: event });
                return void 0;
              case "recovered":
                dispatch({ type: "RECOVERED", data: event });
                return void 0;
              default:
                throw new Error(
                  `Unhandled event type ${event.type} in observer`
                );
            }
          },
          error: (error) => {
            emitLogs();
            const maxRetries = 3;
            if (!error.message) {
              error.message = `We cannot connect at the moment, trying again in some seconds... Retrying (${retryCount > maxRetries ? maxRetries : retryCount}/${maxRetries} retries)`;
            }
            setTimeout(() => {
              retryCount += 1;
              void startStreamLogProcess();
            }, 15e3);
            dispatch({ type: "ERROR", data: error });
          }
        });
      },
      (error) => {
        if (!didCancel) {
          dispatch({ type: "ERROR", data: error });
        }
      }
    );
    void startStreamLogProcess();
    return () => {
      didCancel = true;
      if (subscription) {
        subscription.unsubscribe();
      }
      if (logPusher) {
        clearInterval(logPusher);
      }
    };
  }, [scaffolderApi, dispatch, taskId]);
  return state;
};

function createScaffolderLayout(options) {
  return {
    expose() {
      const LayoutDataHolder = () => null;
      attachComponentData(LayoutDataHolder, LAYOUTS_KEY, options);
      return LayoutDataHolder;
    }
  };
}
const ScaffolderLayouts = () => null;
attachComponentData(ScaffolderLayouts, LAYOUTS_WRAPPER_KEY, true);

export { ScaffolderFieldExtensions, ScaffolderLayouts, createScaffolderFieldExtension, createScaffolderLayout, scaffolderApiRef, useCustomFieldExtensions, useCustomLayouts, useTaskEventStream };
//# sourceMappingURL=index.esm.js.map
