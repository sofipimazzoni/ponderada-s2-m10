'use strict';

var backendCommon = require('@backstage/backend-common');
var helmet = require('helmet');
var express = require('express');
var Router = require('express-promise-router');
var fs = require('fs-extra');
var path = require('path');
var configLoader = require('@backstage/config-loader');
var luxon = require('luxon');
var partition = require('lodash/partition');
var globby = require('globby');
var errors = require('@backstage/errors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var helmet__default = /*#__PURE__*/_interopDefaultCompat(helmet);
var express__default = /*#__PURE__*/_interopDefaultCompat(express);
var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var partition__default = /*#__PURE__*/_interopDefaultCompat(partition);
var globby__default = /*#__PURE__*/_interopDefaultCompat(globby);

async function injectConfig(options) {
  const { staticDir, logger, appConfigs } = options;
  const files = await fs__default.default.readdir(staticDir);
  const jsFiles = files.filter((file) => file.endsWith(".js"));
  const escapedData = JSON.stringify(appConfigs).replace(/("|'|\\)/g, "\\$1");
  const injected = `/*__APP_INJECTED_CONFIG_MARKER__*/"${escapedData}"/*__INJECTED_END__*/`;
  for (const jsFile of jsFiles) {
    const path$1 = path.resolve(staticDir, jsFile);
    const content = await fs__default.default.readFile(path$1, "utf8");
    if (content.includes("__APP_INJECTED_RUNTIME_CONFIG__")) {
      logger.info(`Injecting env config into ${jsFile}`);
      const newContent = content.replaceAll(
        '"__APP_INJECTED_RUNTIME_CONFIG__"',
        injected
      );
      await fs__default.default.writeFile(path$1, newContent, "utf8");
      return path$1;
    } else if (content.includes("__APP_INJECTED_CONFIG_MARKER__")) {
      logger.info(`Replacing injected env config in ${jsFile}`);
      const newContent = content.replaceAll(
        /\/\*__APP_INJECTED_CONFIG_MARKER__\*\/.*?\/\*__INJECTED_END__\*\//g,
        injected
      );
      await fs__default.default.writeFile(path$1, newContent, "utf8");
      return path$1;
    }
  }
  logger.info("Env config not injected");
  return void 0;
}
async function readConfigs(options) {
  const { env, appDistDir, config } = options;
  const appConfigs = configLoader.readEnvConfig(env);
  const schemaPath = path.resolve(appDistDir, ".config-schema.json");
  if (await fs__default.default.pathExists(schemaPath)) {
    const serializedSchema = await fs__default.default.readJson(schemaPath);
    try {
      const schema = options.schema || await configLoader.loadConfigSchema({
        serialized: serializedSchema
      });
      const frontendConfigs = await schema.process(
        [{ data: config.get(), context: "app" }],
        { visibility: ["frontend"], withDeprecatedKeys: true }
      );
      appConfigs.push(...frontendConfigs);
    } catch (error) {
      throw new Error(
        `Invalid app bundle schema. If this error is unexpected you need to run \`yarn build\` in the app. If that doesn't help you should make sure your config schema is correct and rebuild the app bundle again. Caused by the following schema error, ${error}`
      );
    }
  }
  return appConfigs;
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _db, _logger, _namespace;
const migrationsDir = backendCommon.resolvePackagePath(
  "@backstage/plugin-app-backend",
  "migrations"
);
const _StaticAssetsStore = class _StaticAssetsStore {
  constructor(client, logger, namespace) {
    __privateAdd(this, _db, void 0);
    __privateAdd(this, _logger, void 0);
    __privateAdd(this, _namespace, void 0);
    __privateSet(this, _db, client);
    __privateSet(this, _logger, logger);
    __privateSet(this, _namespace, namespace != null ? namespace : "default");
  }
  static async create(options) {
    var _a;
    const { database } = options;
    const client = await database.getClient();
    if (!((_a = database.migrations) == null ? void 0 : _a.skip)) {
      await client.migrate.latest({
        directory: migrationsDir
      });
    }
    return new _StaticAssetsStore(client, options.logger);
  }
  /**
   * Creates a new store with the provided namespace, using the same underlying storage.
   */
  withNamespace(namespace) {
    return new _StaticAssetsStore(__privateGet(this, _db), __privateGet(this, _logger), namespace);
  }
  /**
   * Store the provided assets.
   *
   * If an asset for a given path already exists the modification time will be
   * updated, but the contents will not.
   */
  async storeAssets(assets) {
    const existingRows = await __privateGet(this, _db).call(this, "static_assets_cache").where("namespace", __privateGet(this, _namespace)).whereIn(
      "path",
      assets.map((a) => a.path)
    );
    const existingAssetPaths = new Set(existingRows.map((r) => r.path));
    const [modified, added] = partition__default.default(
      assets,
      (asset) => existingAssetPaths.has(asset.path)
    );
    __privateGet(this, _logger).info(
      `Storing ${modified.length} updated assets and ${added.length} new assets`
    );
    await __privateGet(this, _db).call(this, "static_assets_cache").update({
      last_modified_at: __privateGet(this, _db).fn.now()
    }).where("namespace", __privateGet(this, _namespace)).whereIn(
      "path",
      modified.map((a) => a.path)
    );
    for (const asset of added) {
      await __privateGet(this, _db).call(this, "static_assets_cache").insert({
        path: asset.path,
        content: await asset.content(),
        namespace: __privateGet(this, _namespace)
      }).onConflict(["namespace", "path"]).ignore();
    }
  }
  /**
   * Retrieve an asset from the store with the given path.
   */
  async getAsset(path) {
    const [row] = await __privateGet(this, _db).call(this, "static_assets_cache").where({
      path,
      namespace: __privateGet(this, _namespace)
    });
    if (!row) {
      return void 0;
    }
    return {
      path: row.path,
      content: row.content,
      lastModifiedAt: typeof row.last_modified_at === "string" ? luxon.DateTime.fromSQL(row.last_modified_at, { zone: "UTC" }).toJSDate() : row.last_modified_at
    };
  }
  /**
   * Delete any assets from the store whose modification time is older than the max age.
   */
  async trimAssets(options) {
    const { maxAgeSeconds } = options;
    let lastModifiedInterval = __privateGet(this, _db).raw(
      `now() + interval '${-maxAgeSeconds} seconds'`
    );
    if (__privateGet(this, _db).client.config.client.includes("mysql")) {
      lastModifiedInterval = __privateGet(this, _db).raw(
        `date_sub(now(), interval ${maxAgeSeconds} second)`
      );
    } else if (__privateGet(this, _db).client.config.client.includes("sqlite3")) {
      lastModifiedInterval = __privateGet(this, _db).raw(`datetime('now', ?)`, [
        `-${maxAgeSeconds} seconds`
      ]);
    }
    await __privateGet(this, _db).call(this, "static_assets_cache").where("namespace", __privateGet(this, _namespace)).where("last_modified_at", "<=", lastModifiedInterval).delete();
  }
};
_db = new WeakMap();
_logger = new WeakMap();
_namespace = new WeakMap();
let StaticAssetsStore = _StaticAssetsStore;

async function findStaticAssets(staticDir) {
  const assetPaths = await globby__default.default("**/*", {
    ignore: ["**/*.map"],
    // Ignore source maps since they're quite large
    cwd: staticDir,
    dot: true
  });
  return assetPaths.map((path) => ({
    path,
    content: async () => fs__default.default.readFile(backendCommon.resolveSafeChildPath(staticDir, path))
  }));
}

const CACHE_CONTROL_NO_CACHE = "no-store, max-age=0";
const CACHE_CONTROL_MAX_CACHE = "public, max-age=1209600";
const CACHE_CONTROL_REVALIDATE_CACHE = "no-cache";

function createStaticAssetMiddleware(store) {
  return (req, res, next) => {
    if (req.method !== "GET" && req.method !== "HEAD") {
      next();
      return;
    }
    Promise.resolve(
      (async () => {
        const path$1 = req.path.startsWith("/") ? req.path.slice(1) : req.path;
        const asset = await store.getAsset(path$1);
        if (!asset) {
          next();
          return;
        }
        const ext = path.extname(asset.path);
        if (ext) {
          res.type(ext);
        } else {
          res.type("bin");
        }
        res.setHeader("Cache-Control", CACHE_CONTROL_MAX_CACHE);
        res.setHeader("Last-Modified", asset.lastModifiedAt.toUTCString());
        res.send(asset.content);
      })()
    ).catch(next);
  };
}

async function createRouter(options) {
  var _a;
  const {
    config,
    logger,
    appPackageName,
    staticFallbackHandler,
    auth,
    httpAuth
  } = options;
  const disableConfigInjection = (_a = options.disableConfigInjection) != null ? _a : config.getOptionalBoolean("app.disableConfigInjection");
  const disableStaticFallbackCache = config.getOptionalBoolean(
    "app.disableStaticFallbackCache"
  );
  const appDistDir = backendCommon.resolvePackagePath(appPackageName, "dist");
  const staticDir = path.resolve(appDistDir, "static");
  if (!await fs__default.default.pathExists(staticDir)) {
    if (process.env.NODE_ENV === "production") {
      logger.error(
        `Can't serve static app content from ${staticDir}, directory doesn't exist`
      );
    }
    return Router__default.default();
  }
  logger.info(`Serving static app content from ${appDistDir}`);
  const appConfigs = disableConfigInjection ? void 0 : await readConfigs({
    config,
    appDistDir,
    env: process.env
  });
  const assetStore = options.database && !disableStaticFallbackCache ? await StaticAssetsStore.create({
    logger,
    database: options.database
  }) : void 0;
  const router = Router__default.default();
  router.use(helmet__default.default.frameguard({ action: "deny" }));
  const publicDistDir = path.resolve(appDistDir, "public");
  const enablePublicEntryPoint = await fs__default.default.pathExists(publicDistDir) && auth && httpAuth;
  if (enablePublicEntryPoint && auth && httpAuth) {
    logger.info(
      `App is running in protected mode, serving public content from ${publicDistDir}`
    );
    const publicRouter = Router__default.default();
    publicRouter.use(async (req, res, next) => {
      try {
        const credentials = await httpAuth.credentials(req, {
          allow: ["user", "service", "none"],
          allowLimitedAccess: true
        });
        if (credentials.principal.type === "none") {
          next();
        } else {
          next("router");
        }
      } catch {
        await httpAuth.issueUserCookie(res, {
          credentials: await auth.getNoneCredentials()
        });
        next();
      }
    });
    publicRouter.post(
      "*",
      express__default.default.urlencoded({ extended: true }),
      async (req, res, next) => {
        if (req.body.type === "sign-in") {
          const credentials = await auth.authenticate(req.body.token);
          if (!auth.isPrincipal(credentials, "user")) {
            throw new errors.AuthenticationError("Invalid token, not a user");
          }
          await httpAuth.issueUserCookie(res, {
            credentials
          });
          req.method = "GET";
          next("router");
        } else {
          throw new Error("Invalid POST request to /");
        }
      }
    );
    publicRouter.use(
      await createEntryPointRouter({
        logger: logger.child({ entry: "public" }),
        rootDir: publicDistDir,
        assetStore: assetStore == null ? void 0 : assetStore.withNamespace("public"),
        appConfigs
        // TODO(Rugvip): We should not be including the full config here
      })
    );
    router.use(publicRouter);
  }
  router.use(
    await createEntryPointRouter({
      logger: logger.child({ entry: "main" }),
      rootDir: appDistDir,
      assetStore,
      staticFallbackHandler,
      appConfigs
    })
  );
  return router;
}
async function createEntryPointRouter({
  logger,
  rootDir,
  assetStore,
  staticFallbackHandler,
  appConfigs
}) {
  const staticDir = path.resolve(rootDir, "static");
  const injectedConfigPath = appConfigs && await injectConfig({ appConfigs, logger, staticDir });
  const router = Router__default.default();
  const staticRouter = Router__default.default();
  staticRouter.use(
    express__default.default.static(staticDir, {
      setHeaders: (res, path) => {
        if (path === injectedConfigPath) {
          res.setHeader("Cache-Control", CACHE_CONTROL_REVALIDATE_CACHE);
        } else {
          res.setHeader("Cache-Control", CACHE_CONTROL_MAX_CACHE);
        }
      }
    })
  );
  if (assetStore) {
    const assets = await findStaticAssets(staticDir);
    await assetStore.storeAssets(assets);
    await assetStore.trimAssets({ maxAgeSeconds: 60 * 60 * 24 * 7 });
    staticRouter.use(createStaticAssetMiddleware(assetStore));
  }
  if (staticFallbackHandler) {
    staticRouter.use(staticFallbackHandler);
  }
  staticRouter.use(backendCommon.notFoundHandler());
  router.use("/static", staticRouter);
  router.use(
    express__default.default.static(rootDir, {
      setHeaders: (res, path) => {
        if (express__default.default.static.mime.lookup(path) === "text/html") {
          res.setHeader("Cache-Control", CACHE_CONTROL_NO_CACHE);
        }
      }
    })
  );
  router.get("/*", (_req, res) => {
    res.sendFile(path.resolve(rootDir, "index.html"), {
      headers: {
        // The Cache-Control header instructs the browser to not cache the index.html since it might
        // link to static assets from recently deployed versions.
        "cache-control": CACHE_CONTROL_NO_CACHE
      }
    });
  });
  return router;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router-B9fabz1o.cjs.js.map
