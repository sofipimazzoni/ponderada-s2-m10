'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var backendCommon = require('@backstage/backend-common');
var backendPluginApi = require('@backstage/backend-plugin-api');
var pluginTechdocsNode = require('@backstage/plugin-techdocs-node');
var Docker = require('dockerode');
var pluginTechdocsBackend = require('@backstage/plugin-techdocs-backend');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Docker__default = /*#__PURE__*/_interopDefaultCompat(Docker);

const techdocsPlugin = backendPluginApi.createBackendPlugin({
  pluginId: "techdocs",
  register(env) {
    let docsBuildStrategy;
    env.registerExtensionPoint(pluginTechdocsNode.techdocsBuildsExtensionPoint, {
      setBuildStrategy(buildStrategy) {
        if (docsBuildStrategy) {
          throw new Error("DocsBuildStrategy may only be set once");
        }
        docsBuildStrategy = buildStrategy;
      }
    });
    let customTechdocsGenerator;
    env.registerExtensionPoint(pluginTechdocsNode.techdocsGeneratorExtensionPoint, {
      setTechdocsGenerator(generator) {
        if (customTechdocsGenerator) {
          throw new Error("TechdocsGenerator may only be set once");
        }
        customTechdocsGenerator = generator;
      }
    });
    const customPreparers = /* @__PURE__ */ new Map();
    env.registerExtensionPoint(pluginTechdocsNode.techdocsPreparerExtensionPoint, {
      registerPreparer(protocol, preparer) {
        if (customPreparers.has(protocol)) {
          throw new Error(
            `Preparer for protocol ${protocol} is already registered`
          );
        }
        customPreparers.set(protocol, preparer);
      }
    });
    env.registerInit({
      deps: {
        config: backendPluginApi.coreServices.rootConfig,
        logger: backendPluginApi.coreServices.logger,
        urlReader: backendPluginApi.coreServices.urlReader,
        http: backendPluginApi.coreServices.httpRouter,
        discovery: backendPluginApi.coreServices.discovery,
        cache: backendPluginApi.coreServices.cache,
        httpAuth: backendPluginApi.coreServices.httpAuth,
        auth: backendPluginApi.coreServices.auth
      },
      async init({
        config,
        logger,
        urlReader,
        http,
        discovery,
        cache,
        httpAuth,
        auth
      }) {
        const winstonLogger = backendCommon.loggerToWinstonLogger(logger);
        const preparers = await pluginTechdocsNode.Preparers.fromConfig(config, {
          reader: urlReader,
          logger: winstonLogger
        });
        for (const [protocol, preparer] of customPreparers.entries()) {
          preparers.register(protocol, preparer);
        }
        const dockerClient = new Docker__default.default();
        const containerRunner = new backendCommon.DockerContainerRunner({ dockerClient });
        const generators = await pluginTechdocsNode.Generators.fromConfig(config, {
          logger: winstonLogger,
          containerRunner,
          customGenerator: customTechdocsGenerator
        });
        const publisher = await pluginTechdocsNode.Publisher.fromConfig(config, {
          logger: winstonLogger,
          discovery
        });
        await publisher.getReadiness();
        const cacheManager = backendCommon.cacheToPluginCacheManager(cache);
        http.use(
          await pluginTechdocsBackend.createRouter({
            logger: winstonLogger,
            cache: cacheManager,
            docsBuildStrategy,
            preparers,
            generators,
            publisher,
            config,
            discovery,
            httpAuth,
            auth
          })
        );
        http.addAuthPolicy({
          path: "/static",
          allow: "user-cookie"
        });
      }
    });
  }
});

exports.default = techdocsPlugin;
//# sourceMappingURL=alpha.cjs.js.map
