'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@backstage/errors');
var integration = require('@backstage/integration');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var yaml = require('yaml');
var crypto = require('crypto');
var backendPluginApi = require('@backstage/backend-plugin-api');
var alpha = require('@backstage/plugin-scaffolder-node/alpha');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);
var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);

const examples = [
  {
    description: "Initializes a git repository with the content in the workspace, and publishes it to Gitea with the default configuration.",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner"
          }
        }
      ]
    })
  },
  {
    description: "Initializes a Gitea repository with a description.",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner",
            description: "Initialize a gitea repository"
          }
        }
      ]
    })
  },
  {
    description: "Initializes a Gitea repository with a default Branch, if not set defaults to main",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner",
            defaultBranch: "main"
          }
        }
      ]
    })
  },
  {
    description: "Initializes a Gitea repository with an initial commit message, if not set defaults to `initial commit`",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner",
            gitCommitMessage: "Initial Commit Message"
          }
        }
      ]
    })
  },
  {
    description: "Initializes a Gitea repository with a repo Author Name, if not set defaults to Scaffolder",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner",
            gitAuthorName: "John Doe"
          }
        }
      ]
    })
  },
  {
    description: "Initializes a Gitea repository with a repo Author Email",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner",
            gitAuthorEmail: "johndoe@email.com"
          }
        }
      ]
    })
  },
  {
    description: "Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner",
            sourcePath: "repository/"
          }
        }
      ]
    })
  },
  {
    description: "Initializes a Gitea repository with all properties being set",
    example: yaml__default.default.stringify({
      steps: [
        {
          id: "publish",
          action: "publish:gitea",
          name: "Publish to Gitea",
          input: {
            repoUrl: "gitea.com?repo=repo&owner=owner",
            description: "Initialize a gitea repository",
            defaultBranch: "staging",
            gitCommitMessage: "Initial Commit Message",
            gitAuthorName: "John Doe",
            gitAuthorEmail: "johndoe@email.com",
            sourcePath: "repository/"
          }
        }
      ]
    })
  }
];

const checkGiteaContentUrl = async (config, options) => {
  const { owner, repo, defaultBranch } = options;
  let response;
  const getOptions = {
    method: "GET"
  };
  try {
    response = await fetch(
      `${config.baseUrl}/${owner}/${repo}/src/branch/${defaultBranch}`,
      getOptions
    );
  } catch (e) {
    throw new Error(
      `Unable to get the repository: ${owner}/${repo} metadata , ${e}`
    );
  }
  return response;
};
const checkGiteaOrg = async (config, options) => {
  const { owner } = options;
  let response;
  const getOptions = {
    method: "GET",
    headers: {
      ...integration.getGiteaRequestOptions(config).headers,
      "Content-Type": "application/json"
    }
  };
  try {
    response = await fetch(
      `${config.baseUrl}/api/v1/orgs/${owner}`,
      getOptions
    );
  } catch (e) {
    throw new Error(
      `Unable to get the Organization: ${owner}; Error cause: ${e.cause.message}`
    );
  }
  if (response.status !== 200) {
    throw new Error(
      `Organization ${owner} do not exist. Please create it first !`
    );
  }
};
const createGiteaProject = async (config, options) => {
  const { projectName, description, owner } = options;
  let response;
  const postOptions = {
    method: "POST",
    body: JSON.stringify({
      name: projectName,
      description
    }),
    headers: {
      ...integration.getGiteaRequestOptions(config).headers,
      "Content-Type": "application/json"
    }
  };
  try {
    response = await fetch(
      `${config.baseUrl}/api/v1/orgs/${owner}/repos`,
      postOptions
    );
  } catch (e) {
    throw new Error(`Unable to create repository, ${e}`);
  }
  if (response.status !== 201) {
    throw new Error(
      `Unable to create repository, ${response.status} ${response.statusText}, ${await response.text()}`
    );
  }
};
const generateCommitMessage = (config, commitSubject) => {
  const changeId = crypto__default.default.randomBytes(20).toString("hex");
  const msg = `${config.getOptionalString("scaffolder.defaultCommitMessage") || commitSubject}

Change-Id: I${changeId}`;
  return msg;
};
async function checkAvailabilityGiteaRepository(maxDuration, integrationConfig, options) {
  var _a;
  const startTimestamp = Date.now();
  const { owner, repo, defaultBranch, ctx } = options;
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  let response;
  while (Date.now() - startTimestamp < maxDuration) {
    if ((_a = ctx.signal) == null ? void 0 : _a.aborted)
      return;
    response = await checkGiteaContentUrl(integrationConfig, {
      owner,
      repo,
      defaultBranch
    });
    if (response.status !== 200) {
      await sleep(1e3);
    } else {
      break;
    }
  }
}
function createPublishGiteaAction(options) {
  const { integrations, config } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:gitea",
    description: "Initializes a git repository using the content of the workspace, and publishes it to Gitea.",
    examples,
    schema: {
      input: {
        type: "object",
        required: ["repoUrl"],
        properties: {
          repoUrl: {
            title: "Repository Location",
            type: "string"
          },
          description: {
            title: "Repository Description",
            type: "string"
          },
          defaultBranch: {
            title: "Default Branch",
            type: "string",
            description: `Sets the default branch on the repository. The default value is 'main'`
          },
          gitCommitMessage: {
            title: "Git Commit Message",
            type: "string",
            description: `Sets the commit message on the repository. The default value is 'initial commit'`
          },
          gitAuthorName: {
            title: "Default Author Name",
            type: "string",
            description: `Sets the default author name for the commit. The default value is 'Scaffolder'`
          },
          gitAuthorEmail: {
            title: "Default Author Email",
            type: "string",
            description: `Sets the default author email for the commit.`
          },
          sourcePath: {
            title: "Source Path",
            type: "string",
            description: `Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository.`
          }
        }
      },
      output: {
        type: "object",
        properties: {
          remoteUrl: {
            title: "A URL to the repository with the provider",
            type: "string"
          },
          repoContentsUrl: {
            title: "A URL to the root of the repository",
            type: "string"
          },
          commitHash: {
            title: "The git commit hash of the initial commit",
            type: "string"
          }
        }
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        description,
        defaultBranch = "main",
        gitAuthorName,
        gitAuthorEmail,
        gitCommitMessage = "initial commit",
        sourcePath
      } = ctx.input;
      const { repo, host, owner } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      const integrationConfig = integrations.gitea.byHost(host);
      if (!integrationConfig) {
        throw new errors.InputError(
          `No matching integration configuration for host ${host}, please check your integrations config`
        );
      }
      const { username, password } = integrationConfig.config;
      if (!username || !password) {
        throw new Error("Credentials for the gitea ${host} required.");
      }
      if (owner) {
        await checkGiteaOrg(integrationConfig.config, { owner });
      }
      await createGiteaProject(integrationConfig.config, {
        description,
        owner,
        projectName: repo
      });
      const auth = {
        username,
        password
      };
      const gitAuthorInfo = {
        name: gitAuthorName ? gitAuthorName : config.getOptionalString("scaffolder.defaultAuthor.name"),
        email: gitAuthorEmail ? gitAuthorEmail : config.getOptionalString("scaffolder.defaultAuthor.email")
      };
      const remoteUrl = `${integrationConfig.config.baseUrl}/${owner}/${repo}.git`;
      const commitResult = await pluginScaffolderNode.initRepoAndPush({
        dir: pluginScaffolderNode.getRepoSourceDirectory(ctx.workspacePath, sourcePath),
        remoteUrl,
        auth,
        defaultBranch,
        logger: ctx.logger,
        commitMessage: generateCommitMessage(config, gitCommitMessage),
        gitAuthorInfo
      });
      const maxDuration = 2e4;
      await checkAvailabilityGiteaRepository(
        maxDuration,
        integrationConfig.config,
        {
          owner,
          repo,
          defaultBranch,
          ctx
        }
      );
      const repoContentsUrl = `${integrationConfig.config.baseUrl}/${owner}/${repo}/src/branch/${defaultBranch}/`;
      ctx.output("remoteUrl", remoteUrl);
      ctx.output("commitHash", commitResult == null ? void 0 : commitResult.commitHash);
      ctx.output("repoContentsUrl", repoContentsUrl);
    }
  });
}

const giteaModule = backendPluginApi.createBackendModule({
  pluginId: "scaffolder",
  moduleId: "gitea",
  register({ registerInit }) {
    registerInit({
      deps: {
        scaffolder: alpha.scaffolderActionsExtensionPoint,
        config: backendPluginApi.coreServices.rootConfig
      },
      async init({ scaffolder, config }) {
        const integrations = integration.ScmIntegrations.fromConfig(config);
        scaffolder.addActions(
          createPublishGiteaAction({
            integrations,
            config
          })
        );
      }
    });
  }
});

exports.createPublishGiteaAction = createPublishGiteaAction;
exports.default = giteaModule;
//# sourceMappingURL=index.cjs.js.map
