'use strict';

var zod = require('zod');
var express = require('express');
var Router = require('express-promise-router');
var backendCommon = require('@backstage/backend-common');
var errors = require('@backstage/errors');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var fetch = require('node-fetch');
var lodash = require('lodash');
var DataLoader = require('dataloader');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var express__default = /*#__PURE__*/_interopDefaultCompat(express);
var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);
var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);
var DataLoader__default = /*#__PURE__*/_interopDefaultCompat(DataLoader);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const responseSchema = zod.z.object({
  items: zod.z.array(
    zod.z.object({
      id: zod.z.string(),
      result: zod.z.literal(pluginPermissionCommon.AuthorizeResult.ALLOW).or(zod.z.literal(pluginPermissionCommon.AuthorizeResult.DENY))
    })
  )
});
class PermissionIntegrationClient {
  constructor(options) {
    __publicField(this, "discovery");
    __publicField(this, "auth");
    this.discovery = options.discovery;
    this.auth = options.auth;
  }
  async applyConditions(pluginId, credentials, decisions) {
    const baseUrl = await this.discovery.getBaseUrl(pluginId);
    const endpoint = `${baseUrl}/.well-known/backstage/permissions/apply-conditions`;
    const token = this.auth.isPrincipal(credentials, "none") ? void 0 : await this.auth.getPluginRequestToken({
      onBehalfOf: credentials,
      targetPluginId: pluginId
    }).then((t) => t.token);
    const response = await fetch__default.default(endpoint, {
      method: "POST",
      body: JSON.stringify({
        items: decisions.map(
          ({ id, resourceRef, resourceType, conditions }) => ({
            id,
            resourceRef,
            resourceType,
            conditions
          })
        )
      }),
      headers: {
        ...token ? { authorization: `Bearer ${token}` } : {},
        "content-type": "application/json"
      }
    });
    if (!response.ok) {
      throw await errors.ResponseError.fromResponse(response);
    }
    const result = responseSchema.parse(await response.json());
    return result.items;
  }
}

const attributesSchema = zod.z.object({
  action: zod.z.union([
    zod.z.literal("create"),
    zod.z.literal("read"),
    zod.z.literal("update"),
    zod.z.literal("delete")
  ]).optional()
});
const permissionSchema = zod.z.union([
  zod.z.object({
    type: zod.z.literal("basic"),
    name: zod.z.string(),
    attributes: attributesSchema
  }),
  zod.z.object({
    type: zod.z.literal("resource"),
    name: zod.z.string(),
    attributes: attributesSchema,
    resourceType: zod.z.string()
  })
]);
const evaluatePermissionRequestSchema = zod.z.object({
  id: zod.z.string(),
  resourceRef: zod.z.string().optional(),
  permission: permissionSchema
});
const evaluatePermissionRequestBatchSchema = zod.z.object({
  items: zod.z.array(evaluatePermissionRequestSchema)
});
const handleRequest = async (requests, policy, permissionIntegrationClient, credentials, auth, userInfo) => {
  const applyConditionsLoaderFor = lodash.memoize((pluginId) => {
    return new DataLoader__default.default(
      (batch) => permissionIntegrationClient.applyConditions(pluginId, credentials, batch)
    );
  });
  let user;
  if (auth.isPrincipal(credentials, "user")) {
    const { ownershipEntityRefs } = await userInfo.getUserInfo(credentials);
    const { token } = await auth.getPluginRequestToken({
      onBehalfOf: credentials,
      targetPluginId: "catalog"
      // TODO: unknown at this point
    });
    user = {
      identity: {
        type: "user",
        userEntityRef: credentials.principal.userEntityRef,
        ownershipEntityRefs
      },
      token
    };
  }
  return Promise.all(
    requests.map(
      ({ id, resourceRef, ...request }) => policy.handle(request, user).then((decision) => {
        if (decision.result !== pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
          return {
            id,
            ...decision
          };
        }
        if (!pluginPermissionCommon.isResourcePermission(request.permission)) {
          throw new Error(
            `Conditional decision returned from permission policy for non-resource permission ${request.permission.name}`
          );
        }
        if (decision.resourceType !== request.permission.resourceType) {
          throw new Error(
            `Invalid resource conditions returned from permission policy for permission ${request.permission.name}`
          );
        }
        if (!resourceRef) {
          return {
            id,
            ...decision
          };
        }
        return applyConditionsLoaderFor(decision.pluginId).load({
          id,
          resourceRef,
          ...decision
        });
      })
    )
  );
};
async function createRouter(options) {
  const { policy, discovery, config, logger } = options;
  const { auth, httpAuth, userInfo } = backendCommon.createLegacyAuthAdapters(options);
  if (!config.getOptionalBoolean("permission.enabled")) {
    logger.warn(
      "Permission backend started with permissions disabled. Enable permissions by setting permission.enabled=true."
    );
  }
  const permissionIntegrationClient = new PermissionIntegrationClient({
    discovery,
    auth
  });
  const router = Router__default.default();
  router.use(express__default.default.json());
  router.get("/health", (_, response) => {
    response.json({ status: "ok" });
  });
  router.post(
    "/authorize",
    async (req, res) => {
      const credentials = await httpAuth.credentials(req, {
        allow: ["user", "none"]
      });
      const parseResult = evaluatePermissionRequestBatchSchema.safeParse(
        req.body
      );
      if (!parseResult.success) {
        throw new errors.InputError(parseResult.error.toString());
      }
      const body = parseResult.data;
      res.json({
        items: await handleRequest(
          body.items,
          policy,
          permissionIntegrationClient,
          credentials,
          auth,
          userInfo
        )
      });
    }
  );
  router.use(backendCommon.errorHandler());
  return router;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router-CjGokdX5.cjs.js.map
