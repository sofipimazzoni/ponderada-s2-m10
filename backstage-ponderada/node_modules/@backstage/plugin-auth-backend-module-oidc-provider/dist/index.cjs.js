'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var openidClient = require('openid-client');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var backendPluginApi = require('@backstage/backend-plugin-api');

const HTTP_OPTION_TIMEOUT = 1e4;
const httpOptionsProvider = (_url, options) => {
  return {
    ...options,
    timeout: HTTP_OPTION_TIMEOUT
  };
};
const oidcAuthenticator = pluginAuthNode.createOAuthAuthenticator({
  shouldPersistScopes: true,
  defaultProfileTransform: async (input) => ({
    profile: {
      email: input.fullProfile.userinfo.email,
      picture: input.fullProfile.userinfo.picture,
      displayName: input.fullProfile.userinfo.name
    }
  }),
  initialize({ callbackUrl, config }) {
    const clientId = config.getString("clientId");
    const clientSecret = config.getString("clientSecret");
    const metadataUrl = config.getString("metadataUrl");
    const customCallbackUrl = config.getOptionalString("callbackUrl");
    const tokenEndpointAuthMethod = config.getOptionalString(
      "tokenEndpointAuthMethod"
    );
    const tokenSignedResponseAlg = config.getOptionalString(
      "tokenSignedResponseAlg"
    );
    const initializedScope = config.getOptionalString("scope");
    const initializedPrompt = config.getOptionalString("prompt");
    openidClient.Issuer[openidClient.custom.http_options] = httpOptionsProvider;
    const promise = openidClient.Issuer.discover(metadataUrl).then((issuer) => {
      issuer[openidClient.custom.http_options] = httpOptionsProvider;
      issuer.Client[openidClient.custom.http_options] = httpOptionsProvider;
      const client = new issuer.Client({
        access_type: "offline",
        // this option must be passed to provider to receive a refresh token
        client_id: clientId,
        client_secret: clientSecret,
        redirect_uris: [customCallbackUrl || callbackUrl],
        response_types: ["code"],
        token_endpoint_auth_method: tokenEndpointAuthMethod || "client_secret_basic",
        id_token_signed_response_alg: tokenSignedResponseAlg || "RS256",
        scope: initializedScope || ""
      });
      client[openidClient.custom.http_options] = httpOptionsProvider;
      const strategy = new openidClient.Strategy(
        {
          client,
          passReqToCallback: false
        },
        (tokenset, userinfo, done) => {
          if (typeof done !== "function") {
            throw new Error(
              "OIDC IdP must provide a userinfo_endpoint in the metadata response"
            );
          }
          done(
            void 0,
            { tokenset, userinfo },
            { refreshToken: tokenset.refresh_token }
          );
        }
      );
      const helper = pluginAuthNode.PassportOAuthAuthenticatorHelper.from(strategy);
      return { helper, client, strategy };
    });
    return { initializedScope, initializedPrompt, promise };
  },
  async start(input, ctx) {
    const { initializedScope, initializedPrompt, promise } = ctx;
    const { helper, strategy } = await promise;
    const options = {
      scope: input.scope || initializedScope || "openid profile email",
      state: input.state
    };
    const prompt = initializedPrompt || "none";
    if (prompt !== "auto") {
      options.prompt = prompt;
    }
    return new Promise((resolve, reject) => {
      strategy.error = reject;
      return helper.start(input, {
        ...options
      }).then(resolve);
    });
  },
  async authenticate(input, ctx) {
    var _a;
    const { strategy } = await ctx.promise;
    const { result, privateInfo } = await pluginAuthNode.PassportHelpers.executeFrameHandlerStrategy(input.req, strategy);
    return {
      fullProfile: result,
      session: {
        accessToken: result.tokenset.access_token,
        tokenType: (_a = result.tokenset.token_type) != null ? _a : "bearer",
        scope: result.tokenset.scope,
        expiresInSeconds: result.tokenset.expires_in,
        idToken: result.tokenset.id_token,
        refreshToken: privateInfo.refreshToken
      }
    };
  },
  async refresh(input, ctx) {
    const { client } = await ctx.promise;
    const tokenset = await client.refresh(input.refreshToken);
    if (!tokenset.access_token) {
      throw new Error("Refresh failed");
    }
    const userinfo = await client.userinfo(tokenset.access_token);
    return new Promise((resolve, reject) => {
      var _a;
      if (!tokenset.access_token) {
        reject(new Error("Refresh Failed"));
      }
      resolve({
        fullProfile: { userinfo, tokenset },
        session: {
          accessToken: tokenset.access_token,
          tokenType: (_a = tokenset.token_type) != null ? _a : "bearer",
          scope: tokenset.scope,
          expiresInSeconds: tokenset.expires_in,
          idToken: tokenset.id_token,
          refreshToken: tokenset.refresh_token
        }
      });
    });
  },
  async logout(input, ctx) {
    const { client } = await ctx.promise;
    if (input.refreshToken) {
      await client.revoke(input.refreshToken);
    }
  }
});

exports.oidcSignInResolvers = void 0;
((oidcSignInResolvers2) => {
  oidcSignInResolvers2.emailLocalPartMatchingUserEntityName = pluginAuthNode.commonSignInResolvers.emailLocalPartMatchingUserEntityName;
  oidcSignInResolvers2.emailMatchingUserEntityProfileEmail = pluginAuthNode.commonSignInResolvers.emailMatchingUserEntityProfileEmail;
})(exports.oidcSignInResolvers || (exports.oidcSignInResolvers = {}));

const authModuleOidcProvider = backendPluginApi.createBackendModule({
  pluginId: "auth",
  moduleId: "oidc-provider",
  register(reg) {
    reg.registerInit({
      deps: {
        providers: pluginAuthNode.authProvidersExtensionPoint
      },
      async init({ providers }) {
        providers.registerProvider({
          providerId: "oidc",
          factory: pluginAuthNode.createOAuthProviderFactory({
            authenticator: oidcAuthenticator,
            signInResolverFactories: {
              ...exports.oidcSignInResolvers,
              ...pluginAuthNode.commonSignInResolvers
            }
          })
        });
      }
    });
  }
});

exports.default = authModuleOidcProvider;
exports.oidcAuthenticator = oidcAuthenticator;
//# sourceMappingURL=index.cjs.js.map
